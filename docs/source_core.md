# src/core/alignment_nav.py

from typing import Iterator, Tuple, Optional, Any, Dict


class NavigationLog:
    knowledge_id: str
    _max_size: int
    _prune_threshold: int
    _log: bytearray
    _is_dirty: bool
    _identity_run_count: int
    _lock: Any  # threading.RLock
    manager: Optional[Any]

    def __init__(self, knowledge_id: str, storage_manager: Any, max_size: int = 1048576) -> None: ...
    def append(self, id0_code: int, id1_code: int, *, fork_ok: bool = True) -> None: ...
    def _flush_identity_run(self) -> None: ...
    def _append_raw_byte(self, byte_val: int) -> None: ...
    def iter_steps(self, reverse: bool = False) -> Iterator[Tuple[int, int]]: ...
    @property
    def step_count(self) -> int: ...
    def shutdown(self) -> None: ...
    def load_from_disk(self) -> None: ...
    def persist_to_disk(self) -> None: ...
    def _prune(self) -> None: ...
    def validate_gene_checksum(self, gene: Dict[str, Any]) -> bool: ...

===
# src/core/extension_manager.py

from typing import Optional, Any, Tuple, Dict, List


class ExtensionManager:
    _session_id: str
    _knowledge_id: str
    extensions: Dict[str, Any]
    engine: Any  # GyroEngine
    navigation_log: Any  # NavigationLog
    _output_handler: Optional[Any]

    def __init__(self, session_id: Optional[str] = None, knowledge_id: str = "") -> None: ...
    def _initialize_system_extensions(self) -> None: ...
    def _initialize_application_extensions(self) -> None: ...
    def _load_session_state(self) -> None: ...
    def _validate_system_integrity(self) -> None: ...
    def _cleanup_on_error(self) -> None: ...
    def get_extension(self, name: str) -> Any: ...
    def get_session_id(self) -> str: ...
    def get_knowledge_id(self) -> str: ...
    def gyro_genetic_memory(self, tag: str, data: Any = None) -> Any: ...
    def gyro_epigenetic_memory(self, tag: str, data: Any = None) -> Any: ...
    def gyro_structural_memory(self, tag: str, data: Any = None) -> Any: ...
    def gyro_somatic_memory(self, tag: str, data: Any = None) -> Any: ...
    def gyro_immunity_memory(self, tag: str, data: Any = None) -> Any: ...
    def gyro_operation(self, input_byte: int) -> Tuple[int, int]: ...
    def _notify_extensions(self, packed_nav: int, input_byte: int) -> None: ...
    def export_knowledge(self, output_path: str) -> None: ...
    def import_knowledge(self, bundle_path: str) -> str: ...
    def fork_knowledge(self, new_session: bool = False) -> str: ...
    def link_to_knowledge(self, knowledge_id: str) -> None: ...
    def get_system_health(self) -> Dict[str, Any]: ...
    def shutdown(self, persist_only: bool = False) -> None: ...
    def _get_event_tensor(self, temporal: str) -> Any: ...
    def _get_nest_tensor(self, temporal: str) -> Any: ...
    def _get_decoded_gene_state(self, temporal: str) -> Dict[str, Any]: ...
    def _get_recent_events(self, count: int) -> List[int]: ...
    def _load_extension_states(self) -> None: ...
    def _get_user_key(self) -> bytes: ...
    def _handle_language_output(self, text: str) -> None: ...
    def export_session(self, output_path: str) -> None: ...
    def import_session(self, bundle_path: str) -> str: ...

===

# src/core/gyro_api.py

from typing import Optional, Dict, List, Iterable, Union, Tuple, Any
from pathlib import Path


_active_sessions: Dict[str, Any]  # Dict[str, ExtensionManager]


def initialize_session(session_id: Optional[str] = None, knowledge_id: Optional[str] = None) -> str: ...
def shutdown_session(session_id: str) -> None: ...
def list_active_sessions() -> List[str]: ...
def get_session_info(session_id: str) -> Dict[str, Any]: ...
def process_byte(session_id: str, input_byte: int) -> Optional[Tuple[int, int]]: ...
def process_byte_stream(session_id: str, byte_stream: Iterable[int]) -> int: ...
def process_text(session_id: str, text: str, encoding: str = "utf-8") -> int: ...
def process_file(session_id: str, file_path: Union[str, Path], chunk_size: int = 8192) -> int: ...
def export_knowledge(session_id: str, output_path: Union[str, Path]) -> None: ...
def import_knowledge(bundle_path: Union[str, Path], new_session: bool = True) -> str: ...
def fork_knowledge(session_id: str, new_session: bool = False) -> str: ...
def link_session_to_knowledge(session_id: str, knowledge_id: str) -> None: ...
def query_memory(session_id: str, tag: str) -> Any: ...
def get_navigation_history(session_id: str, count: int = 100, reverse: bool = True) -> List[Tuple[int, int]]: ...
def validate_system_integrity() -> Tuple[bool, Dict[str, Any]]: ...
def cleanup_inactive_sessions() -> int: ...
def ingest_curriculum_resource(resource_key: str, dest_dir: str = "./data/curriculum", progress_cb=None) -> bool: ...

===

# src/core/gyro_core.py

from typing import Tuple, Dict, Optional
import torch


class GyroEngine:
    gene: Dict[str, torch.Tensor]
    phase: int

    def __init__(self, harmonics_path: Optional[str] = None) -> None: ...
    def _load_and_validate_harmonics(self, harmonics_path: str) -> None: ...
    def execute_cycle(self, input_byte: int) -> Tuple[int, int]: ...
    def _get_gene_constant(self) -> Dict[str, torch.Tensor]: ...
    def _compute_gene_checksum(self) -> bytes: ...
    def load_phase(self, phase: int) -> None: ...


def gyration_op(tensor: torch.Tensor, code: int, clone: bool = True) -> torch.Tensor: ...

===

# src/core/gyro_errors.py


class GyroError(Exception): ...
class GyroTagError(GyroError): ...
class GyroPhaseError(GyroError): ...
class GyroNoResonanceError(GyroError): ...
class GyroIntegrityError(GyroError): ...
class GyroImmutabilityError(GyroError): ...
class GyroNavigationError(GyroError): ...
class GyroForkError(GyroError): ...
class GyroSessionError(GyroError): ...
class GyroExtensionError(GyroError): ...
class GyroStorageError(GyroError): ...
class GyroConfigError(GyroError): ...

===

# src/core/gyro_tag_parser.py

from typing import Dict


def validate_tag(tag: str) -> bool: ...
def parse_tag(tag: str) -> Dict[str, str]: ...

===

# src/core/log_decoder.py

from typing import Iterator


def decode_log_stream(raw_byte_iterator: Iterator[int]) -> Iterator[int]: ...
def encode_identity_run(run_length: int) -> bytes: ...

===

# src/extensions/__init__.py

from typing import Any

GyroExtension: Any
ext_StorageManager: Any
ext_ForkManager: Any
ext_StateHelper: Any
ext_EventClassifier: Any
ext_ErrorHandler: Any
ext_NavigationHelper: Any
ext_APIGateway: Any
ext_SystemMonitor: Any
ext_PerformanceTracker: Any
ext_Cryptographer: Any
ext_LanguageEgress: Any
ext_MultiResolution: Any
ext_BloomFilter: Any
ext_SpinPIV: Any
ext_CosetKnowledge: Any

===

# src/extensions/base.py

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional


class GyroExtension(ABC):
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...
    def ext_on_navigation_event(self, nav_event: int, input_byte: Optional[int] = None) -> None: ...
    def validate_footprint(self) -> bool: ...
    def get_pattern_filename(self) -> str: ...
    def shutdown(self) -> None: ...
    def persist_state(self) -> None: ...
    def load_state(self) -> None: ...

===

# src/extensions/ext_api_gateway.py

from typing import Dict, Any


class ext_APIGateway:
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...

===

# src/extensions/ext_bloom_filter.py

from typing import Dict, Any, Optional
from extensions.base import GyroExtension


class ext_BloomFilter(GyroExtension):
    def __init__(self):
        self.m: int
        self.k: int
        self.n: int
        self.bit_array: int
        self._inserted_patterns: set[str]
        self._false_positive_tests: int
        self._total_tests: int

    def ext_gyration_hash(self, pattern: str, op_type: int) -> int: ...
    def ext_insert_pattern(self, pattern: str) -> None: ...
    def ext_contains(self, pattern: str) -> bool: ...
    def get_saturation(self) -> float: ...
    def get_false_positive_rate(self) -> float: ...
    def get_theoretical_fpr(self) -> float: ...
    def should_reset(self) -> bool: ...
    def reset(self) -> None: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...
    def ext_on_navigation_event(self, nav_event: int, input_byte: Optional[int] = None) -> None: ...

===

# src/extensions/ext_coset_knowledge.py

from typing import Dict, Any, List, Optional


class ext_CosetKnowledge:
    def __init__(self) -> None: ...
    def ext_add_pattern(self, pattern: bytes) -> str: ...
    def _find_coset_representative(self, pattern: bytes) -> Optional[str]: ...
    def _calculate_similarity(self, pattern1: bytes, pattern2: bytes) -> float: ...
    def _update_compression_ratio(self) -> None: ...
    def ext_get_coset_info(self, pattern_hash: str) -> Dict[str, Any]: ...
    def ext_get_semantic_groups(self) -> List[Dict[str, Any]]: ...
    def ext_reconstruct_pattern(self, pattern_hash: str) -> Optional[bytes]: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...
    def ext_on_navigation_event(self, nav_event: int, input_byte: Optional[int] = None) -> None: ...

===

# src/extensions/ext_cryptographer.py

from typing import Dict, Any
from .base import GyroExtension


class ext_Cryptographer(GyroExtension):
    user_key: bytes
    counter: int

    def __init__(self, user_key: bytes) -> None: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def _generate_keystream(self, length: int) -> bytes: ...
    def encrypt(self, data: bytes) -> bytes: ...
    def decrypt(self, data: bytes) -> bytes: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...
    def process_navigation_event(self, event: Any, input_byte: Any = None) -> Any: ...
    def get_pattern_filename(self) -> str: ...

===

# src/extensions/ext_error_handler.py

from typing import Dict, Any


class ext_ErrorHandler:
    def __init__(self) -> None: ...
    def handle_error(self, error: Exception) -> None: ...
    def log_extension_error(self, extension_name: str, error: Exception) -> None: ...
    def _update_stats(self, error_type: str) -> None: ...
    def _recover_phase_error(self, error: Exception) -> None: ...
    def _recover_navigation_error(self, error: Exception) -> None: ...
    def _recover_immutability_error(self, error: Exception) -> None: ...
    def _recover_extension_error(self, error: Exception) -> None: ...
    def _log_recovery(self, message: str) -> None: ...
    def get_error_report(self) -> Dict[str, Any]: ...
    def clear_error_state(self) -> None: ...
    def has_critical_errors(self) -> bool: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...

===

# src/extensions/ext_event_classifier.py

from typing import Dict, Any, List


class ext_EventClassifier:
    def __init__(self) -> None: ...
    def is_learning_event(self, event_data: Any) -> bool: ...
    def classify_event(self, event_data: Any) -> str: ...
    def _track_event(self, event_data: Any, is_learning: bool) -> None: ...
    def _hash_event(self, event_data: Any) -> str: ...
    def get_event_statistics(self) -> Dict[str, int]: ...
    def get_recent_learning_events(self, count: int = 10) -> List[Dict[str, Any]]: ...
    def register_learning_pattern(self, pattern: str) -> None: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...

===

# src/extensions/ext_fork_manager.py

from typing import Optional, Dict, Any


class ext_ForkManager:
    def __init__(self, storage_manager: Any) -> None: ...
    def _update_immutability_status(self) -> None: ...
    def is_current_knowledge_immutable(self) -> bool: ...
    def ensure_writable(self, current_nav_log: Any) -> Any: ...
    def fork(self) -> str: ...
    def mark_immutable(self, knowledge_id: Optional[str] = None) -> None: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...

===

# src/extensions/ext_language_egress.py

from typing import Dict, Any, Optional
import threading


class ext_LanguageEgress:
    def __init__(self) -> None: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def process_navigation_event(self, nav_event: int, input_byte: Optional[int] = None) -> None: ...
    def _process_complete_cycle(self) -> None: ...
    def _navigation_to_text(self, navigation_cycle: list[int]) -> bytes: ...
    def _chunk_to_char(self, nav_chunk: list[int]) -> int: ...
    def _emit_complete_sentences(self) -> None: ...
    def _emit_text(self, text: str) -> None: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...
    def get_pattern_filename(self) -> str: ...
    def _extract_language_patterns(self) -> Dict[str, Any]: ...
    def _get_character_mappings(self) -> Dict[str, Any]: ...

===
# src/extensions/ext_multi_resolution.py

from typing import Dict, Any, Optional


class ext_MultiResolution:
    def __init__(self) -> None: ...
    def ext_on_navigation_event(self, nav_event: int, input_byte: Optional[int] = None) -> None: ...
    def _record_boundary(self, boundary_type: str, defect_value: int, input_byte: Optional[int]) -> None: ...
    def ext_get_boundary_analysis(self) -> Dict[str, Any]: ...
    def ext_predict_next_boundary(self) -> Dict[str, float]: ...
    def ext_get_text_structure(self) -> Dict[str, Any]: ...
    def process_navigation_event(self, nav_event: int, input_byte: int = None) -> None: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...

===

# ext_navigation_helper.py

from typing import Dict, Any, List, Tuple, Optional


class ext_NavigationHelper:
    def __init__(self) -> None: ...
    def record_navigation(self, phase: int, ops: Optional[Tuple[int, int]]) -> None: ...
    def _get_boundary_type(self, phase: int) -> Optional[str]: ...
    def _classify_operator(self, ops: Tuple[int, int]) -> None: ...
    def get_resonance_info(self) -> Dict[str, Any]: ...
    def get_operator_info(self) -> Dict[str, Any]: ...
    def _get_last_operators(self) -> Optional[Tuple[int, int]]: ...
    def predict_next_boundary(self, current_phase: int) -> Tuple[int, str]: ...
    def detect_navigation_patterns(self) -> List[Dict[str, Any]]: ...
    def get_cycle_progress(self, current_phase: int) -> Dict[str, Any]: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...
    def ext_on_navigation_event(self, nav_event: int, input_byte: Optional[int] = None) -> None: ...

===

# ext_performance_tracker.py

from typing import Dict, Any, Optional


class ext_PerformanceTracker:
    def __init__(self) -> None: ...
    def start_operation(self, operation_name: Optional[str] = None) -> None: ...
    def end_operation(self, resonated: bool = False, error: Optional[Exception] = None) -> float: ...
    def ext_get_operation_stats(self, operation_name: str) -> Dict[str, Any]: ...
    def ext_get_system_performance(self) -> Dict[str, Any]: ...
    def ext_get_performance_report(self) -> Dict[str, Any]: ...
    def ext_reset_metrics(self) -> None: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...
    def _get_memory_usage(self) -> float: ...
    def _update_throughput(self) -> None: ...
    def _record_alert(self, alert_type: str, details: Dict[str, Any]) -> None: ...
    def _format_performance_summary(self, metrics: Dict[str, Any]) -> str: ...
    def _calculate_efficiency_score(self, metrics: Dict[str, Any]) -> float: ...

===

# ext_phase_controller.py

from typing import Dict, Any


class ext_PhaseController:
    def __init__(self) -> None: ...
    def ext_advance_phase(self, current_phase: int, resonated: bool) -> int: ...
    def ext_set_strategy(self, strategy: str) -> bool: ...
    def ext_set_transition_rule(self, rule: str, enabled: bool) -> bool: ...
    def ext_add_phase_mapping(self, from_phase: int, to_phase: int) -> None: ...
    def ext_get_phase_analysis(self) -> Dict[str, Any]: ...
    def ext_optimize_strategy(self) -> str: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...
    # Internal methods (private)
    def _linear_advance(self, phase: int, resonated: bool) -> int: ...
    def _accelerated_advance(self, phase: int, resonated: bool) -> int: ...
    def _decelerated_advance(self, phase: int, resonated: bool) -> int: ...
    def _harmonic_advance(self, phase: int, resonated: bool) -> int: ...
    def _quantum_advance(self, phase: int, resonated: bool) -> int: ...
    def _adaptive_advance(self, phase: int, resonated: bool) -> int: ...
    def _should_hold_phase(self, phase: int, resonated: bool) -> bool: ...
    def _should_skip_phase(self, phase: int, resonated: bool) -> bool: ...
    def _calculate_skip_amount(self, current_phase: int) -> int: ...
    def _calculate_resonance_correlation(self) -> float: ...
    def _calculate_phase_distribution(self) -> Dict[str, int]: ...

===
# ext_resonance_processor.py

from typing import Dict, Any, List, Optional, Tuple


class ext_ResonanceProcessor:
    def __init__(self) -> None: ...
    def ext_process_resonance(
        self, phase: int, resonated: bool, input_byte: int, ops: Optional[Tuple[int, int]] = None
    ) -> Dict[str, Any]: ...
    def ext_predict_resonance(self, phase: int, input_byte: int) -> float: ...
    def ext_modulate_resonance(self, factor: float) -> None: ...
    def ext_get_resonance_analysis(self) -> Dict[str, Any]: ...
    def ext_get_field_visualization(self) -> Dict[str, Any]: ...
    def ext_on_navigation_event(self, nav_event: int, input_byte: Optional[int] = None) -> None: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...
    # Internal methods
    def _calculate_resonance_strength(self, phase: int, input_byte: int, ops: Tuple[int, int]) -> float: ...
    def _update_resonance_field(self, phase: int, strength: float) -> None: ...
    def _detect_resonance_patterns(self) -> List[Dict[str, Any]]: ...
    def _analyze_harmonics(self) -> None: ...
    def _update_cycle_detection(self, phase: int, resonated: bool) -> None: ...
    def _check_period(self, buffer: List[Tuple[int, bool]], period: int) -> bool: ...
    def _get_harmonic_summary(self) -> Dict[str, float]: ...

===
# ext_spin_piv.py

from typing import Dict, Any, List, Optional


class ext_SpinPIV:
    def __init__(self, initial_piv: Optional[int] = None) -> None: ...
    def ext_on_navigation_event(self, nav_event: int, input_byte: Optional[int] = None) -> None: ...
    def ext_evolve_piv(self) -> None: ...
    def ext_encrypt(self, data: int) -> int: ...
    def ext_decrypt(self, data: int) -> int: ...
    def ext_encrypt_stream(self, data: bytes) -> bytes: ...
    def ext_get_piv_evolution_pattern(self) -> List[int]: ...
    def ext_get_crypto_analysis(self) -> Dict[str, Any]: ...
    def ext_reseed(self, seed: Optional[int] = None) -> None: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...
    # Internal methods
    def _update_entropy_quality(self) -> None: ...
    def _detect_piv_period(self) -> Optional[int]: ...
    def _calculate_bit_entropy(self) -> float: ...

===

# ext_state_helper.py

from typing import Dict, Any


class ext_StateHelper:
    def __init__(self, storage_manager) -> None: ...
    def _load_initial_state(self) -> None: ...
    def load_session_state(self) -> Dict[str, Any]: ...
    def persist_phase(self, phase: int) -> None: ...
    def persist_all_state(self, phase: int, knowledge_id: str) -> None: ...
    def update_knowledge_link(self, knowledge_id: str) -> None: ...
    def should_checkpoint(self, operation_count: int) -> bool: ...
    def create_snapshot(self) -> Dict[str, Any]: ...
    def restore_snapshot(self, snapshot: Dict[str, Any]) -> None: ...
    def _mark_dirty(self, component: str) -> None: ...
    def has_unsaved_changes(self) -> bool: ...
    # --- GyroExtension Interface Implementation ---
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...

===

# ext_storage_manager.py

from typing import Optional, Dict, Any


class ext_StorageManager:
    def __init__(self, session_id: Optional[str] = None, knowledge_id: Optional[str] = None) -> None: ...
    def set_manager(self, manager: "ExtensionManager") -> None: ...
    def load_phase(self) -> int: ...
    def save_phase(self, phase: int) -> None: ...
    def load_knowledge_link(self) -> Optional[str]: ...
    def save_knowledge_link(self, knowledge_id: str) -> None: ...
    def switch_knowledge_context(self, knowledge_id: str) -> None: ...
    def load_raw_navigation_log(self, knowledge_id: str) -> bytes: ...
    def save_raw_navigation_log(self, knowledge_id: str, raw_data: bytes) -> None: ...
    def load_metadata(self, knowledge_id: str) -> Dict[str, Any]: ...
    def save_metadata(self, knowledge_id: str, metadata: Dict[str, Any]) -> None: ...
    def load_extension_data(self, knowledge_id: str, filename: str) -> Optional[bytes]: ...
    def save_extension_data(self, knowledge_id: str, filename: str, data: bytes) -> None: ...
    def store_session_event(self, session_id: str, event_data: Any) -> None: ...
    def load_session_events(self, session_id: str) -> list: ...
    def store_learning_event(self, knowledge_id: str, event_data: Any) -> None: ...
    def save_ui_state(self, session_id: str, ui_state: dict) -> None: ...
    def load_ui_state(self, session_id: str) -> Dict[str, Any]: ...
    def save_gene(self, knowledge_id: str, gene: Dict[str, Any]) -> None: ...
    def load_gene(self, knowledge_id: str) -> Optional[Dict[str, Any]]: ...
    def append_output(self, session_id: str, text: str) -> None: ...
    def fork_knowledge_directory(self, source_id: str) -> str: ...
    def build_export_bundle(self, knowledge_id: str, output_path: str, extension_states: Optional[Dict[str, Any]] = None) -> None: ...
    def unpack_import_bundle(self, bundle_path: str) -> str: ...
    def validate_gene_checksum(self, gene: Dict[str, Any]) -> bool: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...
    def process_navigation_event(self, event, input_byte=None): ...
    def get_pattern_filename(self) -> str: ...
    def export_session(self, session_id: str, output_path: str) -> None: ...
    def import_session(self, bundle_path: str) -> str: ...

===

# ext_system_monitor.py

from typing import Dict, Any, List, Tuple


class ext_SystemMonitor:
    def __init__(self) -> None: ...
    def get_health_report(self, phase: int, nav_log_size: int, knowledge_id: str, session_id: str) -> Dict[str, Any]: ...
    def _collect_system_metrics(self) -> Dict[str, Any]: ...
    def _check_anomalies(self, metrics: Dict[str, Any]) -> List[Dict[str, Any]]: ...
    def _get_performance_summary(self) -> Dict[str, Any]: ...
    def ext_record_operation_latency(self, latency_ms: float) -> None: ...
    def ext_validate_system_integrity(self) -> Tuple[bool, Dict[str, bool]]: ...
    def _validate_memory_bounds(self) -> bool: ...
    def _validate_performance_bounds(self) -> bool: ...
    def _validate_anomaly_rate(self) -> bool: ...
    def _validate_system_resources(self) -> bool: ...
    def get_extension_name(self) -> str: ...
    def get_extension_version(self) -> str: ...
    def get_footprint_bytes(self) -> int: ...
    def get_learning_state(self) -> Dict[str, Any]: ...
    def get_session_state(self) -> Dict[str, Any]: ...
    def set_learning_state(self, state: Dict[str, Any]) -> None: ...
    def set_session_state(self, state: Dict[str, Any]) -> None: ...

===

# src/gyro_api.py GyroSI Baby ML API Interface Definitions

from typing import Dict, List, Optional, Tuple, Union, Any, Iterable


def initialize_session(session_id: Optional[str] = None, knowledge_id: Optional[str] = None) -> str: ...
def shutdown_session(session_id: str) -> None: ...
def list_active_sessions() -> List[str]: ...
def get_session_info(session_id: str) -> Dict[str, Any]: ...

def process_byte(session_id: str, input_byte: int) -> Tuple[int, int]: ...
def process_byte_stream(session_id: str, byte_stream: Iterable[int]) -> int: ...
def process_text(session_id: str, text: str) -> int: ...
def process_file(session_id: str, file_path: Union[str, "Path"], chunk_size: int = 8192) -> int: ...

def export_knowledge(session_id: str, output_path: Union[str, "Path"]) -> None: ...
def import_knowledge(bundle_path: Union[str, "Path"], new_session: bool = True) -> Union[str, None]: ...
def fork_knowledge(session_id: str, new_session: bool = False) -> str: ...
def link_session_to_knowledge(session_id: str, knowledge_id: str) -> None: ...

def query_memory(session_id: str, query: str, max_results: int = 10) -> List[Dict[str, Any]]: ...
def get_navigation_history(session_id: str, limit: int = 100) -> List[Dict[str, Any]]: ...
def get_language_output(session_id: str, last_n: int = 10) -> List[str]: ...

def validate_system_integrity() -> Tuple[bool, Dict[str, Any]]: ...
def cleanup_inactive_sessions() -> int: ...

# Internal utility
def _get_manager(session_id: str) -> "ExtensionManager": ...

===

# gyro_tools/build_operator_matrix.py Interface Definition

from typing import Tuple
import numpy as np

def gene_const() -> dict:
    """
    Returns immutable Gene constant with id_0 and id_1 tensors (torch.int8).
    """

def slice_at_phase(phase: int) -> Tuple[int, int]:
    """
    Given a phase (0-47), returns a tuple of ±1 pair from the immutable Gene.

    Args:
        phase: phase index (0-47)

    Returns:
        Tuple of two ints, each ±1.
    """

def build_mask() -> np.ndarray:
    """
    Builds the resonance mask matrix M with shape (48, 256).
    Each entry is 0 or 1, representing resonance bits per phase and byte.

    Returns:
        Numpy array of uint8 with shape (48, 256).
    """

def build_operator_vector() -> np.ndarray:
    """
    Builds the operator vector O of length 48 (one byte per phase).
    Each byte encodes two operator codes packed as (id₁ << 4) | id₀.

    Returns:
        Numpy array of uint8 with length 48.
    """

def main(out_path: str) -> None:
    """
    Builds the universal GyroSI harmonics matrix and writes the binary payload to out_path.

    Args:
        out_path: File path to write the 1616-byte payload.

    Outputs:
        Writes a binary file containing:
            - 32 bytes SHA-256 digest of the Gene constant,
            - 48x256 bits resonance mask (1536 bytes),
            - 48 bytes operator vector.
    """

===

# gyro_tools/gyro_curriculum_manager.py Interface Definitions

from pathlib import Path
from typing import Optional, Callable, Union

def download_resource(
    resource_key: str,
    dest_dir: Union[str, Path],
    progress_cb: Optional[Callable[[int, int], None]] = None,
) -> Path:
    """
    Downloads a curriculum resource archive to the destination directory.

    Args:
        resource_key: Key identifying the resource to download (must be in CURRICULUM_RESOURCES).
        dest_dir: Directory path where the archive will be saved.
        progress_cb: Optional callback receiving (downloaded_bytes, total_bytes).

    Returns:
        Path object pointing to the downloaded archive.
    """

def extract_resource(
    archive_path: Union[str, Path],
    extract_dir: Union[str, Path],
) -> Union[Path, None]:
    """
    Extracts the given archive into the specified directory.

    Supports .tar.gz, .tgz, .tar.bz2, .zip, .bz2, and .gz archive formats.

    Args:
        archive_path: Path to the archive file.
        extract_dir: Directory path to extract contents into.

    Returns:
        Path to extracted content directory or file (for single-file archives like .bz2/.gz).
    """

def ingest_wordnet(path: Union[str, Path]) -> bool:
    """
    Stub handler for ingesting WordNet data from given path.

    Args:
        path: Path to extracted WordNet data.

    Returns:
        True if ingestion succeeded.
    """

def ingest_wiktionary(path: Union[str, Path]) -> bool:
    """
    Stub handler for ingesting Wiktionary data from given path.

    Args:
        path: Path to extracted Wiktionary data.

    Returns:
        True if ingestion succeeded.
    """

def ingest_simplewiki(path: Union[str, Path]) -> bool:
    """
    Stub handler for ingesting Simple English Wikipedia data.

    Args:
        path: Path to extracted SimpleWiki data.

    Returns:
        True if ingestion succeeded.
    """

def ingest_udhr(path: Union[str, Path]) -> bool:
    """
    Stub handler for ingesting UDHR Multilingual data.

    Args:
        path: Path to extracted UDHR data.

    Returns:
        True if ingestion succeeded.
    """

def ingest_tatoeba(path: Union[str, Path]) -> bool:
    """
    Stub handler for ingesting Tatoeba English sentences data.

    Args:
        path: Path to extracted Tatoeba data.

    Returns:
        True if ingestion succeeded.
    """

def ingest_opensubtitles(path: Union[str, Path]) -> bool:
    """
    Stub handler for ingesting OpenSubtitles data.

    Args:
        path: Path to extracted OpenSubtitles data.

    Returns:
        True if ingestion succeeded.
    """

def ingest_wikibooks(path: Union[str, Path]) -> bool:
    """
    Stub handler for ingesting Wikibooks data.

    Args:
        path: Path to extracted Wikibooks data.

    Returns:
        True if ingestion succeeded.
    """

def ingest_wikisource(path: Union[str, Path]) -> bool:
    """
    Stub handler for ingesting Wikisource data.

    Args:
        path: Path to extracted Wikisource data.

    Returns:
        True if ingestion succeeded.
    """

def ingest_resource(
    resource_key: str,
    dest_dir: Union[str, Path],
    progress_cb: Optional[Callable[[int, int], None]] = None,
) -> bool:
    """
    Convenience function to download, extract, and ingest a curriculum resource.

    Args:
        resource_key: Key identifying the resource (must be in CURRICULUM_RESOURCES).
        dest_dir: Directory path to store downloaded and extracted data.
        progress_cb: Optional callback receiving (downloaded_bytes, total_bytes).

    Returns:
        True if ingestion succeeded, False or raises otherwise.
    """

===

# gyro_tools/gyro_integrity_check.py Interface Definitions

import argparse
from typing import Any


def check_knowledge(args: Any) -> None:
    """
    Performs integrity checks on a given knowledge package directory.

    Args:
        args: Parsed command-line arguments containing 'knowledge_id'.

    Behavior:
        - Validates existence of knowledge directory and key files.
        - Loads and reports metadata.
        - Checks for navigation logs, manifest, extension files, and integrity file presence.
        - Prints results to stdout and errors to stderr.
        - Exits with error code on failure.
    """


def check_session(args: Any) -> None:
    """
    Performs integrity checks on a given session directory.

    Args:
        args: Parsed command-line arguments containing 'session_id'.

    Behavior:
        - Validates existence of session directory and key files.
        - Loads and reports session metadata.
        - Checks for presence of phase file, events log, and knowledge link.
        - Prints results to stdout and errors to stderr.
        - Exits with error code on failure.
    """


def main() -> None:
    """
    Command-line interface entry point.

    Behavior:
        - Parses command-line arguments for subcommands:
          * check-knowledge --knowledge-id <UUID>
          * check-session --session-id <UUID>
        - Dispatches to appropriate check function.
        - Exits with status code reflecting success or failure.
    """

===

# gyro_tools/gyro_knowledge_manager.py Interface Definitions

import argparse
from typing import Any


def export_knowledge(args: Any) -> None:
    """
    Export a knowledge package to a .gyro bundle file.

    Args:
        args: Parsed command-line arguments containing:
            - knowledge_id: UUID of knowledge package to export
            - output: File path to write the .gyro bundle

    Behavior:
        - Initializes an ExtensionManager linked to the knowledge package.
        - Calls export function to write the bundle.
        - Prints confirmation or error to stdout/stderr.
        - Exits with error on failure.
    """


def import_knowledge(args: Any) -> None:
    """
    Import a knowledge package from a .gyro bundle.

    Args:
        args: Parsed command-line arguments containing:
            - input: Path to the .gyro bundle file
            - new_session: Boolean flag to create and link a new session

    Behavior:
        - Initializes a temporary ExtensionManager.
        - Imports knowledge package from the bundle.
        - Prints the new knowledge UUID.
        - Prints message if a new session is created.
        - Exits with error on failure.
    """


def fork_knowledge(args: Any) -> None:
    """
    Fork an existing knowledge package to create a new knowledge UUID.

    Args:
        args: Parsed command-line arguments containing:
            - source: Source knowledge UUID to fork from
            - session: Optional session UUID to link to forked knowledge

    Behavior:
        - Initializes ExtensionManager for the source knowledge.
        - Creates a forked knowledge package.
        - Prints new knowledge UUID.
        - Prints session linking info if applicable.
        - Exits with error on failure.
    """


def link_session(args: Any) -> None:
    """
    Link an existing session to a different knowledge package.

    Args:
        args: Parsed command-line arguments containing:
            - session: Session UUID to link
            - knowledge: Knowledge UUID to link to

    Behavior:
        - Initializes ExtensionManager for the session.
        - Performs linking operation.
        - Prints confirmation or error.
        - Exits with error on failure.
    """


def main() -> None:
    """
    Command-line interface entry point for knowledge management.

    Behavior:
        - Parses subcommands: export-knowledge, import-knowledge, fork-knowledge, link-session.
        - Dispatches to respective handlers.
        - Handles argument parsing and error reporting.
    """

===

# gyro_tools/gyro_session_manager.py Interface Definitions

import argparse
from typing import Any


def export_session(args: Any) -> None:
    """
    Export an active session to a .session.gyro bundle.

    Args:
        args: Parsed command-line arguments containing:
            - session_id: UUID of the session to export
            - output: Path to save the exported bundle file

    Behavior:
        - Initializes an ExtensionManager for the specified session.
        - Calls export method to write the session bundle.
        - Prints success confirmation or error message.
        - Exits with non-zero status on failure.
    """


def import_session(args: Any) -> None:
    """
    Import a session from a .session.gyro bundle file.

    Args:
        args: Parsed command-line arguments containing:
            - input: Path to the .session.gyro bundle file

    Behavior:
        - Initializes a temporary ExtensionManager.
        - Imports the session bundle.
        - Prints the new session UUID assigned.
        - Exits with error on failure.
    """


def main() -> None:
    """
    Command-line interface entry point for session management.

    Behavior:
        - Parses subcommands: export-session, import-session.
        - Dispatches to the respective handler functions.
        - Handles argument parsing, validation, and error reporting.
    """
