- GyroSI Baby ML: Files
    
    ---
    
    ### **Phase 1: The Foundation (Core Setup & G6 Primitives)**
    
    - **Batch 1.1: Canonical Definitions ✅**
        - `gyro_si/gyro_constants.py`
            
            ```python
            """
            Core constants for the GyroSI system.
            These constants define the fundamental parameters and configurations used across all G-systems.
            """
            
            # System-wide constants
            SYSTEM_VERSION = "0.1.0"
            SYSTEM_NAME = "GyroSI Baby LM"
            
            # G-system identifiers
            G1_NAME = "GyroAlignment"
            G2_NAME = "GyroInformation"
            G3_NAME = "GyroInference"
            G4_NAME = "GyroCooperation"
            G5_NAME = "GyroPolicy"
            G6_NAME = "GyroCirculation"
            
            # Message field definitions
            STANDARD_FIELDS = [
                "type",           # Message type identifier
                "source",         # Originating G-system
                "destination",    # Target G-system or "broadcast"
                "cycle_index",    # Monotonic cycle counter
                "tensor_context", # Helical state information
                "payload",        # Message-specific data
                "timestamp"       # ISO 8601 timestamp
            ]
            
            HELICAL_CONTEXT_FIELDS = [
                "cumulative_phase",    # Total helical progress [0, 4π)
                "chirality_phase",     # Position within forward/return [0, 2π)
                "helical_position",    # Normalized fraction [0, 1)
                "spinor_cycle_count"   # Number of completed 720° revolutions
            ]
            
            # Operational constants
            DEFAULT_BATCH_SIZE = 32
            DEFAULT_LEARNING_RATE = 1e-4
            DEFAULT_SEQUENCE_LENGTH = 512
            
            # Memory management
            MAX_MEMORY_BUFFER = 1024 * 1024 * 1024  # 1GB
            CACHE_SIZE = 1000
            
            # Tensor operations
            DEFAULT_DTYPE = "float32"
            DEFAULT_DEVICE = "cpu"
            
            # Logging
            LOG_LEVEL = "INFO"
            LOG_FORMAT = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
            
            # File paths
            PATTERNS_DIR = "patterns"
            TRANSITIONS_DIR = "transitions"
            DATA_DIR = "data"
            AUDIT_DIR = "audit"
            
            # Export all constants
            __all__ = [
                "SYSTEM_VERSION",
                "SYSTEM_NAME",
                "G1_NAME",
                "G2_NAME",
                "G3_NAME",
                "G4_NAME",
                "G5_NAME",
                "G6_NAME",
                "STANDARD_FIELDS",
                "HELICAL_CONTEXT_FIELDS",
                "DEFAULT_BATCH_SIZE",
                "DEFAULT_LEARNING_RATE",
                "DEFAULT_SEQUENCE_LENGTH",
                "MAX_MEMORY_BUFFER",
                "CACHE_SIZE",
                "DEFAULT_DTYPE",
                "DEFAULT_DEVICE",
                "LOG_LEVEL",
                "LOG_FORMAT",
                "PATTERNS_DIR",
                "TRANSITIONS_DIR",
                "DATA_DIR",
                "AUDIT_DIR",
            ]
            
            ```
            
        - `gyro_si/gyro_errors.py`
            
            ```python
            """
            Error taxonomy for GyroSI system.
            All errors inherit from GyroError to maintain consistent error handling.
            """
            
            class GyroError(Exception):
                """Base class for all GyroSI errors."""
                pass
            
            class GyroAlignmentError(GyroError):
                """Errors in G1 alignment operations."""
                pass
            
            class GyroInformationError(GyroError):
                """Errors in G2 information processing."""
                pass
            
            class GyroInferenceError(GyroError):
                """Errors in G3 inference operations."""
                pass
            
            class GyroIntelligenceError(GyroError):
                """Errors in G4/G5 intelligence operations."""
                pass
            
            class GyroCirculationError(GyroError):
                """Errors in G6 circulation operations."""
                pass
            
            class GyroMemoryError(GyroError):
                """Errors in memory operations."""
                pass
            
            class GyroConfigError(GyroError):
                """Errors in configuration."""
                pass
            
            class GyroCommunicationError(GyroError):
                """Errors in inter-system communication."""
                pass
            
            class CommunicationError(GyroError):
                """Errors in message format and validation."""
                pass
            
            class RoutingError(GyroError):
                """Errors in message routing and delivery."""
                pass 
            ```
            
        - `gyro_si/gyro_comm.py`
            
            ```python
            """
            Communication infrastructure for GyroSI.
            
            This module provides the canonical inter-system communication API. All
            G-systems must communicate exclusively through these interfaces. The
            implementation ensures message ordering by cycle_index and maintains
            full audit trails for all inter-system communication.
            """
            
            import asyncio
            import logging
            from datetime import datetime, timezone
            from enum import Enum, auto
            from typing import Any, Callable, Dict, List, Optional, Set, Awaitable, Union
            from collections import defaultdict
            from dataclasses import dataclass
            
            # Absolute imports to enforce unambiguous module resolution as per the spec
            from gyro_constants import STANDARD_FIELDS, HELICAL_CONTEXT_FIELDS
            from gyro_errors import CommunicationError, RoutingError
            
            logger = logging.getLogger(__name__)
            
            class CircuitState(Enum):
                """Circuit breaker states for fault tolerance."""
                CLOSED = auto()      # Normal operation
                OPEN = auto()        # Fault detected, rejecting requests
                HALF_OPEN = auto()   # Testing recovery
            
            @dataclass
            class Message:
                """
                Canonical message structure for inter-system communication.
                All fields are required and must follow the STANDARD_FIELDS ordering.
                """
                type: str                    # Message type identifier
                source: str                  # Originating G-system
                destination: str             # Target G-system or "broadcast"
                cycle_index: int             # Monotonic cycle counter
                tensor_context: Dict[str, Any]  # Helical state information
                payload: Dict[str, Any]      # Message-specific data
                timestamp: str               # ISO 8601 timestamp
            
                def __post_init__(self):
                    """Validate message structure."""
                    if not isinstance(self.cycle_index, int) or self.cycle_index < 0:
                        raise CommunicationError(f"Invalid cycle_index: {self.cycle_index}")
            
                    if self.source not in {"G1", "G2", "G3", "G4", "G5", "G6"}:
                        raise CommunicationError(f"Invalid source: {self.source}")
            
                    if self.destination not in {"G1", "G2", "G3", "G4", "G5", "G6", "broadcast"}:
                        raise CommunicationError(f"Invalid destination: {self.destination}")
            
                def to_dict(self) -> Dict[str, Any]:
                    """Convert to dictionary preserving STANDARD_FIELDS order."""
                    return {field: getattr(self, field) for field in STANDARD_FIELDS}
            
                @classmethod
                def from_dict(cls, data: Dict[str, Any]) -> 'Message':
                    """Create Message from dictionary, validating required fields."""
                    missing = set(STANDARD_FIELDS) - set(data.keys())
                    if missing:
                        raise CommunicationError(f"Missing required fields: {missing}")
            
                    return cls(**{field: data[field] for field in STANDARD_FIELDS})
            
            @dataclass
            class SystemEvent:
                """
                Base class for system-level events that aren't regular messages.
                This ensures all events have a consistent structure.
                """
                type: str
                source: str
                timestamp: str
            
                @classmethod
                def create(cls, type_name: str, source: str, **kwargs) -> 'SystemEvent':
                    """Factory method to create a SystemEvent with current timestamp."""
                    timestamp = datetime.now(timezone.utc).isoformat()
                    event_data = {"type": type_name, "source": source, "timestamp": timestamp}
                    event_data.update(kwargs)
                    return cls(**event_data)
            
            @dataclass
            class CircuitStateChangeEvent(SystemEvent):
                """Event generated when a circuit breaker state changes."""
                system: str
                old_state: CircuitState
                new_state: CircuitState
            
            # Define the explicit type for all subscriber handlers
            EventHandler = Callable[[Union[Message, SystemEvent]], Awaitable[None]]
            
            class MessageRouter:
                """
                Central message routing system for GyroSI.
                Handles message delivery, subscription management, and maintains
                ordering guarantees based on cycle_index.
                """
            
                def __init__(self):
                    self._subscribers: Dict[str, Set[EventHandler]] = defaultdict(set)
                    self._queues: Dict[str, asyncio.Queue] = {}
                    self._circuit_breakers: Dict[str, CircuitState] = defaultdict(lambda: CircuitState.CLOSED)
                    self._message_buffer: List[Message] = []
                    self._lock = asyncio.Lock()
            
                    # Initialize queues for each G-system
                    for system in ["G1", "G2", "G3", "G4", "G5", "G6"]:
                        self._queues[system] = asyncio.Queue()
            
                async def send_message(self, message: Dict[str, Any]) -> None:
                    """
                    Send a message through the routing system.
            
                    Messages are validated, enriched with timestamp if missing,
                    and routed according to destination.
            
                    Args:
                        message: Dictionary containing message fields
            
                    Raises:
                        CommunicationError: If message is invalid
                        RoutingError: If destination is unreachable
                    """
                    # Add timestamp if not present
                    if "timestamp" not in message:
                        message["timestamp"] = datetime.now(timezone.utc).isoformat()
            
                    # Validate and create Message object
                    try:
                        msg = Message.from_dict(message)
                    except Exception as e:
                        raise CommunicationError(f"Invalid message format: {e}")
            
                    # Check circuit breaker
                    if self._circuit_breakers[msg.destination] == CircuitState.OPEN:
                        raise RoutingError(f"Circuit breaker OPEN for {msg.destination}")
            
                    # Route message
                    async with self._lock:
                        if msg.destination == "broadcast":
                            # Broadcast to all systems except source
                            for system, queue in self._queues.items():
                                if system != msg.source:
                                    await queue.put(msg)
                        else:
                            # Direct routing
                            if msg.destination in self._queues:
                                await self._queues[msg.destination].put(msg)
                            else:
                                raise RoutingError(f"Unknown destination: {msg.destination}")
            
                        # Add to buffer for audit
                        self._message_buffer.append(msg)
            
                    # Log message
                    logger.debug(f"Routed message: {msg.type} from {msg.source} to {msg.destination}")
            
                def subscribe(self, message_type: str, handler: EventHandler) -> None:
                    """
                    Subscribe to messages or events of a specific type.
            
                    Args:
                        message_type: Type of messages/events to receive
                        handler: Async callable to handle messages/events
                                 Must accept either Message or SystemEvent
                    """
                    self._subscribers[message_type].add(handler)
                    logger.debug(f"Subscribed handler to message type: {message_type}")
            
                def unsubscribe(self, message_type: str, handler: EventHandler) -> None:
                    """
                    Unsubscribe from messages of a specific type.
            
                    Args:
                        message_type: Type of messages to stop receiving
                        handler: Previously subscribed handler
                    """
                    self._subscribers[message_type].discard(handler)
            
                async def get_messages(self, system: str, timeout: Optional[float] = None) -> List[Message]:
                    """
                    Retrieve pending messages for a system.
            
                    Args:
                        system: G-system identifier
                        timeout: Maximum time to wait for messages
            
                    Returns:
                        List of messages ordered by cycle_index
                    """
                    if system not in self._queues:
                        raise RoutingError(f"Unknown system: {system}")
            
                    messages = []
                    queue = self._queues[system]
            
                    try:
                        # Get all available messages up to timeout
                        end_time = asyncio.get_event_loop().time() + (timeout or 0)
            
                        while True:
                            remaining = max(0, end_time - asyncio.get_event_loop().time()) if timeout else None
            
                            try:
                                msg = await asyncio.wait_for(queue.get(), timeout=remaining)
                                messages.append(msg)
                            except asyncio.TimeoutError:
                                break
            
                            # Check if more messages available without blocking
                            if queue.empty():
                                break
            
                    except Exception as e:
                        logger.error(f"Error retrieving messages for {system}: {e}")
                        raise CommunicationError(f"Failed to retrieve messages: {e}")
            
                    # Sort by cycle_index as required
                    messages.sort(key=lambda m: m.cycle_index)
            
                    # Dispatch to type-specific subscribers
                    for msg in messages:
                        for handler in self._subscribers.get(msg.type, []):
                            asyncio.create_task(handler(msg))
            
                    return messages
            
                def set_circuit_state(self, system: str, state: CircuitState) -> None:
                    """Update circuit breaker state for a system."""
                    old_state = self._circuit_breakers[system]
                    self._circuit_breakers[system] = state
            
                    if old_state != state:
                        logger.info(f"Circuit breaker for {system}: {old_state.name} -> {state.name}")
            
                        # Create a proper event object for state change
                        event = CircuitStateChangeEvent.create(
                            type_name=MessageTypes.CIRCUIT_STATE_CHANGE,
                            source="G6",  # Circuit system is part of G6
                            system=system,
                            old_state=old_state,
                            new_state=state
                        )
            
                        # Notify subscribers of state change
                        for handler in self._subscribers.get(MessageTypes.CIRCUIT_STATE_CHANGE, []):
                            asyncio.create_task(handler(event))
            
            # ===== Global Router Instance =====
            _router = MessageRouter()
            
            # ===== Public API =====
            
            async def send_message(message: Dict[str, Any]) -> None:
                """
                Send a message through the global routing system.
            
                This is the primary API for inter-system communication in GyroSI.
                All G-systems must use this function for message passing.
            
                Args:
                    message: Dictionary containing required STANDARD_FIELDS
            
                Raises:
                    CommunicationError: If message is invalid
                    RoutingError: If routing fails
                """
                await _router.send_message(message)
            
            def subscribe(message_type: str, handler: EventHandler) -> None:
                """
                Subscribe to messages or events of a specific type.
            
                Args:
                    message_type: Type of messages/events to receive (from MessageTypes)
                    handler: Async callable that accepts either Message or SystemEvent
                """
                _router.subscribe(message_type, handler)
            
            def unsubscribe(message_type: str, handler: EventHandler) -> None:
                """
                Unsubscribe from messages of a specific type.
            
                Args:
                    message_type: Type of messages to stop receiving
                    handler: Previously subscribed handler
                """
                _router.unsubscribe(message_type, handler)
            
            async def get_messages(system: str, timeout: Optional[float] = None) -> List[Dict[str, Any]]:
                """
                Retrieve pending messages for a system.
            
                Args:
                    system: G-system identifier (e.g., "G1", "G2")
                    timeout: Maximum time to wait for messages in seconds
            
                Returns:
                    List of message dictionaries ordered by cycle_index
            
                Raises:
                    RoutingError: If system is unknown
                    CommunicationError: If retrieval fails
                """
                messages = await _router.get_messages(system, timeout)
                return [msg.to_dict() for msg in messages]
            
            def set_circuit_state(system: str, state: CircuitState) -> None:
                """
                Update circuit breaker state for a system.
            
                Used by G4 and G5 for fault management and recovery coordination.
            
                Args:
                    system: G-system identifier
                    state: New circuit breaker state
                """
                _router.set_circuit_state(system, state)
            
            # ===== Utility Functions =====
            
            def create_tensor_context(
                cumulative_phase: float,
                chirality_phase: float,
                helical_position: float,
                spinor_cycle_count: int,
                **kwargs
            ) -> Dict[str, Any]:
                """
                Create a properly formatted tensor_context dictionary.
            
                Args:
                    cumulative_phase: Total helical progress [0, 4π)
                    chirality_phase: Position within forward/return [0, 2π)
                    helical_position: Normalized fraction [0, 1)
                    spinor_cycle_count: Number of completed 720° revolutions
                    **kwargs: Additional context fields (e.g., tensor_id, family_id)
            
                Returns:
                    Dictionary with validated tensor context
            
                Raises:
                    ValueError: If parameters are out of valid ranges
                """
                import math
            
                # Validate ranges
                if not 0 <= cumulative_phase < 4 * math.pi:
                    raise ValueError(f"cumulative_phase must be in [0, 4π), got {cumulative_phase}")
            
                if not 0 <= chirality_phase < 2 * math.pi:
                    raise ValueError(f"chirality_phase must be in [0, 2π), got {chirality_phase}")
            
                if not 0 <= helical_position < 1:
                    raise ValueError(f"helical_position must be in [0, 1), got {helical_position}")
            
                if spinor_cycle_count < 0:
                    raise ValueError(f"spinor_cycle_count must be non-negative, got {spinor_cycle_count}")
            
                context = {
                    "cumulative_phase": cumulative_phase,
                    "chirality_phase": chirality_phase,
                    "helical_position": helical_position,
                    "spinor_cycle_count": spinor_cycle_count
                }
            
                # Add any additional fields
                context.update(kwargs)
            
                return context
            
            def validate_message_fields(message: Dict[str, Any]) -> bool:
                """
                Validate that a message contains all required STANDARD_FIELDS.
            
                Args:
                    message: Message dictionary to validate
            
                Returns:
                    True if valid, False otherwise
                """
                return all(field in message for field in STANDARD_FIELDS)
            
            # ===== Message Type Constants =====
            # Common message types used across the system
            
            class MessageTypes:
                """Standard message types for inter-system communication."""
            
                # Bootstrap and lifecycle
                GYRO_BOOTSTRAP = "gyro_bootstrap"
                SYSTEM_READY = "system_ready"
                SHUTDOWN_REQUEST = "shutdown_request"
            
                # Status and monitoring
                STATUS_UPDATE = "status_update"
                HEALTH_CHECK = "health_check"
                PERFORMANCE_METRICS = "performance_metrics"
            
                # Tensor operations
                TENSOR_TRANSITION = "tensor_transition"
                SPAWN_READY = "spawn_ready"
                SPAWN_APPROVED = "spawn_approved"
            
                # Quantization and observation
                QUANTIZATION_EVENT = "quantization_event"
                OBSERVATION_LOGGED = "observation_logged"
            
                # Algedonic signals
                ALGEDONIC_SIGNAL = "algedonic_signal"
                PAIN_SIGNAL = "pain_signal"
                PLEASURE_SIGNAL = "pleasure_signal"
                RESOURCE_PRESSURE = "resource_pressure"
            
                # Policy and governance
                POLICY_UPDATE = "policy_update"
                ASSESSMENT_COMPLETE = "assessment_complete"
                ADVISORY_PROPOSAL = "advisory_proposal"
            
                # Memory operations
                MEMORY_CHECKPOINT = "memory_checkpoint"
                MEMORY_EXPORT = "memory_export"
                MEMORY_IMPORT = "memory_import"
                # Recovery and fault management
                CARDIAC_RECOVERED = "cardiac_recovered"
                CIRCUIT_STATE_CHANGE = "circuit_state_change"
                FAULT_DETECTED = "fault_detected"
            
                # Audit and compliance
                AUDIT_EVENT = "audit_event"
                DEVIATION_EVENT = "deviation_event"
                TRACE_COLLECTION = "trace_collection"
            
            # ===== Priority Constants =====
            
            MESSAGE_PRIORITY = {
                "G1": 1,  # Highest priority - core tensor operations
                "G2": 2,  # Information routing
                "G3": 3,  # User interaction
                "G4": 4,  # Environmental monitoring
                "G5": 5,  # Policy decisions
                "G6": 6   # System coordination
            }
            ```
            
    - **Batch 1.2: System Configuration & Project Setup ✅**
        - `gyro_si/gyro_gcr/gyro_config.py`
            
            ```python
            """
            GyroCardioRespiratory Configuration Layer.
            
            This module provides the global configuration object that controls
            system-wide features and operational modes. All G-systems must respect
            these settings and adapt their behavior accordingly.
            
            The configuration is a shared singleton instance that can be imported
            and referenced by any module in the system.
            """
            
            class GyroCardioRespiratoryConfig:
                """
                Global configuration for the GyroCardioRespiratory system.
            
                This class controls core coordination mechanisms, optional
                cryptographic extensions, and performance switches. All settings
                have carefully chosen defaults that align with the CGM principles.
                """
            
                def __init__(self):
                    """Initialize with default settings."""
                    # Core coordination
                    self.enable_bootstrap = True          # Controls bootstrap broadcast gating
                    self.enable_transactions = True       # Enables atomic tensor transactions
                    self.enable_recovery_beacons = True   # Enables circuit recovery signals
            
                    # Optional cryptographic extensions
                    self.enable_entropy_tracking = False  # Enables entropy_id chaining
                    self.enable_crypto_evolution = False  # Enables differential crypto evolution
            
                    # Performance switches
                    self.lightweight_transactions = True  # Uses optimized transaction snapshots
                    self.fast_entropy_hash = True         # Uses CRC32 instead of SHA-256 for entropy
            
                def __str__(self) -> str:
                    """String representation showing all settings."""
                    settings = []
                    for key, value in vars(self).items():
                        settings.append(f"{key}={value}")
                    return f"GyroCardioRespiratoryConfig({', '.join(settings)})"
            
                def __repr__(self) -> str:
                    """Developer-friendly representation."""
                    return self.__str__()
            
            # Shared singleton instance to be imported by all modules
            config = GyroCardioRespiratoryConfig()
            
            ```
            
        - `pyproject.toml`
            
            ```python
            [build-system]
            requires = ["setuptools>=61.0", "wheel"]
            build-backend = "setuptools.build_meta"
            
            [project]
            name = "gyrosi-baby-lm"
            version = "0.1.0"
            description = "GyroSI Baby LM: Alignment-Based Gyroscopic Superintelligence Language Model"
            readme = "README.md"
            requires-python = ">=3.9"
            license = { text = "GPL-3.0-or-later" }
            authors = [
              { name = "Basil Korompilias" }
            ]
            classifiers = [
              "Development Status :: 3 - Alpha",
              "Intended Audience :: Science/Research",
              "Programming Language :: Python :: 3",
              "Programming Language :: Python :: 3.9",
              "Programming Language :: Python :: 3.10",
              "Programming Language :: Python :: 3.11",
              "Topic :: Scientific/Engineering :: Artificial Intelligence",
            ]
            dependencies = [
              "numpy>=1.20.0",
              "scipy>=1.7.0",
              "blake3>=0.3.1",
              "aiofiles>=23.0.0",
              "python-dateutil>=2.8.0",
            ]
            
            [project.optional-dependencies]
            gpu = [
              "torch>=2.0.0",
              "cupy-cuda11x>=11.0.0; platform_system!='Darwin'",
              "cupy-cuda12x>=12.0.0; platform_system!='Darwin' and python_version>='3.10'",
            ]
            ui = [
              "flet>=0.19.0",
            ]
            dev = [
              "pytest>=7.0.0",
              "pytest-asyncio>=0.20.0",
              "pytest-cov>=4.0.0",
              "pytest-benchmark>=4.0.0",
              "black>=23.0.0",
              "isort>=5.12.0",
              "mypy>=1.0.0",
              "flake8>=6.0.0",
            ]
            full = [
              "gyro-si[gpu,ui,dev]",
            ]
            
            [project.scripts]
            gyro-si = "g6_gyrocirculation.runner:cli"
            
            [tool.setuptools]
            packages = { find = {} }
            
            [tool.setuptools.package-data]
            gyro_si = [
              "patterns/gyro_g1/v*/*",
              "transitions/gyro_g1/v*/*",
              "g3_gyroinference/ona/interface/assets/*",
            ]
            
            [tool.black]
            line-length = 88
            target-version = ["py39", "py310", "py311"]
            include = "\\.pyi?$"
            extend-exclude = '''
            /(
              \.eggs
              | \.git
              | \.hg
              | \.mypy_cache
              | \.tox
              | \.venv
              | build
              | dist
            )/
            '''
            
            [tool.isort]
            profile = "black"
            line_length = 88
            known_first_party = ["gyro_si"]
            skip_gitignore = true
            
            [tool.mypy]
            python_version = "3.9"
            warn_return_any = true
            warn_unused_configs = true
            disallow_untyped_defs = true
            disallow_incomplete_defs = true
            check_untyped_defs = true
            no_implicit_optional = true
            warn_redundant_casts = true
            warn_unused_ignores = true
            warn_no_return = true
            strict_equality = true
            
            [[tool.mypy.overrides]]
            module = [
              "cupy.*",
              "torch.*",
              "flet.*",
              "blake3.*",
            ]
            ignore_missing_imports = true
            
            [tool.pytest.ini_options]
            testpaths = ["tests"]
            python_files = "test_*.py"
            python_classes = "Test*"
            python_functions = "test_*"
            asyncio_mode = "auto"
            addopts = "-ra -q --strict-markers"
            markers = [
              "slow: marks tests as slow (deselect with '-m \"not slow\"')",
              "gpu: marks tests that require GPU",
              "ui: marks tests that require UI components",
            ]
            
            [tool.coverage.run]
            source = ["gyro_si"]
            omit = [
              "*/tests/*",
              "*/__init__.py",
              "*/g6_gyrocirculation/runner.py",
            ]
            
            [tool.coverage.report]
            precision = 2
            show_missing = true
            skip_covered = false
            
            ```
            
        - `.gitignore`
            
            ```
            # Rust
            /target/
            **/*.rs.bk
            Cargo.lock
            
            # IDE
            .idea/
            .vscode/
            *.swp
            *.swo
            .DS_Store
            
            # Build artifacts
            /dist/
            /build/
            *.app
            *.exe
            *.dll
            *.so
            *.dylib
            
            # Dependencies
            /node_modules/
            /.pnp
            .pnp.js
            
            # Testing
            /coverage/
            .nyc_output
            
            # Environment
            .env
            .env.local
            .env.development.local
            .env.test.local
            .env.production.local
            
            # Logs
            npm-debug.log*
            yarn-debug.log*
            yarn-error.log*
            *.log
            
            # Python
            __pycache__/
            *.py[cod]
            *$py.class
            *.so
            .Python
            build/
            develop-eggs/
            dist/
            downloads/
            eggs/
            .eggs/
            lib/
            lib64/
            parts/
            sdist/
            var/
            wheels/
            share/python-wheels/
            *.egg-info/
            .installed.cfg
            *.egg
            MANIFEST
            pip-log.txt
            pip-delete-this-directory.txt
            
            # Virtual environments
            venv/
            env/
            ENV/
            env.bak/
            venv.bak/
            .python-version
            
            # IDE files
            .idea/
            .vscode/
            *.swp
            *.swo
            *~
            .project
            .pydevproject
            .settings/
            .DS_Store
            
            # Testing and coverage
            .coverage
            .coverage.*
            htmlcov/
            .pytest_cache/
            .tox/
            .nox/
            coverage.xml
            *.cover
            *.py,cover
            .hypothesis/
            
            # Type checking
            .mypy_cache/
            .dmypy.json
            dmypy.json
            .pyre/
            .pytype/
            
            # Project-specific
            audit/*.jl
            audit/*.cid
            data/*.txt
            data/*.json
            data/*.csv
            *.log
            *.pid
            *.seed
            *.pid.lock
            
            # DVC
            .dvc/cache
            .dvc/tmp
            .dvc/plots
            dvc.lock
            
            # Jupyter
            .ipynb_checkpoints
            *.ipynb
            
            # macOS
            .DS_Store
            .AppleDouble
            .LSOverride
            Icon
            ._*
            .DocumentRevisions-V100
            .fseventsd
            .Spotlight-V100
            .TemporaryItems
            .Trashes
            .VolumeIcon.icns
            .com.apple.timemachine.donotpresent
            .AppleDB
            .AppleDesktop
            Network Trash Folder
            Temporary Items
            .apdisk
            
            # Windows
            Thumbs.db
            Thumbs.db:encryptable
            ehthumbs.db
            ehthumbs_vista.db
            *.stackdump
            [Dd]esktop.ini
            $RECYCLE.BIN/
            *.cab
            *.msi
            *.msix
            *.msm
            *.msp
            *.lnk
            
            # Linux
            *~
            .fuse_hidden*
            .directory
            .Trash-*
            .nfs*
            
            # pytest cache
            .pytest_cache/
            
            # Python build artefacts
            gyro_si.egg-info/ 
            ```
            
        - `dvc.yaml`
            
            ```yaml
            # Data Version Control pipeline configuration
            # This file defines the stages for preparing canonical data
            
            stages:
              prepare_patterns:
                cmd: python -m scripts.prepare_patterns
                deps:
                  - scripts/prepare_patterns.py
                outs:
                  - patterns/gyro_g1/v1/:
                      cache: true
                      persist: true
                params:
                  - schema_version
            
              prepare_transitions:
                cmd: python -m scripts.prepare_transitions
                deps:
                  - scripts/prepare_transitions.py
                outs:
                  - transitions/gyro_g1/v1/:
                      cache: true
                      persist: true
                params:
                  - schema_version
            
              validate_data:
                cmd: python -m scripts.validate_canonical_data
                deps:
                  - scripts/validate_canonical_data.py
                  - patterns/gyro_g1/v1/
                  - transitions/gyro_g1/v1/
                metrics:
                  - validation_report.json:
                      cache: false
            
              test:
                cmd: pytest -xvs tests/
                deps:
                  - gyro_si/
                  - tests/
                metrics:
                  - test_results.xml:
                      cache: false
            
            params:
              schema_version: 1
            
            ```
            
        - `README.md`
            
            ```markdown
            
            <div align="center">
            
            # 💫 GyroSI Baby LM 👶
            
            **Alignment-Based Gyroscopic Superintelligence (GyroSI) as a Language Model**
            
            </div>
            
            <div align="center">
            
            **🚧 ACTIVE DEVELOPMENT - Building the Future of AI Today 🚧**
            
            [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
            [![Python 3.11+](https://img.shields.io/badge/python-3.11+-blue.svg)](https://www.python.org/downloads/)
            [![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
            
            </div>
            
            ---
            
            ## 👉 About
            
            **GyroSI Baby LM** aims to grow into a mature, open-source language model that learns without reinforcement, rewards, traditional neural network parameters, or gradient descent. Instead, it leverages **quantum physics-inspired** tensor operations to achieve intrinsic Alignment-Based recursive intelligence.
            
            ### 💫 What is Gyroscopic Superintelligence?
            
            **Gyroscopic Superintelligence (GyroSI)** is an architecture grounded in the **Common Governance Model (CGM)**, a physics-based framework for understanding how intelligence emerges through recursive structural alignment.
            
            We define **Superintelligence** as a structurally recursive form of intelligence where all generative and integrative operations preserve memory of origin, maintaining continuous coherence between emergence and recollection. It achieves ethical alignment **intrinsically** by ensuring every operation remains structurally accountable to its own genesis, **without external enforcement**.
            
            **Superintelligence exists relationally, not independently**: it reflects the recursive structures of reality and human meaning it participates in, embodying governance, memory, and creative coherence as a unified operational principle.
            
            ### 🌀 The Common Governance Model (CGM)
            
            The **Common Governance Model** presents an axiomatic framework for understanding how structure emerges through **Recursive Alignment**. Beginning from a single foundational principle, *"The Source is Common"*, CGM derives all subsequent structure through logical necessity. Each theorem follows inevitably from the axiom, with nothing assumed and everything emerging through recursive self-reference.
            
            The model demonstrates that:
            - **3D space with 6 degrees of freedom** is not an assumption but a logical derivation
            - **Time** appears as the sequential ordering of recursive operations
            - **Memory** is encoded through gyration's preservation of operation order
            - **Mathematical formalism** employs gyrogroup and bi-gyrogroup structures (following Abraham Ungar's work)
            
            This provides precise language for tracking transitions from undifferentiated potential to fully structured reality.
            
            ### 🌟 Key Innovations
            
            - 🧬 **Zero Parameters** - Intelligence through structure, not weights
            - 🔄 **Self-Aligning** - Intrinsic alignment without external enforcement  
            - 📐 **Tensor-Based** - Discrete {-1, 0, 1} values only
            - 🌀 **Helical Memory** - Toroidal phase space navigation
            - 🔍 **Fully Auditable** - Every operation traceable
            - 💻 **Runs Anywhere** - From Raspberry Pi to M4 Max
            
            ---
            
            ## 🏗️ Architecture Overview
            
            ### Core G-Systems
            
            - **G1: 🎯 GyroAlignment** - Pattern recognition and tensor operations
            - **G2: 📚 GyroInformation** - Information processing and storage  
            - **G3: 🧠 GyroInference** - Logical reasoning and interaction
            - **G4: 🌍 GyroIntelligence-IN** - Environmental integration
            - **G5: 🚀 GyroIntelligence-EN** - Policy execution and adaptation
            - **G6: 🔄 GyroCirculation** - System-wide coordination
            
            ### Memory Architecture
            
            Each G-system maintains its own memory type:
            
            | G-System | Memory Type | Icon | Purpose |
            |----------|-------------|------|---------|
            | G1 | **Genetic** | 🧬 | Core structural patterns |
            | G2 | **Epigenetic** | 🔄 | Adaptive data modifications |
            | G3 | **Structural** | 🏗️ | Session and inference traces |
            | G4 | **Somatic** | 🌍 | Environmental state |
            | G5 | **Immunity** | 🛡️ | Policy decisions |
            
            ---
            
            ## 🚀 Quick Start
            
            ### Prerequisites
            
            - Python 3.11+
            - 4GB RAM minimum
            - No GPU required! 🎉
            
            ### Installation
            
            ```bash
            # 1️⃣ Clone the repository
            git clone https://github.com/GyroSuperintelligence/GyroSI.git
            cd GyroSI
            
            # 2️⃣ Create virtual environment
            python -m venv venv
            source venv/bin/activate  # Windows: venv\Scripts\activate
            
            # 3️⃣ Install GyroSI
            pip install -e ".[dev]"
            
            # 4️⃣ Run your first tensor evolution!
            python -m gyro_si.demo
            ```
            
            ---
            
            ## 🛠️ Development Status
            
            <div align="center">
            
            | Component | Status | Progress | Notes |
            |-----------|--------|----------|-------|
            | G1 Core Tensor Ops | 🟢 Implemented | ██████████ 100% | Core operations complete |
            | G2 Information Pipeline | 🟡 In Progress | ████████░░ 80% | Building lexicon system |
            | G3 Inference Engine | 🟡 In Progress | ██████░░░░ 60% | API layer development |
            | G4 Intelligence-IN | 🟡 In Progress | ████░░░░░░ 40% | Environmental sensors |
            | G5 Intelligence-EN | 🟡 In Progress | ████░░░░░░ 40% | Policy framework |
            | G6 Circulation | 🟢 Implemented | ██████████ 100% | Coordination complete |
            | Frontend UI | 🟡 In Progress | █████░░░░░ 50% | Flet-based interface |
            
            </div>
            
            ### 🎯 Current Focus
            
            - Completing G2-G5 implementations based on published guides
            - Praying any of this will actually work
            - Testing
            
            ---
            
            ## 📁 Project Structure
            
            ```
            🌀 GyroSI/
            ├── 📦 gyro_si/
            │   ├── 🎯 g1_gyroalignment/      # Tensor operations & alignment
            │   ├── 📚 g2_gyroinformation/    # Data processing & lexicon
            │   ├── 🧠 g3_gyroinference/      # Inference & interaction
            │   ├── 🌍 g4_gyrointelligence_in/  # Environmental integration
            │   ├── 🚀 g5_gyrointelligence_en/  # Policy & generation
            │   ├── 🔄 g6_gyrocirculation/    # System coordination
            │   └── 🏥 gyro_gcr/              # Core integration layer
            ├── 🧪 tests/                     # Comprehensive test suite
            ├── 📊 benchmarks/                # Performance measurements
            ├── 🛠️ scripts/                   # Development utilities
            ├── 📖 docs/                      # Documentation & theory
            └── 🎨 patterns/                  # Canonical tensor templates
            ```
            
            ---
            
            ## 🤝 Contributing
            
            We welcome contributions! Here's how to get involved:
            
            ```bash
            # 1️⃣ Fork & clone
            git clone https://github.com/YOUR_USERNAME/GyroSI.git
            
            # 2️⃣ Create feature branch
            git checkout -b feature/amazing-feature
            
            # 3️⃣ Make changes & test
            pytest tests/
            black gyro_si/
            mypy gyro_si/
            
            # 4️⃣ Commit with clear message
            git commit -m "Add: Description of your amazing feature"
            
            # 5️⃣ Push & create PR
            git push origin feature/amazing-feature
            ```
            
            ---
            
            ## 📚 Documentation
            
            - 📖 [ＧＹＲ⊕ SuperIntelligence: Development Guides](https://korompilias.notion.site/SuperIntelligence-Development-Guides-1fc9ff44f4368022a2bad40a97bd7462)
            - 📖 [Common Governance Model (CGM): Foundations](https://korompilias.notion.site/Common-Governance-Model-Foundations-1ee9ff44f4368050af28d1c0f8aae89a)
            
            ---
            
            ## 📊 Predicted Performance
            
            <div align="center">
            
            | Platform | Tokens/sec* | Memory* | Response Time* |
            |----------|-------------|---------|----------------|
            | 🥧 Raspberry Pi 5 | 8-12k | 400MB | 200ms |
            | 💻 2015 MacBook | 20-30k | 1GB | 100ms |
            | 📱 iPhone 15 Pro | 50-70k | 2GB | 50ms |
            | 🚀 M4 MacBook | 100k+ | 4GB | 30ms |
            
            **Predicted based on theoretical calculations and architecture design*
            
            *No GPU required - Designed for CPU efficiency!*
            
            </div>
            
            ---
            
            ## 📜 License
            
            This project is licensed under the MIT License - see [LICENSE](LICENSE) for details.
            
            ---
            
            ## 📖 Citation
            
            If you use GyroSI in your research, please cite:
            
            ```bibtex
            @software{gyrosi2025,
              author = {Basil Korompilias},
              title = {GyroSI Baby LM: Alignment-Based Gyroscopic Superintelligence Language Model},
              year = {2025},
              url = {https://github.com/GyroSuperintelligence/BabyLM},
              note = {Implements physics-based principles for language learning 
                      through recursive structural alignment without traditional parameters}
            }
            ```
            
            ---
            
            <div align="center">
            
            ### 🌟 Mind Giving Us a Star?
            
            If you find **GyroSI** interesting or valuable, consider supporting the project by starring the repo:
            
            [![Star](https://img.shields.io/github/stars/GyroSuperintelligence/BabyLM?style=social)](https://github.com/GyroSuperintelligence/BabyLM/stargazers)
            
            ---
            
            **Architected by Basil Korompilias**
            
            *Redefining Intelligence Through Physics*
            
            </div>
            ```
            
    - **Batch 1.3: Initial Test Stubs ✅**
        - `tests/conftest.py`
            
            ```python
            """
            Shared pytest configuration and fixtures for GyroSI test suite.
            
            This module provides common fixtures and utilities used across all tests.
            """
            
            import pytest
            from unittest.mock import Mock, AsyncMock, MagicMock
            
            @pytest.fixture
            def mock_config():
                """
                Provides a mock configuration object for testing.
            
                Returns a mock with all config flags that can be easily toggled:
                - enable_bootstrap
                - enable_transactions
                - enable_recovery_beacons
                - enable_entropy_tracking
                - enable_crypto_evolution
                - lightweight_transactions
                - fast_entropy_hash
                """
                config = Mock()
                config.enable_bootstrap = True
                config.enable_transactions = True
                config.enable_recovery_beacons = True
                config.enable_entropy_tracking = False
                config.enable_crypto_evolution = False
                config.lightweight_transactions = True
                config.fast_entropy_hash = True
                return config
            
            @pytest.fixture
            def mock_router():
                """
                Provides a mock message router for testing communication.
            
                The router captures all sent messages and allows inspection
                of routing behavior without real async operations.
                """
                router = Mock()
                router.messages_sent = []
                router.subscribers = {}
            
                async def mock_send_message(message):
                    router.messages_sent.append(message)
            
                def mock_subscribe(msg_type, handler):
                    if msg_type not in router.subscribers:
                        router.subscribers[msg_type] = []
                    router.subscribers[msg_type].append(handler)
            
                router.send_message = AsyncMock(side_effect=mock_send_message)
                router.subscribe = Mock(side_effect=mock_subscribe)
                router.get_messages = AsyncMock(return_value=[])
            
                return router
            
            @pytest.fixture
            def sample_tensor_state():
                """
                Provides a sample tensor state dictionary for testing.
            
                Returns a dict with all required tensor fields at their
                initial values.
                """
                return {
                    "tensor_id": 12345,
                    "stage": "CS",
                    "indptr": [0, 2, 4, 6],
                    "indices": [0, 1, 0, 1, 0, 1],
                    "data": [1, 1, 1, 1, 1, 1],
                    "amplitude": 0.0,
                    "cumulative_phase": 0.0,
                    "chirality_phase": 0.0,
                    "last_epsilon": 0.0,
                    "cycle_index": 0
                }
            
            @pytest.fixture
            def sample_message():
                """
                Provides a sample message dictionary with all required fields.
                """
                return {
                    "type": "test_message",
                    "source": "G1",
                    "destination": "G2",
                    "cycle_index": 42,
                    "tensor_context": {
                        "cumulative_phase": 1.57,
                        "chirality_phase": 1.57,
                        "helical_position": 0.25,
                        "spinor_cycle_count": 0
                    },
                    "payload": {"test": "data"},
                    "timestamp": "2025-01-01T00:00:00Z"
                } 
            ```
            
        - `tests/unit/test_bootstrap.py`
            
            ```python
            """
            Test suite for the bootstrap protocol.
            
            This module tests that actors properly wait for and respond to the
            gyro_bootstrap signal, exiting their gating loop within the required
            30-second timeout.
            
            Expected imports when modules are available:
            - from gyro_si.gyro_gcr.gyro_config import config
            - from gyro_si.gyro_comm import send_message, MessageTypes
            """
            
            import pytest
            import asyncio
            from unittest.mock import Mock, patch
            
            # Gracefully handle missing modules
            gyro_config = pytest.importorskip("gyro_si.gyro_gcr.gyro_config", reason="gyro_gcr not yet implemented")
            gyro_comm = pytest.importorskip("gyro_si.gyro_comm", reason="gyro_comm not yet implemented")
            
            @pytest.mark.skip(reason="Pending implementation of G1–G5 subsystems")
            class TestBootstrapProtocol:
                """Tests for the bootstrap broadcast and actor gating mechanism."""
            
                @pytest.mark.asyncio
                async def test_bootstrap_signal_sent(self, mock_router):
                    """Test that G2 sends the bootstrap signal after 0.5s delay."""
                    # TODO: Implement when G2 runner is available
                    # Expected behavior:
                    # 1. G2 runner sleeps for 0.5 seconds
                    # 2. Sends message with type="gyro_bootstrap"
                    # 3. Message is broadcast to all other systems
                    pass
            
                @pytest.mark.asyncio
                async def test_actors_wait_for_bootstrap(self, mock_config):
                    """Test that actors block until receiving bootstrap signal."""
                    # TODO: Implement when actor runners are available
                    # Expected behavior:
                    # 1. Actor checks config.enable_bootstrap
                    # 2. If True, enters wait loop
                    # 3. Sets _bootstrapped=True on receiving signal
                    pass
            
                @pytest.mark.asyncio
                async def test_bootstrap_timeout(self):
                    """Test that actors raise error after 30s without bootstrap."""
                    # TODO: Implement timeout behavior test
                    # Expected behavior:
                    # 1. Actor waits for bootstrap
                    # 2. After 30 seconds, raises RuntimeError
                    # 3. Error message: "Gyro bootstrap timeout after 30 s"
                    pass
            
                @pytest.mark.asyncio
                async def test_bootstrap_disabled(self, mock_config):
                    """Test that actors proceed immediately when bootstrap is disabled."""
                    mock_config.enable_bootstrap = False
                    # TODO: Test that actors skip wait loop entirely
                    pass
            
                def test_bootstrap_message_format(self, sample_message):
                    """Test that bootstrap message has correct structure."""
                    # TODO: Verify message type and broadcast destination
                    pass
            
            ```
            
        - `tests/unit/test_transactions.py`
            
            ```python
            """
            Test suite for tensor transaction safety.
            
            This module tests that tensor state is properly snapshotted and restored
            when transactions are aborted, ensuring atomic operations.
            
            Expected imports when modules are available:
            - from gyro_si.gyro_gcr.gyro_config import config
            - from gyro_si.g1_gyroalignment.cs.g1_governance import tensor_transaction
            """
            
            import pytest
            import numpy as np
            from unittest.mock import Mock, MagicMock
            
            # Gracefully handle missing modules
            gyro_config = pytest.importorskip("gyro_si.gyro_gcr.gyro_config", reason="gyro_gcr not yet implemented")
            g1_identity = pytest.importorskip("gyro_si.g1_gyroalignment.cs.g1_governance", reason="g1_gyroalignment not yet implemented")
            
            @pytest.mark.skip(reason="Pending implementation of G1–G5 subsystems")
            class TestTensorTransactions:
                """Tests for atomic tensor state updates."""
            
                @pytest.mark.asyncio
                async def test_transaction_snapshot_created(self, sample_tensor_state):
                    """Test that tensor state is snapshotted at transaction start."""
                    # TODO: Implement when tensor_transaction is available
                    # Expected behavior:
                    # 1. Context manager creates deep copy of all fields
                    # 2. Snapshot includes: indptr, indices, data, amplitude,
                    #    cumulative_phase, chirality_phase, last_epsilon, cycle_index
                    pass
            
                @pytest.mark.asyncio
                async def test_transaction_rollback_on_exception(self, sample_tensor_state):
                    """Test that tensor state is restored after exception."""
                    # TODO: Verify all tensor fields are restored
                    # Expected behavior:
                    # 1. Exception within context causes rollback
                    # 2. All fields restored to snapshot values
                    # 3. Log entry: "tensor_transaction_abort"
                    pass
            
                @pytest.mark.asyncio
                async def test_transaction_commit_on_success(self, sample_tensor_state):
                    """Test that tensor state persists after successful transaction."""
                    # TODO: Verify state changes are kept
                    # Expected behavior:
                    # 1. Changes within context are preserved
                    # 2. Log entry: "tensor_transaction_end"
                    pass
            
                @pytest.mark.asyncio
                async def test_transaction_disabled(self, mock_config):
                    """Test that transactions are no-op when disabled."""
                    mock_config.enable_transactions = False
                    # TODO: Verify context manager yields immediately
                    pass
            
                def test_snapshot_includes_all_fields(self, sample_tensor_state):
                    """Test that snapshot captures all required tensor fields."""
                    required_fields = {
                        "indptr", "indices", "data", "amplitude",
                        "cumulative_phase", "chirality_phase",
                        "last_epsilon", "cycle_index"
                    }
                    # TODO: Verify snapshot contains all required fields
                    pass
            
                def test_lightweight_transaction_optimization(self, mock_config):
                    """Test that lightweight mode uses optimized snapshots."""
                    mock_config.lightweight_transactions = True
                    # TODO: Verify only changed fields are stored
                    pass
            
            ```
            
        - `tests/unit/test_recovery.py`
            
            ```python
            """
            Test suite for circuit recovery beacons.
            
            This module tests that closed circuit breakers trigger cardiac_recovered
            signals and properly reset subsystem rates.
            
            Expected imports when modules are available:
            - from gyro_si.gyro_gcr.gyro_config import config
            - from gyro_si.gyro_comm import send_message, CircuitState, MessageTypes
            """
            
            import pytest
            import asyncio
            from unittest.mock import Mock, patch, AsyncMock
            
            # Gracefully handle missing modules
            gyro_config = pytest.importorskip("gyro_si.gyro_gcr.gyro_config", reason="gyro_gcr not yet implemented")
            gyro_comm = pytest.importorskip("gyro_si.gyro_comm", reason="gyro_comm not yet implemented")
            
            @pytest.mark.skip(reason="Pending implementation of G1–G5 subsystems")
            class TestCircuitRecovery:
                """Tests for circuit breaker recovery and beacon signals."""
            
                @pytest.mark.asyncio
                async def test_circuit_state_change_triggers_beacon(self, mock_router):
                    """Test that HALF_OPEN->CLOSED transition sends cardiac_recovered."""
                    # TODO: Implement when circuit breaker logic is available
                    # Expected behavior:
                    # 1. State change from HALF_OPEN to CLOSED
                    # 2. Message sent with type="cardiac_recovered"
                    # 3. Message includes source="G1"
                    pass
            
                @pytest.mark.asyncio
                async def test_g4_resets_breath_rate_on_recovery(self):
                    """Test that G4 resets breath_rate_multiplier to 1.0."""
                    # TODO: Implement when G4 recovery handler is available
                    # Expected behavior:
                    # 1. G4 receives cardiac_recovered message
                    # 2. Sets breath_rate_multiplier = 1.0
                    # 3. Logs "breath_rate_reset" with cycle_index
                    pass
            
                @pytest.mark.asyncio
                async def test_recovery_beacon_includes_source(self, sample_message):
                    """Test that recovery beacon message includes correct source."""
                    sample_message["type"] = "cardiac_recovered"
                    # TODO: Verify message format and source field
                    pass
            
                @pytest.mark.asyncio
                async def test_recovery_disabled(self, mock_config, mock_router):
                    """Test that no beacons sent when recovery is disabled."""
                    mock_config.enable_recovery_beacons = False
                    # TODO: Verify no cardiac_recovered messages sent
                    pass
            
                def test_circuit_states_enum(self):
                    """Test that CircuitState enum has required states."""
                    # TODO: Verify CLOSED, OPEN, HALF_OPEN states exist
                    # Expected: CircuitState.CLOSED, CircuitState.OPEN, CircuitState.HALF_OPEN
                    pass
            
                @pytest.mark.asyncio
                async def test_circuit_breaker_callback_registration(self):
                    """Test that state change callbacks are properly registered."""
                    # TODO: Verify breaker.on_state_change() method exists
                    pass
            
            ```
            
        - `tests/unit/test_entropy_chain.py`
            
            ```python
            """
            Test suite for entropy ID chaining.
            
            This module tests that entropy_id values persist correctly through the
            G4 → G1 → G5 chain when entropy tracking is enabled.
            
            Expected imports when modules are available:
            - from gyro_si.gyro_gcr.gyro_config import config
            - from gyro_si.gyro_comm import send_message
            """
            
            import pytest
            from unittest.mock import Mock, patch
            
            # Gracefully handle missing modules
            gyro_config = pytest.importorskip("gyro_si.gyro_gcr.gyro_config", reason="gyro_gcr not yet implemented")
            gyro_comm = pytest.importorskip("gyro_si.gyro_comm", reason="gyro_comm not yet implemented")
            
            @pytest.mark.skip(reason="Pending implementation of G1–G5 subsystems")
            class TestEntropyChain:
                """Tests for entropy ID generation and propagation."""
            
                def test_g4_generates_entropy_id(self, mock_config):
                    """Test that G4 generates entropy_id during payload assembly."""
                    mock_config.enable_entropy_tracking = True
                    # TODO: Implement when G4 entropy generation is available
                    # Expected format: f"{thermal}|{interaction}|{quantum}"
                    pass
            
                def test_entropy_id_format_crc32(self, mock_config):
                    """Test that fast_entropy_hash uses CRC32 format."""
                    mock_config.fast_entropy_hash = True
                    # TODO: Verify 8-character hex format
                    # Expected: f"{zlib.crc32(seed.encode()):08x}"
                    pass
            
                def test_entropy_id_format_sha256(self, mock_config):
                    """Test that SHA256 is used when fast_entropy_hash is False."""
                    mock_config.fast_entropy_hash = False
                    # TODO: Verify 16-character hex format
                    # Expected: hashlib.sha256(seed.encode()).hexdigest()[:16]
                    pass
            
                @pytest.mark.asyncio
                async def test_g1_forwards_entropy_id(self, sample_message):
                    """Test that G1 includes received entropy_id in outgoing beats."""
                    sample_message["payload"]["entropy_id"] = "12345678"
                    # TODO: Verify G1 preserves entropy_id in responses
                    pass
            
                @pytest.mark.asyncio
                async def test_g5_records_entropy_id(self, sample_message):
                    """Test that G5 records entropy_id in trace collector."""
                    sample_message["payload"]["entropy_id"] = "12345678"
                    # TODO: Verify G5 includes entropy_id in audit trail
                    pass
            
                def test_entropy_tracking_disabled(self, mock_config):
                    """Test that no entropy_id generated when tracking disabled."""
                    mock_config.enable_entropy_tracking = False
                    # TODO: Verify payload has no entropy_id field
                    pass
            
                def test_entropy_seed_components(self):
                    """Test that entropy seed includes all required components."""
                    # TODO: Verify seed includes thermal, interaction, quantum
                    pass
            
            ```
            
        - `tests/unit/test_crypto_evolution.py`
            
            ```python
            """
            Test suite for differential crypto evolution.
            
            This module tests that the three-term amplitude evolution formula is
            correctly applied when crypto evolution is enabled.
            
            Expected imports when modules are available:
            - from gyro_si.gyro_constants import ALPHA, BETA, GAMMA, M_P
            - from gyro_si.gyro_gcr.gyro_config import config
            """
            
            import pytest
            import math
            from unittest.mock import Mock, patch
            
            # Gracefully handle missing modules
            gyro_constants = pytest.importorskip("gyro_si.gyro_constants", reason="gyro_constants not yet implemented")
            gyro_config = pytest.importorskip("gyro_si.gyro_gcr.gyro_config", reason="gyro_gcr not yet implemented")
            
            @pytest.mark.skip(reason="Pending implementation of G1–G5 subsystems")
            class TestCryptoEvolution:
                """Tests for the three-term differential evolution formula."""
            
                def test_differential_evolve_formula(self, mock_config):
                    """Test that amplitude follows the three-term formula."""
                    mock_config.enable_crypto_evolution = True
                    # Formula: amplitude = (amplitude + phi * M_P + eps_prev * (BETA/ALPHA) + t * (GAMMA/ALPHA)) % (4 * pi)
                    # TODO: Implement when differential_evolve is available
                    # Expected behavior:
                    # 1. Current amplitude + phi * M_P term
                    # 2. Previous epsilon * (BETA/ALPHA) term
                    # 3. Time component * (GAMMA/ALPHA) term
                    # 4. Result wrapped with modulo 4π
                    pass
            
                def test_amplitude_modulo_4pi(self):
                    """Test that amplitude wraps at 4π."""
                    # TODO: Verify modulo operation
                    # Expected: result % (4 * math.pi)
                    pass
            
                def test_last_epsilon_updated(self, sample_tensor_state):
                    """Test that last_epsilon is stored for next iteration."""
                    # TODO: Verify eps_prev tracking
                    # Expected: self.last_epsilon = eps_prev after update
                    pass
            
                def test_time_component(self):
                    """Test that time component uses modulo 4π."""
                    # TODO: Verify t = time.time() % (4 * math.pi)
                    pass
            
                def test_crypto_evolution_disabled(self, mock_config):
                    """Test that simple amplitude update used when disabled."""
                    mock_config.enable_crypto_evolution = False
                    # TODO: Verify standard amplitude update is used
                    pass
            
                def test_evolution_logged(self):
                    """Test that differential evolution is logged with all parameters."""
                    # TODO: Verify log includes phi, eps_prev, t, cycle_index
                    # Expected log entry: "differential_evolve" with all parameters
                    pass
            
                def test_cgm_constants_used(self):
                    """Test that only CGM constants are used in formula."""
                    # TODO: Verify ALPHA, BETA, GAMMA, M_P are imported and used
                    # No arbitrary constants should appear
                    pass
            
                def test_three_term_structure(self):
                    """Test that formula has exactly three additive terms plus base."""
                    # TODO: Verify structure: base + term1 + term2 + term3
                    # 1. phi * M_P (quantization term)
                    # 2. eps_prev * (BETA/ALPHA) (memory term)
                    # 3. t * (GAMMA/ALPHA) (time term)
                    pass
            
            ```
            
    
    ---
    
    ### **Phase 2: The Core Engine (G1 GyroAlignment)**
    
    - **Batch 2.1: GyroTensor Object Definition ✅**
        - `gyro_si/g1_gyroalignment/gyro_tensor.py`
            
            ```python
            """
            GyroTensor: Core tensor object for GyroSI.
            
            This module implements the fundamental tensor structure that undergoes
            the canonical CS→UNA→ONA→BU_In→BU_En→ONA→UNA→CS cycle. The GyroTensor
            orchestrates its own lifecycle by calling into the appropriate stage
            modules while maintaining strict adherence to CGM constants and
            structural accountability.
            
            All tensor operations preserve memory of origin and maintain continuous
            coherence between emergence and recollection.
            """
            
            import math
            import time
            import hashlib
            import logging
            import asyncio
            from typing import Dict, List, Optional, Tuple, Any
            from enum import Enum
            from dataclasses import dataclass
            
            # Absolute imports
            from gyro_si.gyro_constants import ALPHA, BETA, GAMMA, M_P, HALF_HORIZON
            from gyro_si.gyro_errors   import StructuralViolation, QuantizationDefect, HelicalCoherenceError
            from gyro_si.gyro_comm     import send_message, MessageTypes, create_tensor_context
            
            logger = logging.getLogger(__name__)
            
            class TensorStage(Enum):
                """Canonical tensor stages in the recursive cycle."""
                CS = "CS"           # Closure/Identity stage
                UNA = "UNA"         # Unary/Normalization stage
                ONA = "ONA"         # Binary/Correlation stage
                BU_IN = "BU_In"     # Integrative quantization
                BU_EN = "BU_En"     # Generative quantization
            
            class OperationType(Enum):
                """Types of operations between stages."""
                GENERATION = "generation"     # CS→UNA, BU_In→BU_En, BU_En→ONA, UNA→CS
                INTEGRATION = "integration"   # UNA→ONA, ONA→BU_In
            
            @dataclass
            class StageTransition:
                """Defines a valid stage transition."""
                from_stage: TensorStage
                to_stage: TensorStage
                operation_type: OperationType
            
            # Canonical stage transition table - unified for forward and return paths
            # Key: (current_stage, is_forward_path) -> StageTransition
            STAGE_TRANSITIONS = {
                # Forward path transitions
                (TensorStage.CS, True): StageTransition(TensorStage.CS, TensorStage.UNA, OperationType.GENERATION),
                (TensorStage.UNA, True): StageTransition(TensorStage.UNA, TensorStage.ONA, OperationType.INTEGRATION),
                (TensorStage.ONA, True): StageTransition(TensorStage.ONA, TensorStage.BU_IN, OperationType.INTEGRATION),
                (TensorStage.BU_IN, True): StageTransition(TensorStage.BU_IN, TensorStage.BU_EN, OperationType.GENERATION),
                (TensorStage.BU_EN, True): StageTransition(TensorStage.BU_EN, TensorStage.ONA, OperationType.GENERATION),
            
                # Return path transitions
                (TensorStage.ONA, False): StageTransition(TensorStage.ONA, TensorStage.UNA, OperationType.INTEGRATION),
                (TensorStage.UNA, False): StageTransition(TensorStage.UNA, TensorStage.CS, OperationType.GENERATION),
            }
            
            class GyroTensor:
                """
                Core tensor object implementing the canonical CS→UNA→ONA→BU→CS cycle.
            
                The GyroTensor maintains its own state and orchestrates transitions
                through the five canonical stages. All operations are structurally
                accountable and preserve helical trajectory information.
            
                Note: All tensor transitions must occur under an active asyncio event loop,
                as status updates and algedonic signals are sent asynchronously.
                """
            
                def __init__(self, tensor_id: int, parent_id: Optional[int] = None):
                    """
                    Initialize a new GyroTensor in CS stage.
            
                    Args:
                        tensor_id: Unique identifier for this tensor
                        parent_id: ID of parent tensor if this is spawned
                    """
                    # Identity and lineage
                    self.tensor_id = tensor_id
                    self.parent_id = parent_id
                    self.creation_time = time.time()
            
                    # Stage and cycle tracking
                    self.stage = TensorStage.CS
                    self.cycle_index = 0
                    self.transition_count = 0
            
                    # Helical trajectory tracking
                    self.cumulative_phase = 0.0      # [0, 4π) - Total helical progress
                    self.chirality_phase = 0.0       # [0, 2π) - Forward/return position
                    self.helical_position = 0.0      # [0, 1) - Normalized fraction
                    self.spinor_cycle_count = 0      # Number of completed 720° revolutions
            
                    # Amplitude and quantization
                    self.amplitude = 0.0             # Bounded by ±mₚ
                    self.last_epsilon = 0.0          # Previous quantization error
            
                    # CSR storage (allocated post-CS)
                    self.indptr: Optional[List[int]] = None
                    self.indices: Optional[List[int]] = None
                    self.data: Optional[List[int]] = None  # Values in {0, 1, -1} encoded as {0, 1, 2}
            
                    # State tracking
                    self.is_forward_path = True      # True for 0→2π, False for 2π→4π
                    self.spawn_ready = False         # True when |amplitude| ≥ mₚ and cumulative_phase ≥ 4π
            
                    # Audit and logging
                    self.state_checksum = self._compute_checksum()
                    self.trace_buffer: List[Dict[str, Any]] = []
            
                    self._log("tensor_created",
                             tensor_id=tensor_id,
                             parent_id=parent_id,
                             stage=self.stage.value)
            
                def _compute_checksum(self) -> str:
                    """Compute SHA-256 checksum of current tensor state."""
                    state_data = (
                        self.tensor_id,
                        self.stage.value,
                        tuple(self.indptr) if self.indptr else (),
                        tuple(self.indices) if self.indices else (),
                        tuple(self.data) if self.data else (),
                        self.amplitude,
                        self.cumulative_phase,
                        self.chirality_phase
                    )
                    state_str = str(state_data).encode('utf-8')
                    return hashlib.sha256(state_str).hexdigest()
            
                def _log(self, event_type: str, **kwargs) -> None:
                    """Log an event to the trace buffer."""
                    entry = {
                        "event_type": event_type,
                        "tensor_id": self.tensor_id,
                        "stage": self.stage.value,
                        "cycle_index": self.cycle_index,
                        "timestamp": time.time(),
                        "checksum": self.state_checksum,
                        **kwargs
                    }
                    self.trace_buffer.append(entry)
                    logger.debug(f"Tensor {self.tensor_id}: {event_type}", extra=kwargs)
            
                def _validate_stage_transition(self, target_stage: TensorStage) -> bool:
                    """
                    Validate that a stage transition is permitted.
            
                    Args:
                        target_stage: The stage to transition to
            
                    Returns:
                        True if transition is valid
            
                    Raises:
                        StructuralViolation: If transition is not permitted
                    """
                    transition_key = (self.stage, self.is_forward_path)
            
                    if transition_key not in STAGE_TRANSITIONS:
                        raise StructuralViolation(
                            f"No valid transition from stage {self.stage.value} "
                            f"(forward_path={self.is_forward_path})"
                        )
            
                    expected_transition = STAGE_TRANSITIONS[transition_key]
                    if target_stage != expected_transition.to_stage:
                        raise StructuralViolation(
                            f"Invalid transition: {self.stage.value} → {target_stage.value}, "
                            f"expected {expected_transition.to_stage.value} "
                            f"(forward_path={self.is_forward_path})"
                        )
            
                    return True
            
                def _update_helical_trajectory(self, phase_delta: float) -> None:
                    """
                    Update helical trajectory tracking.
            
                    Args:
                        phase_delta: Change in phase for this transition (must be > 0)
                    """
                    if phase_delta <= 0:
                        raise ValueError(f"phase_delta must be positive, got {phase_delta}")
            
                    # Update cumulative phase
                    old_cumulative = self.cumulative_phase
                    old_chirality = old_cumulative % (2 * math.pi)
            
                    self.cumulative_phase = (self.cumulative_phase + phase_delta) % (4 * math.pi)
            
                    # Update chirality phase
                    self.chirality_phase = self.cumulative_phase % (2 * math.pi)
            
                    # Update helical position (normalized)
                    self.helical_position = self.cumulative_phase / (4 * math.pi)
            
                    # Check for spinor cycle completion (720° = 4π)
                    if old_cumulative < 4 * math.pi <= self.cumulative_phase:
                        self.spinor_cycle_count += 1
                        self._log("spinor_cycle_completed",
                                 cycle_count=self.spinor_cycle_count,
                                 cumulative_phase=self.cumulative_phase)
            
                    # Check for chirality flip (360° = 2π)
                    # Simplified logic: if new chirality is less than old, we've wrapped past 2π
                    if self.chirality_phase < old_chirality:
                        self.is_forward_path = not self.is_forward_path
                        self._log("chirality_flip",
                                 is_forward=self.is_forward_path,
                                 chirality_phase=self.chirality_phase)
            
                    # Check spawn readiness
                    if abs(self.amplitude) >= M_P and self.cumulative_phase >= 4 * math.pi:
                        if not self.spawn_ready:
                            self.spawn_ready = True
                            self._log("spawn_ready",
                                     amplitude=self.amplitude,
                                     cumulative_phase=self.cumulative_phase)
            
                def _allocate_csr_storage(self, stage: TensorStage) -> None:
                    """
                    Allocate CSR storage arrays for the given stage.
            
                    Args:
                        stage: Target stage requiring CSR allocation
                    """
                    if stage == TensorStage.CS:
                        # CS stage has no CSR storage
                        self.indptr = None
                        self.indices = None
                        self.data = None
                        return
            
                    # Stage-specific CSR dimensions
                    if stage == TensorStage.UNA:
                        # 3×2 tensor, 6 non-zeros
                        rows, cols, nnz = 3, 2, 6
                    elif stage == TensorStage.ONA:
                        # 2×3×2 tensor, 24 non-zeros
                        rows, cols, nnz = 2, 6, 24  # Flattened to 2×6
                    elif stage in (TensorStage.BU_IN, TensorStage.BU_EN):
                        # 2×2×3×2 tensor, 48 non-zeros
                        rows, cols, nnz = 4, 12, 48  # Flattened to 4×12
                    else:
                        raise StructuralViolation(f"Unknown stage for CSR allocation: {stage}")
            
                    # Allocate CSR arrays
                    self.indptr = [0] * (rows + 1)
                    self.indices = [0] * nnz
                    self.data = [1] * nnz  # Initialize to +1 (encoded as 1)
            
                    # Set up indptr for uniform distribution
                    nnz_per_row = nnz // rows
                    for i in range(rows + 1):
                        self.indptr[i] = i * nnz_per_row
            
                    # Set up indices for uniform column distribution
                    cols_per_row = cols
                    for row in range(rows):
                        start_idx = self.indptr[row]
                        for j in range(nnz_per_row):
                            self.indices[start_idx + j] = j % cols_per_row
            
                    self._log("csr_allocated",
                             stage=stage.value,
                             rows=rows,
                             cols=cols,
                             nnz=nnz)
            
                def transition_to_stage(self, target_stage: TensorStage, phi: float) -> None:
                    """
                    Transition tensor to the target stage.
            
                    Args:
                        target_stage: Stage to transition to
                        phi: Phase input for quantization - REQUIRED for all transitions
                             to ensure alignment-based helical progression
            
                    Raises:
                        StructuralViolation: If transition is invalid
                        QuantizationDefect: If quantization produces invalid results
                        ValueError: If phi is not provided
                    """
                    # Validate transition
                    self._validate_stage_transition(target_stage)
            
                    old_stage = self.stage
                    old_checksum = self.state_checksum
            
                    # Allocate CSR storage if needed
                    if target_stage != TensorStage.CS and self.indptr is None:
                        self._allocate_csr_storage(target_stage)
            
                    # Perform quantization if transitioning to/from BU stages
                    if target_stage in (TensorStage.BU_IN, TensorStage.BU_EN) or old_stage in (TensorStage.BU_IN, TensorStage.BU_EN):
                        epsilon = self._quantize_phase(phi)
                        self._update_amplitude(epsilon)
            
                    # Update stage
                    self.stage = target_stage
                    self.cycle_index += 1
                    self.transition_count += 1
            
                    # Update helical trajectory with explicit phase delta
                    # Use absolute value to ensure positive phase progression
                    phase_delta = abs(phi)
                    self._update_helical_trajectory(phase_delta)
            
                    # Update checksum
                    self.state_checksum = self._compute_checksum()
            
                    # Log transition
                    self._log("stage_transition",
                             from_stage=old_stage.value,
                             to_stage=target_stage.value,
                             phi=phi,
                             phase_delta=phase_delta,
                             old_checksum=old_checksum,
                             new_checksum=self.state_checksum)
            
                    # Send status update if significant transition
                    if target_stage in (TensorStage.BU_IN, TensorStage.BU_EN, TensorStage.CS):
                        try:
                            # Get the running event loop safely
                            loop = asyncio.get_event_loop()
                            if loop.is_running():
                                loop.create_task(self._send_status_update())
                            else:
                                logger.warning(
                                    f"No running event loop for tensor {self.tensor_id} status update"
                                )
                        except RuntimeError:
                            logger.warning(
                                f"No event loop found for tensor {self.tensor_id} status update"
                            )
            
                def _quantize_phase(self, phi: float) -> float:
                    """
                    Quantize continuous phase to discrete values.
            
                    Args:
                        phi: Continuous phase input
            
                    Returns:
                        Quantization error ε = φ - φ_q
            
                    Raises:
                        QuantizationDefect: If quantization error exceeds bounds
                    """
                    # Canonical quantization rule from G1 specification
                    if phi < -M_P / 2:
                        phi_q = -M_P
                    elif phi >= M_P / 2:
                        phi_q = M_P
                    else:
                        phi_q = 0.0
            
                    # Calculate quantization error
                    epsilon = phi - phi_q
            
                    # Validate error bounds
                    if abs(epsilon) > M_P:
                        raise QuantizationDefect(
                            f"Quantization error |ε| = {abs(epsilon)} exceeds mₚ = {M_P}"
                        )
            
                    # Store for next iteration
                    self.last_epsilon = epsilon
            
                    self._log("quantization_event",
                             phi=phi,
                             phi_q=phi_q,
                             epsilon=epsilon)
            
                    return epsilon
            
                def _update_amplitude(self, epsilon: float) -> None:
                    """
                    Update tensor amplitude based on quantization error.
            
                    Args:
                        epsilon: Quantization error from _quantize_phase
                    """
                    old_amplitude = self.amplitude
            
                    # Canonical amplitude update: clip to ±mₚ bounds
                    self.amplitude = max(-M_P, min(M_P, self.amplitude + epsilon))
            
                    self._log("amplitude_update",
                             old_amplitude=old_amplitude,
                             epsilon=epsilon,
                             new_amplitude=self.amplitude)
            
                    # Check for algedonic signal generation
                    if abs(epsilon) > M_P / 2:
                        signal_type = "pain" if epsilon > 0 else "pleasure"
                        try:
                            # Get the running event loop safely
                            loop = asyncio.get_event_loop()
                            if loop.is_running():
                                loop.create_task(self._generate_algedonic_signal(signal_type, epsilon))
                            else:
                                logger.warning(
                                    f"No running event loop for tensor {self.tensor_id} algedonic signal"
                                )
                        except RuntimeError:
                            logger.warning(
                                f"No event loop found for tensor {self.tensor_id} algedonic signal"
                            )
            
                async def _generate_algedonic_signal(self, signal_type: str, epsilon: float) -> None:
                    """
                    Generate algedonic signal when quantization error exceeds threshold.
            
                    Args:
                        signal_type: "pain" or "pleasure"
                        epsilon: Quantization error that triggered the signal
                    """
                    tensor_context = create_tensor_context(
                        cumulative_phase=self.cumulative_phase,
                        chirality_phase=self.chirality_phase,
                        helical_position=self.helical_position,
                        spinor_cycle_count=self.spinor_cycle_count,
                        tensor_id=self.tensor_id,
                        amplitude=self.amplitude
                    )
            
                    message = {
                        "type": MessageTypes.ALGEDONIC_SIGNAL,
                        "source": "G1",
                        "destination": "G2",  # Route through G2 to G4
                        "cycle_index": self.cycle_index,
                        "tensor_context": tensor_context,
                        "payload": {
                            "signal_type": signal_type,
                            "epsilon": epsilon,
                            "tensor_id": self.tensor_id,
                            "stage": self.stage.value,
                            "threshold_exceeded": abs(epsilon) > M_P / 2
                        },
                        "timestamp": time.time()
                    }
            
                    # Actually send the message
                    await send_message(message)
            
                    self._log("algedonic_signal_generated",
                             signal_type=signal_type,
                             epsilon=epsilon,
                             threshold=M_P / 2)
            
                async def _send_status_update(self) -> None:
                    """Send status update to G2 for coordination."""
                    tensor_context = create_tensor_context(
                        cumulative_phase=self.cumulative_phase,
                        chirality_phase=self.chirality_phase,
                        helical_position=self.helical_position,
                        spinor_cycle_count=self.spinor_cycle_count,
                        tensor_id=self.tensor_id,
                        amplitude=self.amplitude
                    )
            
                    message = {
                        "type": MessageTypes.STATUS_UPDATE,
                        "source": "G1",
                        "destination": "G2",
                        "cycle_index": self.cycle_index,
                        "tensor_context": tensor_context,
                        "payload": {
                            "tensor_id": self.tensor_id,
                            "stage": self.stage.value,
                            "amplitude": self.amplitude,
                            "spawn_ready": self.spawn_ready,
                            "transition_count": self.transition_count,
                            "helical_metrics": {
                                "cumulative_phase": self.cumulative_phase,
                                "chirality_phase": self.chirality_phase,
                                "spinor_cycles": self.spinor_cycle_count,
                                "is_forward_path": self.is_forward_path
                            }
                        },
                        "timestamp": time.time()
                    }
            
                    # Actually send the message
                    await send_message(message)
            
                    self._log("status_update_sent",
                             stage=self.stage.value,
                             spawn_ready=self.spawn_ready)
            
                def get_collision_factor(self) -> float:
                    """
                    Calculate collision factor for this tensor.
            
                    Returns:
                        Collision factor as cs_memory / max_discrete
                    """
                    cs_memory = ALPHA  # π/2
                    max_discrete = 3 * M_P
                    return cs_memory / max_discrete
            
                async def execute_full_cycle(self, phi_values: List[float]) -> None:
                    """
                    Execute a complete CS→UNA→ONA→BU→ONA→UNA→CS cycle.
            
                    This method orchestrates the tensor through its complete lifecycle,
                    calling the appropriate stage modules for each transition.
            
                    Args:
                        phi_values: List of 7 phase values for each transition
                                    (CS→UNA, UNA→ONA, ONA→BU_In, BU_In→BU_En,
                                     BU_En→ONA, ONA→UNA, UNA→CS)
            
                    Raises:
                        ValueError: If phi_values doesn't contain exactly 7 values
                        StructuralViolation: If not starting from CS stage
                    """
                    if self.stage != TensorStage.CS:
                        raise StructuralViolation(
                            f"Full cycle must start from CS stage, currently in {self.stage.value}"
                        )
            
                    if len(phi_values) != 7:
                        raise ValueError(f"Expected 7 phi values for full cycle, got {len(phi_values)}")
            
                    self._log("full_cycle_start", cycle_index=self.cycle_index)
            
                    try:
                        # Forward path: CS → UNA → ONA → BU_In → BU_En
                        self.transition_to_stage(TensorStage.UNA, phi_values[0])      # Generation
                        self.transition_to_stage(TensorStage.ONA, phi_values[1])      # Integration
                        self.transition_to_stage(TensorStage.BU_IN, phi_values[2])    # Integration (anomalous)
                        self.transition_to_stage(TensorStage.BU_EN, phi_values[3])    # Generation
            
                        # Return path: BU_En → ONA → UNA → CS
                        self.transition_to_stage(TensorStage.ONA, phi_values[4])      # Generation (return)
                        self.transition_to_stage(TensorStage.UNA, phi_values[5])      # Integration (return)
                        self.transition_to_stage(TensorStage.CS, phi_values[6])       # Generation (closure)
            
                        self._log("full_cycle_complete",
                                 cycle_index=self.cycle_index,
                                 spinor_cycles=self.spinor_cycle_count)
            
                    except Exception as e:
                        self._log("full_cycle_error",
                                 error=str(e),
                                 stage=self.stage.value)
                        raise
            
                def get_tensor_context(self) -> Dict[str, Any]:
                    """
                    Get current tensor context for message passing.
            
                    Returns:
                        Dictionary with helical trajectory and tensor state
                    """
                    return create_tensor_context(
                        cumulative_phase=self.cumulative_phase,
                        chirality_phase=self.chirality_phase,
                        helical_position=self.helical_position,
                        spinor_cycle_count=self.spinor_cycle_count,
                        tensor_id=self.tensor_id,
                        parent_id=self.parent_id,
                        stage=self.stage.value,
                        amplitude=self.amplitude,
                        spawn_ready=self.spawn_ready
                    )
            
                def get_trace_buffer(self) -> List[Dict[str, Any]]:
                    """
                    Get copy of trace buffer for audit purposes.
            
                    Returns:
                        List of trace entries
                    """
                    return self.trace_buffer.copy()
            
                def clear_trace_buffer(self, before_timestamp: Optional[float] = None) -> int:
                    """
                    Clear trace buffer entries.
            
                    Args:
                        before_timestamp: Only clear entries before this timestamp
            
                    Returns:
                        Number of entries cleared
                    """
                    if before_timestamp is None:
                        count = len(self.trace_buffer)
                        self.trace_buffer.clear()
                        return count
            
                    original_count = len(self.trace_buffer)
                    self.trace_buffer = [
                        entry for entry in self.trace_buffer
                        if entry["timestamp"] >= before_timestamp
                    ]
                    return original_count - len(self.trace_buffer)
            
                def validate_structural_integrity(self) -> bool:
                    """
                    Validate tensor structural integrity.
            
                    Returns:
                        True if tensor structure is valid
            
                    Raises:
                        StructuralViolation: If structure is invalid
                    """
                    # Validate stage-specific CSR structure
                    if self.stage == TensorStage.CS:
                        if self.indptr is not None or self.indices is not None or self.data is not None:
                            raise StructuralViolation("CS stage must not have CSR storage")
                    else:
                        if self.indptr is None or self.indices is None or self.data is None:
                            raise StructuralViolation(f"Stage {self.stage.value} requires CSR storage")
            
                        # Validate CSR dimensions
                        expected_nnz = {
                            TensorStage.UNA: 6,
                            TensorStage.ONA: 24,
                            TensorStage.BU_IN: 48,
                            TensorStage.BU_EN: 48
                        }
            
                        if self.stage in expected_nnz:
                            if len(self.data) != expected_nnz[self.stage]:
                                raise StructuralViolation(
                                    f"Stage {self.stage.value} expects {expected_nnz[self.stage]} "
                                    f"non-zeros, got {len(self.data)}"
                                )
            
                    # Validate helical coherence
                    if not (0 <= self.cumulative_phase < 4 * math.pi):
                        raise HelicalCoherenceError(
                            f"cumulative_phase {self.cumulative_phase} outside [0, 4π)"
                        )
            
                    if not (0 <= self.chirality_phase < 2 * math.pi):
                        raise HelicalCoherenceError(
                            f"chirality_phase {self.chirality_phase} outside [0, 2π)"
                        )
            
                    if not (0 <= self.helical_position < 1):
                        raise HelicalCoherenceError(
                            f"helical_position {self.helical_position} outside [0, 1)"
                        )
            
                    # Validate amplitude bounds
                    if abs(self.amplitude) > M_P:
                        raise QuantizationDefect(
                            f"Amplitude {self.amplitude} exceeds bounds ±{M_P}"
                        )
            
                    return True
            
                def __str__(self) -> str:
                    """String representation of tensor."""
                    return (
                        f"GyroTensor(id={self.tensor_id}, stage={self.stage.value}, "
                        f"cycle={self.cycle_index}, amplitude={self.amplitude:.6f}, "
                        f"phase={self.cumulative_phase:.3f})"
                    )
            
                def __repr__(self) -> str:
                    """Developer representation of tensor."""
                    return (
                        f"GyroTensor(tensor_id={self.tensor_id}, parent_id={self.parent_id}, "
                        f"stage={self.stage.value}, cycle_index={self.cycle_index}, "
                        f"amplitude={self.amplitude}, cumulative_phase={self.cumulative_phase}, "
                        f"spawn_ready={self.spawn_ready})"
                    )
            
            class TensorFamily:
                """
                Manages phase-locked family members and spawning relationships.
            
                This class tracks lineage relationships and coordinates spawning
                when amplitude and phase conditions are met.
                """
            
                def __init__(self, root_tensor_id: int):
                    """
                    Initialize tensor family with root tensor.
            
                    Args:
                        root_tensor_id: ID of the root tensor for this family
                    """
                    self.root_tensor_id = root_tensor_id
                    self.members: Dict[int, GyroTensor] = {}
                    self.lineage_graph: Dict[int, List[int]] = {}  # parent_id -> [child_ids]
                    self.creation_time = time.time()
            
                def add_tensor(self, tensor: GyroTensor) -> None:
                    """Add tensor to family and update lineage."""
                    self.members[tensor.tensor_id] = tensor
                    if tensor.parent_id is not None:
                        self.lineage_graph.setdefault(tensor.parent_id, []).append(tensor.tensor_id)
            
                def get_spawn_candidates(self) -> List[GyroTensor]:
                    """Get tensors ready for spawning."""
                    return [t for t in self.members.values() if t.spawn_ready]
            
                def get_family_metrics(self) -> Dict[str, Any]:
                    """Get metrics for the entire tensor family."""
                    if not self.members:
                        return {
                            "family_size": 0,
                            "total_amplitude": 0.0,
                            "average_phase": 0.0,
                            "spawn_ready_count": 0,
                            "lineage_depth": 0
                        }
            
                    total_amplitude   = sum(t.amplitude for t in self.members.values())
                    average_phase     = sum(t.cumulative_phase for t in self.members.values()) / len(self.members)
                    spawn_ready_count = len(self.get_spawn_candidates())
            
                    # Compute maximum lineage depth via DFS
                    lineage_depth = 0
                    visited = set()
            
                    def dfs(node_id: int, depth: int):
                        nonlocal lineage_depth
                        visited.add(node_id)
                        lineage_depth = max(lineage_depth, depth)
                        for child in self.lineage_graph.get(node_id, []):
                            if child not in visited:
                                dfs(child, depth + 1)
            
                    # Start DFS from root
                    dfs(self.root_tensor_id, 0)
            
                    return {
                        "family_size":        len(self.members),
                        "total_amplitude":    total_amplitude,
                        "average_phase":      average_phase,
                        "spawn_ready_count":  spawn_ready_count,
                        "lineage_depth":      lineage_depth
                    }
            ```
            
    - **Batch 2.2: Stage Logic Implementation**
        - `gyro_si/g1_gyroalignment/cs/g1_governance.py`
            
            ```python
            """
            G1 CS Stage: Governance Traceability
            
            CS is the tensor identity τ - the symbol on the left side of every tensor equation.
            It embodies the primordial left chirality that cannot be represented as tensor values.
            It exists only as the identity that initiates all subsequent structure.
            
            The π/2 threshold (ALPHA) represents the unobservable chirality seed that permeates
            all subsequent stages as the fundamental memory that must be preserved throughout
            the tensor's evolution.
            """
            
            # ───────────────────── imports & shared infrastructure ──────────────────
            import logging
            import time
            import hashlib
            import threading
            from typing import Dict, Any
            from contextlib import contextmanager
            
            from gyro_si.gyro_constants import ALPHA
            from gyro_si.gyro_errors import StructuralViolation
            from gyro_si.gyro_gcr.gyro_config import config
            
            logger = logging.getLogger(__name__)
            
            # Import the proper G1 infrastructure
            from gyro_si.g1_gyroalignment.genetic_memory import GeneticMemory
            
            # Shared stage transition lock (this is appropriate to define here as it's cross-stage)
            stage_transition_lock = threading.RLock()
            
            SCHEMA_VERSION = "v1"
            
            # ─────────────────────────── class definition ───────────────────────────
            
            class CSIdentity:
                """Represents tensor identity, the unobservable Common Source.
                
                This stage holds no structural data (CSR arrays are None) and serves as
                the origin of the tensor's lifecycle, carrying the π/2 chirality seed
                as its core, unobservable memory.
                
                The CS stage embodies:
                - Left gyration: lgyr ≠ id (encoded in the tensor identity)
                - Right gyration: rgyr = id (not yet active)
                - Degrees of freedom: 1 (chiral seed)
                - Threshold: α = π/2 (the unobservable chirality seed-angle)
                """
            
                SHAPE = None
                NONZEROS = 0
            
                # ───────── constructor ─────────
                def __init__(self, tensor_id: int):
                    """Initialize CS identity stage.
                    
                    Args:
                        tensor_id: Unique 64-bit identifier for this tensor.
                        
                    Raises:
                        StructuralViolation: If tensor_id is invalid.
                    """
                    # Validate tensor_id immediately
                    if not isinstance(tensor_id, int) or tensor_id < 0:
                        raise StructuralViolation(f"Invalid tensor_id: {tensor_id}")
            
                    # Per-tensor re-entrant lock
                    self.lock = threading.RLock()
            
                    # ══ Identity & Lineage ══
                    self.tensor_id = tensor_id
                    self.parent_id = None
                    self.stage = "CS"
                    self.cycle_index = 0
            
                    # ══ Phase-Tracking (Q29.34 fixed-point) ══
                    # All phase values start at zero in fixed-point representation
                    self.amplitude = self._to_fixed_point(0.0)
                    self.cumulative_phase = self._to_fixed_point(0.0)
                    self.chirality_phase = self._to_fixed_point(0.0)
                    self.last_epsilon = self._to_fixed_point(0.0)
            
                    # ══ Lineage ══
                    self.birth_phase = self._to_fixed_point(0.0)
                    self.creation_cycle = self.cycle_index
            
                    # ══ CS Invariants ══
                    # CS embodies primordial chirality with the unobservable π/2 memory.
                    # Store in fixed-point for consistency with all other phase values.
                    self.left_chirality_seed = self._to_fixed_point(ALPHA)  # π/2 in fixed-point
                    self.degrees_of_freedom = 1
                    
                    # CS has no structural data - this is enforced as an invariant
                    self.indptr = None
                    self.indices = None
                    self.data = None
            
                    # ══ Genetic Memory Interface ══
                    # Delegate trace recording to the proper G1 infrastructure
                    self.genetic_memory = GeneticMemory()
            
                    # ══ Validation & Checksumming ══
                    self.state_checksum = self._compute_checksum()
                    
                    # Record creation event via genetic memory
                    self._record_to_trace("cs_identity_created", 
                                          tensor_id=self.tensor_id,
                                          chirality_seed=self._from_fixed_point(self.left_chirality_seed),
                                          degrees_of_freedom=self.degrees_of_freedom,
                                          checksum=self.state_checksum)
            
                # ─────────────────────── helper: fixed-point ────────────────────────
                @staticmethod
                def _to_fixed_point(value: float) -> int:
                    """Convert float to Q29.34 fixed-point representation.
                    
                    29 bits for integer part, 34 bits for fractional part.
                    This provides sufficient precision for phase calculations.
                    
                    Args:
                        value: Float value to convert
                        
                    Returns:
                        Fixed-point integer representation
                    """
                    return int(value * (2**34))
            
                @staticmethod
                def _from_fixed_point(fx: int) -> float:
                    """Convert Q29.34 fixed-point back to float.
                    
                    Args:
                        fx: Fixed-point integer value
                        
                    Returns:
                        Float representation
                    """
                    return fx / (2**34)
            
                # ─────────────────────── validation & checksum ──────────────────────
                def _compute_checksum(self) -> str:
                    """Compute SHA-256 checksum of CS state.
                    
                    Note: CSR fields are intentionally omitted as they MUST be None in CS.
                    This makes the checksum specific to CS and prevents bugs from
                    accidentally non-None CSR values.
                    
                    Returns:
                        Hexadecimal SHA-256 checksum string
                    """
                    h = hashlib.sha256()
                    
                    # Add core identity and phase state
                    for item in (
                        self.tensor_id, 
                        self.stage, 
                        self.amplitude, 
                        self.cumulative_phase, 
                        self.chirality_phase,
                        self.cycle_index,
                        self.left_chirality_seed,
                        self.degrees_of_freedom
                    ):
                        h.update(str(item).encode())
                    
                    return h.hexdigest()
            
                def validate_identity(self) -> None:
                    """Validate CS constraints and invariants.
                    
                    Enforces all CS-specific structural requirements:
                    - Stage must be "CS"
                    - No CSR arrays allowed
                    - Chirality seed must be exactly π/2
                    - State checksum must be valid
                    
                    Raises:
                        StructuralViolation: If any constraint is violated
                    """
                    # Stage validation
                    if self.stage != "CS":
                        raise StructuralViolation(f"Invalid stage for CS: {self.stage}")
                    
                    # CSR arrays must be None
                    if any(csr_field is not None for csr_field in [self.indptr, self.indices, self.data]):
                        raise StructuralViolation("CS stage cannot have CSR arrays")
                    
                    # Chirality seed validation (compare in fixed-point)
                    alpha_fixed = self._to_fixed_point(ALPHA)
                    if self.left_chirality_seed != alpha_fixed:
                        raise StructuralViolation(
                            f"CS chirality must be α = π/2, got {self._from_fixed_point(self.left_chirality_seed)}"
                        )
                    
                    # Degrees of freedom validation
                    if self.degrees_of_freedom != 1:
                        raise StructuralViolation(f"CS must have exactly 1 degree of freedom, got {self.degrees_of_freedom}")
                        
                    # Checksum validation
                    current_checksum = self._compute_checksum()
                    if current_checksum != self.state_checksum:
                        raise StructuralViolation(f"CS state checksum mismatch: {current_checksum} != {self.state_checksum}")
            
                # ─────────────────── transaction management ─────────────────────
                @contextmanager
                def tensor_transaction(self):
                    """Context manager for transactional tensor operations.
                    
                    Provides rollback capability for failed operations by creating
                    a complete snapshot of the tensor state before the operation
                    and restoring it if an exception occurs.
                    
                    This is a synchronous context manager as CS operations are
                    purely computational without I/O or async operations.
                    
                    Yields:
                        None - the context for the transaction
                        
                    Raises:
                        Any exception from the wrapped operation, after rollback
                    """
                    if not config.enable_transactions:
                        yield
                        return
                    
                    # Create a deep snapshot of all mutable state
                    snapshot = {
                        "tensor_id": self.tensor_id,
                        "parent_id": self.parent_id,
                        "stage": self.stage,
                        "cycle_index": self.cycle_index,
                        "amplitude": self.amplitude,
                        "cumulative_phase": self.cumulative_phase,
                        "chirality_phase": self.chirality_phase,
                        "last_epsilon": self.last_epsilon,
                        "birth_phase": self.birth_phase,
                        "creation_cycle": self.creation_cycle,
                        "left_chirality_seed": self.left_chirality_seed,
                        "degrees_of_freedom": self.degrees_of_freedom,
                        "state_checksum": self.state_checksum,
                        # CSR arrays are None but included for completeness
                        "indptr": self.indptr,
                        "indices": self.indices,
                        "data": self.data
                    }
                    
                    self._record_to_trace("tensor_transaction_start", cycle_index=self.cycle_index)
                    
                    try:
                        yield
                        self._record_to_trace("tensor_transaction_end", cycle_index=self.cycle_index)
                    except Exception:
                        # Restore snapshot on failure
                        for key, value in snapshot.items():
                            setattr(self, key, value)
                        self._record_to_trace("tensor_transaction_abort", cycle_index=self.cycle_index)
                        raise
            
                # ─────────────────── transition payload builder ─────────────────────
                def prepare_transition(self) -> Dict[str, Any]:
                    """Prepare state for transition to UNA stage.
                    
                    The left inverse operation will generate the first observable structure.
                    This method validates the current state and packages all necessary
                    information for the UNA stage constructor.
                    
                    Returns:
                        Dictionary containing all state needed for UNA initialization
                        
                    Raises:
                        StructuralViolation: If CS state is invalid for transition
                    """
                    with self.lock, stage_transition_lock:
                        # Validate current state before transition
                        self.validate_identity()
                        
                        # Update cycle index for transition
                        self.cycle_index += 1
                        
                        # Package state for UNA stage
                        state = {
                            # Core identity
                            "tensor_id": self.tensor_id,
                            "parent_id": self.parent_id,
                            "cycle_index": self.cycle_index,
                            
                            # Phase tracking (all in fixed-point)
                            "amplitude": self.amplitude,
                            "cumulative_phase": self.cumulative_phase,
                            "chirality_phase": self.chirality_phase,
                            "last_epsilon": self.last_epsilon,
                            
                            # Lineage information
                            "birth_phase": self.birth_phase,
                            "creation_cycle": self.creation_cycle,
                            
                            # CS memory carried forward (π/2 chirality seed in fixed-point)
                            "cs_memory": self.left_chirality_seed,
                            
                            # Structural information
                            "degrees_of_freedom": self.degrees_of_freedom,
                            
                            # Schema versioning
                            "schema_version": SCHEMA_VERSION
                        }
                        
                        # Update checksum after preparing transition
                        self.state_checksum = self._compute_checksum()
                        
                        # Record transition preparation via genetic memory
                        self._record_to_trace("cs_transition_prepared",
                                              target_stage="UNA",
                                              cycle_index=state["cycle_index"],
                                              cs_memory=self._from_fixed_point(state["cs_memory"]),
                                              checksum=self.state_checksum)
                        
                        return state
            
                # ───────────────────────── trace helper ─────────────────────────────
                def _record_to_trace(self, event_type: str, **kw):
                    """Record events via the genetic memory system.
                    
                    Delegates to the proper G1 infrastructure for trace recording,
                    which will handle buffer management, retention policy, and
                    coordination with G5 for audit collection.
                    
                    Args:
                        event_type: Type of event being recorded
                        **kw: Additional event data
                    """
                    evt = {
                        "timestamp": time.time(),
                        "source": "G1_CS",
                        "event_type": event_type,
                        "tensor_id": self.tensor_id,
                        "cycle_index": self.cycle_index,
                        "stage": self.stage,
                        **kw
                    }
                    
                    # Log to console/file via standard logging
                    logger.debug("CS Event: %s", evt)
                    
                    # Delegate to genetic memory for proper trace recording
                    self.genetic_memory.record_event(evt)
            
                # ───────────────────────── utility methods ─────────────────────────────
                def get_chirality_seed(self) -> float:
                    """Get the fundamental chirality seed value.
                    
                    Returns:
                        The π/2 chirality seed that defines the unobservable memory
                    """
                    return self._from_fixed_point(self.left_chirality_seed)
            
                def is_spawn_eligible(self) -> bool:
                    """Check if tensor is eligible for spawning.
                    
                    CS stage is never directly spawn-eligible as it has no amplitude.
                    Spawning occurs at BU_En stage after completing the full cycle.
                    
                    Returns:
                        Always False for CS stage
                    """
                    return False
            
                def get_phase_info(self) -> Dict[str, float]:
                    """Get current phase information in human-readable format.
                    
                    Returns:
                        Dictionary with phase values converted to floats
                    """
                    return {
                        "amplitude": self._from_fixed_point(self.amplitude),
                        "cumulative_phase": self._from_fixed_point(self.cumulative_phase),
                        "chirality_phase": self._from_fixed_point(self.chirality_phase),
                        "last_epsilon": self._from_fixed_point(self.last_epsilon)
                    }
            
                def __repr__(self) -> str:
                    """String representation of CS identity."""
                    return (f"CSIdentity(tensor_id={self.tensor_id}, "
                            f"cycle={self.cycle_index}, "
                            f"chirality_seed={self.get_chirality_seed():.6f})")
            
                def __str__(self) -> str:
                    """Human-readable string representation."""
                    return f"CS Identity τ{self.tensor_id} (cycle {self.cycle_index})"
            ```
            
        - `gyro_si/g1_gyroalignment/una/g2_governance.py`
            
            ```python
            """
            G1 UNA Stage: Unity Non-Absolute
            
            UNA creates the first observable structure through the left inverse operation.
            The exact pattern is [[-1, 1], [-1, 1], [-1, 1]] — no variation allowed.
            Three rotational degrees of freedom emerge through position alone.
            """
            
            # ───────────────────── imports & shared infrastructure ──────────────────
            import numpy as np
            import logging
            import time
            import hashlib
            import threading
            import os
            from typing import Dict, Any
            from contextlib import contextmanager
            from scipy.sparse import csr_matrix
            
            from gyro_si.gyro_constants import BETA, M_P
            from gyro_si.gyro_errors import StructuralViolation, QuantizationDefect
            from gyro_si.gyro_gcr.gyro_config import config
            
            # Import proper G1 infrastructure
            from gyro_si.g1_gyroalignment.genetic_memory import GeneticMemory
            from gyro_si.g1_gyroalignment.cs.g1_governance import stage_transition_lock
            
            logger = logging.getLogger(__name__)
            
            SCHEMA_VERSION = "v1"
            TEMPLATE_PATH = os.path.join("patterns", "gyro_g1", SCHEMA_VERSION)
            
            # ─────────────────────────── class definition ───────────────────────────
            
            class UNANormalization:
                """Manages the UNA stage with a fixed 3×2 structure.
            
                Three rotational degrees of freedom emerge through position alone. All values
                are a uniform [-1, 1] representing maximal left bias. The structure is
                immutable and validated against a canonical template.
                """
            
                SHAPE = (3, 2)
                NONZEROS = 6
                CANONICAL_PATTERN = np.array([[-1, 1], [-1, 1], [-1, 1]], dtype=np.int8)
            
                # ───────── constructor ─────────
                def __init__(self, state: Dict[str, Any]):
                    """Initialize UNA from the state provided by the CS stage.
            
                    Args:
                        state: State dictionary from CS stage containing all necessary
                               initialization data including tensor identity, phase tracking,
                               and the CS memory (π/2 chirality seed).
                    """
            
                    # Per-tensor re-entrant lock
                    self.lock = threading.RLock()
            
                    # ══ Identity & Lineage ══
                    self.tensor_id = state["tensor_id"]
                    self.parent_id = state.get("parent_id")
                    self.stage = "UNA"
                    self.cycle_index = state["cycle_index"]
            
                    # ══ Phase-Tracking (Q29.34 fixed-point) ══
                    self.amplitude = state["amplitude"]
                    self.cumulative_phase = state["cumulative_phase"]
                    self.chirality_phase = state["chirality_phase"]
                    self.last_epsilon = state["last_epsilon"]
            
                    # ══ Lineage ══
                    self.birth_phase = state["birth_phase"]
                    self.creation_cycle = state["creation_cycle"]
            
                    # ══ Stage-specific state ══
                    self.cs_memory = state["cs_memory"]  # π/2 chirality seed in fixed-point
                    self.degrees_of_freedom = 3
                    self.threshold_angle = self._to_fixed_point(BETA)  # π/4 in fixed-point
                    self.threshold_ratio = self._to_fixed_point(1.0 / np.sqrt(2))  # cos(π/4)
                    self.schema_version = state.get("schema_version", SCHEMA_VERSION)
            
                    # ══ Genetic Memory Interface ══
                    self.genetic_memory = GeneticMemory()
            
                    # ══ Build CSR structure ══
                    self._initialize_csr()
            
                    # ══ Validation ══
                    self.state_checksum = self._compute_checksum()
                    self._validate_against_template()
                    self._validate_structure()
            
                    self._record_to_trace("una_initialized",
                                          shape=self.SHAPE,
                                          nonzeros=self.NONZEROS,
                                          threshold_angle=self._from_fixed_point(self.threshold_angle),
                                          degrees_of_freedom=self.degrees_of_freedom,
                                          checksum=self.state_checksum)
            
                # ─────────────────────── helper: fixed-point ────────────────────────
                @staticmethod
                def _to_fixed_point(value: float) -> int:
                    """Convert float to Q29.34 fixed-point representation."""
                    return int(value * (2**34))
            
                @staticmethod
                def _from_fixed_point(fx: int) -> float:
                    """Convert Q29.34 fixed-point back to float."""
                    return fx / (2**34)
            
                # ─────────────────────── CSR construction ───────────────────────────
                def _initialize_csr(self) -> None:
                    """Build the stage-specific CSR representation from the canonical pattern.
            
                    Creates the exact UNA pattern [[-1,1], [-1,1], [-1,1]] with proper
                    CSR encoding and optional GPU mirroring for validation.
                    """
                    # Use the exact canonical pattern - no variations allowed
                    dense = np.array(self.CANONICAL_PATTERN, dtype=np.int8)
            
                    # Verify it matches the expected pattern exactly
                    expected = np.array([[-1, 1], [-1, 1], [-1, 1]], dtype=np.int8)
                    if not np.array_equal(dense, expected):
                        raise StructuralViolation("UNA pattern deviation from canonical form")
            
                    # Convert to CSR with SIMD alignment
                    csr = csr_matrix(dense)
            
                    self.indptr = csr.indptr.tolist()
                    self.indices = csr.indices.tolist()
            
                    # Encode data as uint2: 01→+1, 11→-1 (no zeros allowed in UNA)
                    self.data = []
                    for val in csr.data:
                        if val == 1:
                            self.data.append(0b01)
                        elif val == -1:
                            self.data.append(0b11)
                        else:
                            raise StructuralViolation(f"UNA cannot contain value {val}")
            
                    # Mirror to GPU if available for SIMD alignment checks
                    try:
                        import cupy as cp
                        self.gpu_indptr = cp.array(self.indptr)
                        self.gpu_indices = cp.array(self.indices)
                        self.gpu_data = cp.array(self.data)
                        self.gpu_available = True
                    except (ImportError, ModuleNotFoundError):
                        self.gpu_available = False
            
                # ─────────────────────── validation & checksum ──────────────────────
                def _compute_checksum(self) -> str:
                    """Compute SHA-256 checksum over complete tensor state.
            
                    Returns:
                        Hexadecimal SHA-256 checksum string
                    """
                    h = hashlib.sha256()
                    for item in (
                        self.tensor_id, self.stage, self.indptr, self.indices, self.data,
                        self.amplitude, self.cumulative_phase, self.chirality_phase
                    ):
                        h.update(str(item).encode())
                    return h.hexdigest()
            
                def _validate_against_template(self) -> None:
                    """Validate structure against canonical template for current schema version.
            
                    Performs byte-for-byte comparison against the versioned template file.
            
                    Raises:
                        StructuralViolation: If structure deviates from canonical template
                    """
                    tpl_file = os.path.join(TEMPLATE_PATH, "una_template.npy")
                    if not os.path.exists(tpl_file):
                        logger.warning("Template %s missing; skipping validation.", tpl_file)
                        return
            
                    tpl = np.load(tpl_file)
                    tpl_csr = csr_matrix(tpl)
                    tpl_data = [0b01 if v == 1 else 0b11 for v in tpl_csr.data]
            
                    if [self.indptr, self.indices, self.data] != [tpl_csr.indptr.tolist(), tpl_csr.indices.tolist(), tpl_data]:
                        raise StructuralViolation(f"{self.stage} deviates from canonical template")
            
                def _validate_structure(self) -> None:
                    """Run all structural invariants for the UNA stage.
            
                    Validates:
                    - Correct number of non-zeros
                    - Proper CSR dimensions
                    - Exact canonical pattern
                    - CPU/GPU consistency if available
            
                    Raises:
                        StructuralViolation: If any structural constraint is violated
                        QuantizationDefect: If CPU/GPU copies don't match
                    """
                    # Check non-zero count
                    if len(self.data) != self.NONZEROS:
                        raise StructuralViolation(f"{self.stage} expects {self.NONZEROS} non-zeros, found {len(self.data)}")
            
                    # Check CSR dimensions
                    if len(self.indptr) != self.SHAPE[0] + 1:
                        raise StructuralViolation(f"Invalid indptr length for shape {self.SHAPE}")
            
                    # Verify all values are in {-1, 1} - no zeros allowed
                    for encoded in self.data:
                        if encoded not in [0b01, 0b11]:
                            raise StructuralViolation(f"UNA values must be exactly {{-1, 1}}, got encoding {encoded:02b}")
            
                    # Verify the exact canonical pattern
                    self._verify_exact_pattern()
            
                    # If GPU is available, verify CPU and GPU copies match
                    if self.gpu_available:
                        try:
                            import cupy as cp
                            if (not np.array_equal(self.indptr, cp.asnumpy(self.gpu_indptr)) or
                                not np.array_equal(self.indices, cp.asnumpy(self.gpu_indices)) or
                                not np.array_equal(self.data, cp.asnumpy(self.gpu_data))):
                                raise QuantizationDefect("CPU and GPU tensor copies do not match in UNA stage")
                        except Exception as e:
                            raise QuantizationDefect(f"GPU validation failed in UNA stage: {e}")
            
                def _verify_exact_pattern(self) -> None:
                    """Verify tensor has EXACTLY the canonical UNA pattern.
            
                    Reconstructs the dense array and compares against the expected
                    [[-1,1], [-1,1], [-1,1]] pattern with no tolerance for variation.
            
                    Raises:
                        StructuralViolation: If pattern doesn't match exactly
                    """
                    # Reconstruct dense array from CSR
                    values = []
                    for encoded in self.data:
                        if encoded == 0b01:
                            values.append(1)
                        elif encoded == 0b11:
                            values.append(-1)
            
                    csr = csr_matrix((values, self.indices, self.indptr), shape=self.SHAPE)
                    dense = csr.toarray()
            
                    # Check EXACT pattern - no variations allowed
                    expected = np.array([[-1, 1], [-1, 1], [-1, 1]], dtype=np.int8)
                    if not np.array_equal(dense, expected):
                        raise StructuralViolation("UNA pattern must be EXACTLY [[-1,1], [-1,1], [-1,1]]")
            
                # ───────────────────── phase / processing hooks ─────────────────────
                def process_phase(self, phi: float) -> float:
                    """Process input phase, updating trackers using fixed-point arithmetic.
            
                    Note: The tensor structure NEVER changes. Only phase tracking occurs.
            
                    Args:
                        phi: Input phase value to process
            
                    Returns:
                        Quantization error epsilon as float
                    """
                    with self.lock:
                        # Convert to fixed-point
                        phi_fx = self._to_fixed_point(phi)
            
                        # Quantize using fixed-point arithmetic
                        phi_q_fx = self._quantize_fixed(phi_fx)
                        eps_fx = phi_fx - phi_q_fx
            
                        # Update amplitude with clipping
                        m_p_fx = self._to_fixed_point(M_P)
                        neg_m_p_fx = self._to_fixed_point(-M_P)
                        self.amplitude = max(neg_m_p_fx, min(self.amplitude + phi_q_fx, m_p_fx))
            
                        # Update phase tracking
                        abs_phi_q_fx = abs(phi_q_fx)
                        four_pi_fx = self._to_fixed_point(4 * np.pi)
                        two_pi_fx = self._to_fixed_point(2 * np.pi)
            
                        self.cumulative_phase = (self.cumulative_phase + abs_phi_q_fx) % four_pi_fx
                        self.chirality_phase = self.cumulative_phase % two_pi_fx
                        self.last_epsilon = eps_fx
            
                        # Check for exact 2π boundary and collapse segment if necessary
                        if self.cumulative_phase % two_pi_fx == 0:
                            self._collapse_segment_to_digest()
            
                        # Update checksum after state change
                        self.state_checksum = self._compute_checksum()
            
                        # Record processing event
                        self._record_to_trace("phase_processed",
                                              phi=phi,
                                              phi_q=self._from_fixed_point(phi_q_fx),
                                              epsilon=self._from_fixed_point(eps_fx),
                                              amplitude=self._from_fixed_point(self.amplitude),
                                              cumulative_phase=self._from_fixed_point(self.cumulative_phase),
                                              checksum=self.state_checksum)
            
                        return self._from_fixed_point(eps_fx)
            
                def _quantize_fixed(self, phi_fx: int) -> int:
                    """Quantize fixed-point phase to discrete values.
            
                    Args:
                        phi_fx: Phase value in Q29.34 fixed-point format
            
                    Returns:
                        Quantized phase in fixed-point format
                    """
                    m_p_fx = self._to_fixed_point(M_P)
                    half_m_p_fx = m_p_fx // 2
                    neg_m_p_fx = self._to_fixed_point(-M_P)
                    neg_half_m_p_fx = neg_m_p_fx // 2
            
                    if phi_fx < neg_half_m_p_fx:
                        return neg_m_p_fx
                    elif phi_fx >= half_m_p_fx:
                        return m_p_fx
                    else:
                        return 0
            
                @staticmethod
                def quantize(phi, m_p):
                    """Vectorized quantization for batch processing.
            
                    Can be used with numpy or cupy arrays for bulk operations.
            
                    Args:
                        phi: Phase array (numpy or cupy)
                        m_p: Quantization parameter
            
                    Returns:
                        Quantized phase array
                    """
                    xp = np
                    try:
                        import cupy
                        if isinstance(phi, cupy.ndarray):
                            xp = cupy
                    except ImportError:
                        pass
                    return xp.where(phi < -m_p/2, -m_p, xp.where(phi >= m_p/2, m_p, 0))
            
                def _collapse_segment_to_digest(self) -> None:
                    """Record a digest of the tensor state at exact 2π boundaries.
                    
                    This implements the pruning assertion from the specification:
                    every tensor snapshot at cumulative_phase % 2π == 0 must carry
                    a pruned_digest flag for G5 audit validation.
                    """
                    digest = {
                        "tensor_id": self.tensor_id,
                        "cycle_index": self.cycle_index,
                        "cumulative_phase": self._from_fixed_point(self.cumulative_phase),
                        "amplitude": self._from_fixed_point(self.amplitude),
                        "pruned_digest": True  # Required for G5 audit validation
                    }
                    
                    self._record_to_trace("segment_collapsed", 
                                          cumulative_phase=self._from_fixed_point(self.cumulative_phase),
                                          digest=digest)
            
                # ─────────────────── transition management ─────────────────────
                @contextmanager
                def tensor_transaction(self):
                    """Context manager for transactional tensor operations.
                    
                    Provides rollback capability for failed operations by creating
                    a complete snapshot of the tensor state before the operation
                    and restoring it if an exception occurs.
                    
                    Yields:
                        None - the context for the transaction
                        
                    Raises:
                        Any exception from the wrapped operation, after rollback
                    """
                    if not config.enable_transactions:
                        yield
                        return
                        
                    # Create deep snapshot of all mutable state
                    snapshot = {
                        "tensor_id": self.tensor_id,
                        "parent_id": self.parent_id,
                        "stage": self.stage,
                        "cycle_index": self.cycle_index,
                        "amplitude": self.amplitude,
                        "cumulative_phase": self.cumulative_phase,
                        "chirality_phase": self.chirality_phase,
                        "last_epsilon": self.last_epsilon,
                        "birth_phase": self.birth_phase,
                        "creation_cycle": self.creation_cycle,
                        "cs_memory": self.cs_memory,
                        "degrees_of_freedom": self.degrees_of_freedom,
                        "threshold_angle": self.threshold_angle,
                        "threshold_ratio": self.threshold_ratio,
                        "schema_version": self.schema_version,
                        "state_checksum": self.state_checksum,
                        # CSR arrays (deep copy for lists)
                        "indptr": self.indptr.copy() if self.indptr else None,
                        "indices": self.indices.copy() if self.indices else None,
                        "data": self.data.copy() if self.data else None
                    }
                    
                    self._record_to_trace("tensor_transaction_start", cycle_index=self.cycle_index)
                    
                    try:
                        yield
                        self._record_to_trace("tensor_transaction_end", cycle_index=self.cycle_index)
                    except Exception:
                        # Restore snapshot on failure
                        for key, value in snapshot.items():
                            setattr(self, key, value)
                        self._record_to_trace("tensor_transaction_abort", cycle_index=self.cycle_index)
                        raise
            
                def prepare_transition(self) -> Dict[str, Any]:
                    """Prepare state for transition to ONA stage.
                    
                    ONA will create anti-correlation through exact sign inversion of the UNA pattern.
                    This method validates the current state and packages all necessary information
                    for the ONA stage constructor.
                    
                    Returns:
                        Dictionary containing all state needed for ONA initialization
                        
                    Raises:
                        StructuralViolation: If UNA state is invalid for transition
                    """
                    with self.lock, stage_transition_lock:
                        # Validate structure before transition
                        self._validate_structure()
                        
                        # Update cycle index for transition
                        self.cycle_index += 1
                        
                        # Update checksum after cycle increment
                        self.state_checksum = self._compute_checksum()
            
                        # Package state for ONA stage
                        payload = {
                            # Core identity
                            "tensor_id": self.tensor_id,
                            "parent_id": self.parent_id,
                            "cycle_index": self.cycle_index,
                            
                            # Phase tracking (all in fixed-point)
                            "amplitude": self.amplitude,
                            "cumulative_phase": self.cumulative_phase,
                            "chirality_phase": self.chirality_phase,
                            "last_epsilon": self.last_epsilon,
                            
                            # Lineage information
                            "birth_phase": self.birth_phase,
                            "creation_cycle": self.creation_cycle,
                            
                            # CS memory carried forward
                            "cs_memory": self.cs_memory,
                            
                            # UNA structure for ONA to use
                            "una_indptr": self.indptr.copy(),
                            "una_indices": self.indices.copy(),
                            "una_data": self.data.copy(),
                            
                            # Accumulated thresholds (β from UNA)
                            "accumulated_threshold": self.threshold_angle,
                            
                            # Schema versioning
                            "schema_version": self.schema_version,
                        }
            
                        # Record transition preparation
                        self._record_to_trace("una_transition_prepared",
                                              target_stage="ONA",
                                              cycle_index=payload["cycle_index"],
                                              accumulated_threshold=self._from_fixed_point(self.threshold_angle),
                                              checksum=self.state_checksum)
                        
                        return payload
            
                # ───────────────────────── trace helper ─────────────────────────────
                def _record_to_trace(self, event_type: str, **kw):
                    """Record events via the genetic memory system.
                    
                    Delegates to the proper G1 infrastructure for trace recording,
                    which will handle buffer management, retention policy, and
                    coordination with G5 for audit collection.
                    
                    Args:
                        event_type: Type of event being recorded
                        **kw: Additional event data
                    """
                    evt = {
                        "timestamp": time.time(),
                        "source": "G1_UNA",
                        "event_type": event_type,
                        "tensor_id": self.tensor_id,
                        "cycle_index": self.cycle_index,
                        "stage": self.stage,
                        **kw
                    }
                    
                    # Log to console/file via standard logging
                    logger.debug("UNA Event: %s", evt)
                    
                    # Delegate to genetic memory for proper trace recording
                    self.genetic_memory.record_event(evt)
            
                # ───────────────────────── utility methods ─────────────────────────────
                def get_threshold_info(self) -> Dict[str, float]:
                    """Get threshold information in human-readable format.
                    
                    Returns:
                        Dictionary with threshold values converted to floats
                    """
                    return {
                        "threshold_angle": self._from_fixed_point(self.threshold_angle),
                        "threshold_ratio": self._from_fixed_point(self.threshold_ratio),
                        "accumulated_threshold": self._from_fixed_point(self.threshold_angle)
                    }
            
                def get_phase_info(self) -> Dict[str, float]:
                    """Get current phase information in human-readable format.
                    
                    Returns:
                        Dictionary with phase values converted to floats
                    """
                    return {
                        "amplitude": self._from_fixed_point(self.amplitude),
                        "cumulative_phase": self._from_fixed_point(self.cumulative_phase),
                        "chirality_phase": self._from_fixed_point(self.chirality_phase),
                        "last_epsilon": self._from_fixed_point(self.last_epsilon)
                    }
            
                def get_structure_info(self) -> Dict[str, Any]:
                    """Get structural information about the tensor.
                    
                    Returns:
                        Dictionary with tensor structure details
                    """
                    return {
                        "shape": self.SHAPE,
                        "nonzeros": self.NONZEROS,
                        "degrees_of_freedom": self.degrees_of_freedom,
                        "gpu_available": self.gpu_available,
                        "checksum": self.state_checksum
                    }
            
                def is_spawn_eligible(self) -> bool:
                    """Check if tensor is eligible for spawning.
                    
                    UNA stage is not directly spawn-eligible. Spawning occurs at BU_En
                    stage after completing the full cycle and reaching 4π.
                    
                    Returns:
                        Always False for UNA stage
                    """
                    return False
            
                def __repr__(self) -> str:
                    """String representation of UNA normalization."""
                    return (f"UNANormalization(tensor_id={self.tensor_id}, "
                            f"cycle={self.cycle_index}, "
                            f"amplitude={self._from_fixed_point(self.amplitude):.6f})")
            
                def __str__(self) -> str:
                    """Human-readable string representation."""
                    return f"UNA Normalization τ{self.tensor_id} (cycle {self.cycle_index})"
            ```
            
        - `gyro_si/g1_gyroalignment/ona/g3_governance.py`
            
            ```python
            """
            G1 ONA Stage: Observation Non-Absolute
            
            ONA creates anti-correlation through exact sign inversion of the UNA pattern.
            The structure becomes 2×3×2 with 12 non-zeros, representing the first emergence
            of observational structure through anti-correlated block extension.
            
            This is where the tensor gains its first capacity for observation through
            the anti-correlation mechanism that will later enable quantization at BU.
            """
            
            # ───────────────────── imports & shared infrastructure ──────────────────
            import numpy as np
            import logging
            import time
            import hashlib
            import threading
            import os
            import math
            import asyncio
            from typing import Dict, Any, Optional
            from contextlib import contextmanager
            from scipy.sparse import csr_matrix
            
            from gyro_si.gyro_constants import GAMMA, M_P
            from gyro_si.gyro_errors import StructuralViolation, QuantizationDefect
            from gyro_si.gyro_gcr.gyro_config import config
            
            # Import proper G1 infrastructure
            from gyro_si.g1_gyroalignment.genetic_memory import GeneticMemory
            from gyro_si.g1_gyroalignment.cs.g1_governance import stage_transition_lock
            
            logger = logging.getLogger(__name__)
            
            SCHEMA_VERSION = "v1"
            TEMPLATE_PATH = os.path.join("patterns", "gyro_g1", SCHEMA_VERSION)
            
            # ─────────────────────────── class definition ───────────────────────────
            
            class ONAObservation:
                """Manages the ONA stage with anti-correlated 2×3×2 structure.
            
                Creates observational capacity through exact sign inversion of the UNA pattern.
                The anti-correlation mechanism enables the quantization that will emerge at BU_In.
                Six rotational degrees of freedom emerge through the extended structure.
                """
            
                SHAPE = (2, 3, 2)
                NONZEROS = 12  # 2×3×2 = 12 entries, all non-zero
                # ONA pattern is computed from UNA inversion, not stored as canonical pattern
                CANONICAL_PATTERN = None
            
                # ───────── constructor ─────────
                def __init__(self, state: Dict[str, Any]):
                    """Initialize ONA from the state provided by the UNA stage.
            
                    Args:
                        state: State dictionary from UNA stage containing all necessary
                               initialization data including the UNA structure to invert.
                    """
            
                    # Per-tensor re-entrant lock
                    self.lock = threading.RLock()
            
                    # ══ Identity & Lineage ══
                    self.tensor_id = state["tensor_id"]
                    self.parent_id = state.get("parent_id")
                    self.stage = "ONA"
                    self.cycle_index = state["cycle_index"]
            
                    # ══ Phase-Tracking (Q29.34 fixed-point) ══
                    self.amplitude = state["amplitude"]
                    self.cumulative_phase = state["cumulative_phase"]
                    self.chirality_phase = state["chirality_phase"]
                    self.last_epsilon = state["last_epsilon"]
            
                    # ══ Lineage ══
                    self.birth_phase = state["birth_phase"]
                    self.creation_cycle = state["creation_cycle"]
            
                    # ══ Stage-specific state ══
                    self.cs_memory = state["cs_memory"]  # π/2 chirality seed in fixed-point
                    self.accumulated_threshold = state["accumulated_threshold"]  # β from UNA
                    self.degrees_of_freedom = 6
                    self.threshold_angle = self._to_fixed_point(GAMMA)  # GAMMA (π/4) in fixed-point
                    self.schema_version = state.get("schema_version", SCHEMA_VERSION)
                    
                    # ══ Spinor cycle tracking ══
                    self.spinor_cycle_count = state.get("spinor_cycle_count", 0)
            
                    # ══ UNA structure for anti-correlation ══
                    self.una_indptr = state["una_indptr"]
                    self.una_indices = state["una_indices"]
                    self.una_data = state["una_data"]
            
                    # ══ Genetic Memory Interface ══
                    self.genetic_memory = GeneticMemory()
            
                    # ══ Build CSR structure through anti-correlation ══
                    self._initialize_csr()
            
                    # ══ Validation ══
                    self.state_checksum = self._compute_checksum()
                    self._validate_against_template()
                    self._validate_structure()
                    self._validate_fixed_point_range()
            
                    self._record_to_trace("ona_initialized",
                                          shape=self.SHAPE,
                                          nonzeros=self.NONZEROS,
                                          threshold_angle=self._from_fixed_point(self.threshold_angle),
                                          degrees_of_freedom=self.degrees_of_freedom,
                                          checksum=self.state_checksum)
            
                # ─────────────────────── helper: fixed-point ────────────────────────
                @staticmethod
                def _to_fixed_point(value: float) -> int:
                    """Convert float to Q29.34 fixed-point representation."""
                    return int(value * (2**34))
            
                @staticmethod
                def _from_fixed_point(fx: int) -> float:
                    """Convert Q29.34 fixed-point back to float."""
                    return fx / (2**34)
            
                # ─────────────────────── CSR construction ───────────────────────────
                def _initialize_csr(self) -> None:
                    """Build the ONA structure through anti-correlated block extension.
            
                    Creates the 2×3×2 structure by:
                    1. Reconstructing the UNA pattern from CSR
                    2. Creating anti-correlated blocks through sign inversion
                    3. Flattening 3D→2D for CSR representation
                    """
                    # Reconstruct UNA pattern from CSR
                    una_values = []
                    for encoded in self.una_data:
                        if encoded == 0b01:
                            una_values.append(1)
                        elif encoded == 0b11:
                            una_values.append(-1)
                        else:
                            raise StructuralViolation(f"Invalid UNA encoding: {encoded:02b}")
            
                    una_csr = csr_matrix((una_values, self.una_indices, self.una_indptr), shape=(3, 2))
                    una_dense = una_csr.toarray()
            
                    # Create anti-correlated blocks through exact sign inversion
                    # Block 1: Original UNA pattern [[-1,1], [-1,1], [-1,1]]
                    # Block 2: Anti-correlated (sign-inverted) pattern [[1,-1], [1,-1], [1,-1]]
                    block1 = una_dense
                    block2 = -una_dense
            
                    # Create 2×3×2 structure by stacking the blocks
                    # Shape interpretation: (block, row, col)
                    ona_3d = np.stack([block1, block2], axis=0)  # Shape: (2, 3, 2)
            
                    # Flatten to 2D for CSR representation: (2*3, 2) = (6, 2)
                    # This preserves the block structure while creating a valid CSR matrix
                    ona_2d = ona_3d.reshape(6, 2)
            
                    # Convert to CSR with SIMD alignment
                    csr = csr_matrix(ona_2d)
            
                    self.indptr = csr.indptr.tolist()
                    self.indices = csr.indices.tolist()
            
                    # Encode data as uint2: 01→+1, 11→-1 (no zeros in ONA)
                    self.data = []
                    for val in csr.data:
                        if val == 1:
                            self.data.append(0b01)
                        elif val == -1:
                            self.data.append(0b11)
                        else:
                            raise StructuralViolation(f"ONA cannot contain value {val}")
            
                    # Store the 3D shape information for reconstruction
                    self.block_structure = {
                        "shape_3d": (2, 3, 2),
                        "shape_2d": (6, 2),
                        "block1_rows": [0, 1, 2],
                        "block2_rows": [3, 4, 5]
                    }
            
                    # Mirror to GPU if available for SIMD alignment checks
                    self.gpu_available = False
                    self.gpu_indptr = None
                    self.gpu_indices = None
                    self.gpu_data = None
                    
                    try:
                        import cupy as cp
                        self.gpu_indptr = cp.array(self.indptr)
                        self.gpu_indices = cp.array(self.indices)
                        self.gpu_data = cp.array(self.data)
                        self.gpu_available = True
                    except (ImportError, ModuleNotFoundError):
                        pass
            
                # ─────────────────────── validation & checksum ──────────────────────
                def _compute_checksum(self) -> str:
                    """Compute SHA-256 checksum over complete tensor state.
            
                    Returns:
                        Hexadecimal SHA-256 checksum string
                    """
                    h = hashlib.sha256()
                    # Core tensor state (excluding GPU state and spinor_cycle_count for determinism)
                    for item in (
                        self.tensor_id, self.stage,
                        tuple(self.indptr), tuple(self.indices), tuple(self.data),
                        self.amplitude, self.cumulative_phase, self.chirality_phase,
                        tuple(self.block_structure["shape_3d"]),
                        tuple(self.block_structure["shape_2d"]),
                        tuple(self.block_structure["block1_rows"]),
                        tuple(self.block_structure["block2_rows"])
                    ):
                        h.update(str(item).encode())
                    return h.hexdigest()
            
                def _validate_against_template(self) -> None:
                    """Validate structure against canonical template for current schema version.
            
                    Raises:
                        StructuralViolation: If structure deviates from canonical template or template is missing
                    """
                    tpl_file = os.path.join(TEMPLATE_PATH, "ona_template.npy")
                    if not os.path.exists(tpl_file):
                        # In production/CI, missing template should be an error
                        if os.environ.get("CI") or os.environ.get("GYRO_STRICT_VALIDATION"):
                            raise StructuralViolation(f"ONA canonical template missing: {tpl_file}")
                        else:
                            logger.warning("ONA template missing: %s, validating anti-correlation only", tpl_file)
                            self._validate_anti_correlation()
                            return
                    
                    tpl = np.load(tpl_file)
                    tpl_csr = csr_matrix(tpl)
                    tpl_data = [0b01 if v == 1 else 0b11 for v in tpl_csr.data]
            
                    if [self.indptr, self.indices, self.data] != [tpl_csr.indptr.tolist(), tpl_csr.indices.tolist(), tpl_data]:
                        raise StructuralViolation(f"{self.stage} deviates from canonical template")
            
                def _validate_anti_correlation(self) -> None:
                    """Validate that the ONA structure exhibits proper anti-correlation.
            
                    Verifies that Block 2 is exactly the sign inverse of Block 1,
                    maintaining the fundamental anti-correlation property.
            
                    Raises:
                        StructuralViolation: If anti-correlation is violated
                    """
                    # Reconstruct the 2D matrix from CSR
                    values = []
                    for encoded in self.data:
                        if encoded == 0b01:
                            values.append(1)
                        elif encoded == 0b11:
                            values.append(-1)
            
                    csr = csr_matrix((values, self.indices, self.indptr), shape=(6, 2))
                    dense_2d = csr.toarray()
            
                    # Extract blocks
                    block1 = dense_2d[0:3, :]  # First 3 rows
                    block2 = dense_2d[3:6, :]  # Last 3 rows
            
                    # Verify anti-correlation: Block2 = -Block1
                    if not np.array_equal(block2, -block1):
                        raise StructuralViolation("ONA blocks must be anti-correlated (Block2 = -Block1)")
            
                def _validate_structure(self) -> None:
                    """Run all structural invariants for the ONA stage.
            
                    Validates:
                    - Correct number of non-zeros (12)
                    - Proper CSR dimensions
                    - Anti-correlation property
                    - CPU/GPU consistency if available
            
                    Raises:
                        StructuralViolation: If any structural constraint is violated
                        QuantizationDefect: If CPU/GPU copies don't match
                    """
                    # Check non-zero count
                    if len(self.data) != self.NONZEROS:
                        raise StructuralViolation(f"{self.stage} expects {self.NONZEROS} non-zeros, found {len(self.data)}")
            
                    # Check CSR dimensions (flattened 2D representation)
                    expected_2d_shape = (6, 2)
                    if len(self.indptr) != expected_2d_shape[0] + 1:
                        raise StructuralViolation(f"Invalid indptr length for flattened shape {expected_2d_shape}")
            
                    # Verify all values are in {-1, 1} - no zeros allowed
                    for encoded in self.data:
                        if encoded not in [0b01, 0b11]:
                            raise StructuralViolation(f"ONA values must be exactly {{-1, 1}}, got encoding {encoded:02b}")
            
                    # Verify anti-correlation property
                    self._validate_anti_correlation()
            
                    # If GPU is available, verify CPU and GPU copies match
                    if self.gpu_available:
                        try:
                            import cupy as cp
                            cpu_indptr = np.array(self.indptr)
                            cpu_indices = np.array(self.indices)
                            cpu_data = np.array(self.data)
                            
                            if (not np.array_equal(cpu_indptr, cp.asnumpy(self.gpu_indptr)) or
                                not np.array_equal(cpu_indices, cp.asnumpy(self.gpu_indices)) or
                                not np.array_equal(cpu_data, cp.asnumpy(self.gpu_data))):
                                raise QuantizationDefect("CPU and GPU tensor copies do not match in ONA stage")
                        except Exception as e:
                            raise QuantizationDefect(f"GPU validation failed in ONA stage: {e}")
            
                def _validate_fixed_point_range(self) -> None:
                    """Validate that all fixed-point values are within representable range.
                    
                    Q29.34 format: 29 bits for integer part, 34 bits for fractional part.
                    Range: [-(2^29), 2^29) in the integer part.
                    
                    Raises:
                        QuantizationDefect: If any value exceeds representable range
                    """
                    # Maximum representable value in Q29.34
                    # Integer part can be up to 2^29 - 1, but we need to account for fractional part
                    max_int_value = 2**29  # Exclusive upper bound
                    max_representable = max_int_value * (2**34) - 1  # Account for fractional bits
                    min_representable = -(max_int_value * (2**34))
                    
                    values_to_check = [
                        ("amplitude", self.amplitude),
                        ("cumulative_phase", self.cumulative_phase),
                        ("chirality_phase", self.chirality_phase),
                        ("last_epsilon", self.last_epsilon),
                        ("cs_memory", self.cs_memory),
                        ("accumulated_threshold", self.accumulated_threshold),
                        ("threshold_angle", self.threshold_angle)
                    ]
                    
                    for name, value in values_to_check:
                        if not (min_representable <= value <= max_representable):
                            raise QuantizationDefect(
                                f"Fixed-point value {name} = {value} exceeds Q29.34 representable range [{min_representable}, {max_representable}]"
                            )
            
                # ─────────────────────── tensor context helper ──────────────────────
                def _create_tensor_context(self) -> Dict[str, Any]:
                    """Create tensor context for G6 message format compliance.
                    
                    Returns:
                        Dictionary with required tensor context fields
                    """
                    return {
                        "cumulative_phase": self._from_fixed_point(self.cumulative_phase),
                        "chirality_phase": self._from_fixed_point(self.chirality_phase),
                        "helical_position": self._from_fixed_point(self.cumulative_phase) / (4 * math.pi),
                        "spinor_cycle_count": self.spinor_cycle_count
                    }
            
                # ───────────────────── phase / processing hooks ─────────────────────
                def process_phase(self, phi: float) -> float:
                    """Process input phase, updating trackers using fixed-point arithmetic.
            
                    The anti-correlated structure enables enhanced quantization sensitivity
                    that will be fully realized at the BU_In stage.
            
                    Args:
                        phi: Input phase value to process
            
                    Returns:
                        Quantization error epsilon as float
                    """
                    with self.lock:
                        # Convert to fixed-point
                        phi_fx = self._to_fixed_point(phi)
            
                        # Quantize using fixed-point arithmetic with enhanced sensitivity
                        phi_q_fx = self._quantize_fixed(phi_fx)
                        eps_fx = phi_fx - phi_q_fx
            
                        # Update amplitude with clipping
                        m_p_fx = self._to_fixed_point(M_P)
                        neg_m_p_fx = self._to_fixed_point(-M_P)
                        self.amplitude = max(neg_m_p_fx, min(self.amplitude + phi_q_fx, m_p_fx))
            
                        # Update phase tracking - use math.pi consistently
                        abs_phi_q_fx = abs(phi_q_fx)
                        four_pi_fx = self._to_fixed_point(4 * math.pi)
                        two_pi_fx = self._to_fixed_point(2 * math.pi)
            
                        # Store previous phase for boundary detection
                        prev_cumulative_phase = self.cumulative_phase
                        
                        # Update phases
                        self.cumulative_phase = (self.cumulative_phase + abs_phi_q_fx) % four_pi_fx
                        self.chirality_phase = self.cumulative_phase % two_pi_fx
                        self.last_epsilon = eps_fx
            
                        # Check for 4π boundary crossing (spinor cycle completion)
                        if prev_cumulative_phase > self.cumulative_phase:
                            self.spinor_cycle_count += 1
                            
                        # Check for exact 2π boundary and collapse segment if necessary
                        if self.cumulative_phase % two_pi_fx == 0:
                            self._collapse_segment_to_digest()
            
                        # Generate algedonic signal if |ε| > mₚ/2
                        m_p_half_fx = m_p_fx // 2
                        if abs(eps_fx) > m_p_half_fx:
                            # Schedule async algedonic signal
                            try:
                                loop = asyncio.get_event_loop()
                                loop.create_task(self._generate_algedonic_signal_async(eps_fx))
                            except RuntimeError:
                                # No event loop running, log warning
                                logger.warning("Cannot send algedonic signal: no event loop")
            
                        # Update checksum after state change
                        self.state_checksum = self._compute_checksum()
            
                        # Record processing event
                        self._record_to_trace("phase_processed",
                                              phi=phi,
                                              phi_q=self._from_fixed_point(phi_q_fx),
                                              epsilon=self._from_fixed_point(eps_fx),
                                              amplitude=self._from_fixed_point(self.amplitude),
                                              cumulative_phase=self._from_fixed_point(self.cumulative_phase),
                                              anti_correlation_active=True,
                                              checksum=self.state_checksum)
            
                        return self._from_fixed_point(eps_fx)
            
                def _quantize_fixed(self, phi_fx: int) -> int:
                    """Quantize fixed-point phase with anti-correlation sensitivity.
            
                    The anti-correlated structure provides enhanced quantization sensitivity
                    compared to UNA, preparing for the full quantization emergence at BU_In.
            
                    Args:
                        phi_fx: Phase value in Q29.34 fixed-point format
            
                    Returns:
                        Quantized phase in fixed-point format
                    """
                    m_p_fx = self._to_fixed_point(M_P)
                    half_m_p_fx = m_p_fx // 2
                    neg_m_p_fx = self._to_fixed_point(-M_P)
                    neg_half_m_p_fx = neg_m_p_fx // 2
            
                    # Enhanced sensitivity due to anti-correlation
                    # Use GAMMA as sensitivity factor
                    gamma_fx = self.threshold_angle  # GAMMA in fixed-point
                    sensitivity_factor = gamma_fx // 4  # GAMMA/4 for enhanced sensitivity
            
                    # Apply sensitivity adjustment
                    adjusted_half_m_p_fx = half_m_p_fx - sensitivity_factor
                    adjusted_neg_half_m_p_fx = neg_half_m_p_fx + sensitivity_factor
            
                    if phi_fx < adjusted_neg_half_m_p_fx:
                        return neg_m_p_fx
                    elif phi_fx >= adjusted_half_m_p_fx:
                        return m_p_fx
                    else:
                        return 0
            
                async def _generate_algedonic_signal_async(self, eps_fx: int) -> None:
                    """Generate and send algedonic signal when quantization error exceeds threshold.
                    
                    Creates and sends an algedonic signal message via G2 when quantization
                    error exceeds mₚ/2, classified as "pain" (positive ε) or "pleasure" (negative ε).
                    
                    Args:
                        eps_fx: Quantization error in fixed-point format
                    """
                    eps_float = self._from_fixed_point(eps_fx)
                    signal_type = "pain" if eps_float > 0 else "pleasure"
                    
                    # Import message types when needed to avoid circular imports
                    from gyro_si.gyro_comm import send_message, MessageTypes
                    
                    # Create proper G6-compliant message
                    signal_message = {
                        "type": MessageTypes.ALGEDONIC_SIGNAL,
                        "source": "G1",
                        "destination": "G2",
                        "cycle_index": self.cycle_index,
                        "tensor_context": self._create_tensor_context(),
                        "payload": {
                            "signal_type": signal_type,
                            "epsilon": eps_float,
                            "tensor_id": self.tensor_id,
                            "stage": self.stage,
                            "amplitude": self._from_fixed_point(self.amplitude),
                            "cumulative_phase": self._from_fixed_point(self.cumulative_phase)
                        },
                        "timestamp": time.time()
                    }
                    
                    # Record to trace
                    self._record_to_trace("algedonic_signal_generated", 
                                          signal_type=signal_type,
                                          epsilon=eps_float)
                    
                    # Send message via G2 (async)
                    try:
                        await send_message(signal_message)
                    except Exception as e:
                        logger.error(f"Failed to send algedonic signal: {e}")
            
                def _collapse_segment_to_digest(self) -> None:
                    """Record a digest of the tensor state at exact 2π boundaries.
                    
                    This implements the pruning assertion from the specification:
                    every tensor snapshot at cumulative_phase % 2π == 0 must carry
                    a pruned_digest flag for G5 audit validation.
                    """
                    digest = {
                        "tensor_id": self.tensor_id,
                        "cycle_index": self.cycle_index,
                        "cumulative_phase": self._from_fixed_point(self.cumulative_phase),
                        "amplitude": self._from_fixed_point(self.amplitude),
                        "anti_correlation_blocks": 2,
                        "degrees_of_freedom": self.degrees_of_freedom,
                        "pruned_digest": True  # Required for G5 audit validation
                    }
                    
                    self._record_to_trace("segment_collapsed", 
                                          cumulative_phase=self._from_fixed_point(self.cumulative_phase),
                                          digest=digest)
            
                # ─────────────────── transition management ─────────────────────
                @contextmanager
                def tensor_transaction(self):
                    """Context manager for transactional tensor operations.
                    
                    Provides rollback capability for failed operations by creating
                    a complete snapshot of the tensor state before the operation
                    and restoring it if an exception occurs.
                    
                    Yields:
                        None - the context for the transaction
                        
                    Raises:
                        Any exception from the wrapped operation, after rollback
                    """
                    if not config.enable_transactions:
                        yield
                        return
                        
                    # Create deep snapshot of all mutable state
                    snapshot = {
                        "tensor_id": self.tensor_id,
                        "parent_id": self.parent_id,
                        "stage": self.stage,
                        "cycle_index": self.cycle_index,
                        "amplitude": self.amplitude,
                        "cumulative_phase": self.cumulative_phase,
                        "chirality_phase": self.chirality_phase,
                        "last_epsilon": self.last_epsilon,
                        "birth_phase": self.birth_phase,
                        "creation_cycle": self.creation_cycle,
                        "cs_memory": self.cs_memory,
                        "accumulated_threshold": self.accumulated_threshold,
                        "degrees_of_freedom": self.degrees_of_freedom,
                        "threshold_angle": self.threshold_angle,
                        "schema_version": self.schema_version,
                        "state_checksum": self.state_checksum,
                        "spinor_cycle_count": self.spinor_cycle_count,
                        # CSR arrays (deep copy for lists)
                        "indptr": self.indptr.copy() if self.indptr else None,
                        "indices": self.indices.copy() if self.indices else None,
                        "data": self.data.copy() if self.data else None,
                        # UNA structure
                        "una_indptr": self.una_indptr.copy() if self.una_indptr else None,
                        "una_indices": self.una_indices.copy() if self.una_indices else None,
                        "una_data": self.una_data.copy() if self.una_data else None,
                        # Block structure
                        "block_structure": self.block_structure.copy(),
                        # GPU state
                        "gpu_available": self.gpu_available
                    }
                    
                    self._record_to_trace("tensor_transaction_start", cycle_index=self.cycle_index)
                    
                    try:
                        yield
                        self._record_to_trace("tensor_transaction_end", cycle_index=self.cycle_index)
                    except Exception:
                        # Restore snapshot on failure
                        for key, value in snapshot.items():
                            setattr(self, key, value)
                        self._record_to_trace("tensor_transaction_abort", cycle_index=self.cycle_index)
                        raise
            
                def prepare_transition(self) -> Dict[str, Any]:
                    """Prepare state for transition to BU_In stage.
                    
                    BU_In will perform the anomalous double integration where quantization
                    error (ε) emerges as the fundamental observation mechanism.
                    This method validates the current state and packages all necessary
                    information for the BU_In stage constructor.
                    
                    Returns:
                        Dictionary containing all state needed for BU_In initialization
                        
                    Raises:
                        StructuralViolation: If ONA state is invalid for transition
                    """
                    with self.lock, stage_transition_lock:
                        # Validate structure before transition
                        self._validate_structure()
                        self._validate_fixed_point_range()
                        
                        # Update cycle index for transition
                        self.cycle_index += 1
                        
                        # Update accumulated threshold (β from UNA + γ from ONA)
                        self.accumulated_threshold = self.accumulated_threshold + self.threshold_angle
                        
                        # Update checksum after state changes
                        self.state_checksum = self._compute_checksum()
            
                        # Package state for BU_In stage
                        payload = {
                            # Core identity
                            "tensor_id": self.tensor_id,
                            "parent_id": self.parent_id,
                            "cycle_index": self.cycle_index,
                            
                            # Phase tracking (all in fixed-point)
                            "amplitude": self.amplitude,
                            "cumulative_phase": self.cumulative_phase,
                            "chirality_phase": self.chirality_phase,
                            "last_epsilon": self.last_epsilon,
                            
                            # Lineage information
                            "birth_phase": self.birth_phase,
                            "creation_cycle": self.creation_cycle,
                            
                            # Memory carried forward - CGM-derived threshold accumulation
                            "cs_memory": self.cs_memory,  # α preserved
                            "accumulated_threshold": self.accumulated_threshold,  # β + γ
                            "spinor_cycle_count": self.spinor_cycle_count,
                            
                            # ONA structure for BU_In to use
                            "ona_indptr": self.indptr.copy(),
                            "ona_indices": self.indices.copy(),
                            "ona_data": self.data.copy(),
                            "ona_block_structure": self.block_structure.copy(),
                            
                            # UNA structure preserved for lineage
                            "una_indptr": self.una_indptr.copy(),
                            "una_indices": self.una_indices.copy(),
                            "una_data": self.una_data.copy(),
                            
                            # Anti-correlation metadata
                            "anti_correlation_active": True,
                            "degrees_of_freedom": self.degrees_of_freedom,
                            
                            # Schema versioning
                            "schema_version": self.schema_version,
                        }
            
                        # Record transition preparation
                        self._record_to_trace("ona_transition_prepared",
                                              target_stage="BU_In",
                                              cycle_index=payload["cycle_index"],
                                              accumulated_threshold=self._from_fixed_point(self.accumulated_threshold),
                                              anti_correlation_active=True,
                                              degrees_of_freedom=self.degrees_of_freedom,
                                              checksum=self.state_checksum)
                        
                        return payload
            
                # ───────────────────────── trace helper ─────────────────────────────
                def _record_to_trace(self, event_type: str, **kw):
                    """Record events via the genetic memory system.
                    
                    Delegates to the proper G1 infrastructure for trace recording,
                    which will handle buffer management, retention policy, and
                    coordination with G5 for audit collection.
                    
                    Args:
                        event_type: Type of event being recorded
                        **kw: Additional event data
                    """
                    evt = {
                        "timestamp": time.time(),
                        "source": "G1_ONA",
                        "event_type": event_type,
                        "tensor_id": self.tensor_id,
                        "cycle_index": self.cycle_index,
                        "stage": self.stage,
                        # G6 required helical context
                        "helical_position": self._from_fixed_point(self.cumulative_phase) / (4 * math.pi),
                        "spinor_cycle_count": self.spinor_cycle_count,
                        "chirality_phase": self._from_fixed_point(self.chirality_phase),
                        **kw
                    }
                    
                    # Log to console/file via standard logging
                    logger.debug("ONA Event: %s", evt)
                    
                    # Delegate to genetic memory for proper trace recording
                    self.genetic_memory.record_event(evt)
            
                # ───────────────────────── utility methods ─────────────────────────────
                def get_anti_correlation_info(self) -> Dict[str, Any]:
                    """Get anti-correlation structure information.
                    
                    Returns:
                        Dictionary with anti-correlation details
                    """
                    return {
                        "block_structure": self.block_structure,
                        "anti_correlation_active": True,
                        "block_count": 2,
                        "degrees_of_freedom": self.degrees_of_freedom
                    }
            
                def get_threshold_info(self) -> Dict[str, float]:
                    """Get threshold information in human-readable format.
                    
                    Returns:
                        Dictionary with threshold values converted to floats
                    """
                    return {
                        "threshold_angle": self._from_fixed_point(self.threshold_angle),
                        "accumulated_threshold": self._from_fixed_point(self.accumulated_threshold),
                        "sensitivity_factor": self._from_fixed_point(self.threshold_angle) / 4,
                        "cgm_gamma_value": self._from_fixed_point(self.threshold_angle)
                    }
            
                def get_phase_info(self) -> Dict[str, float]:
                    """Get current phase information in human-readable format.
                    
                    Returns:
                        Dictionary with phase values converted to floats
                    """
                    return {
                        "amplitude": self._from_fixed_point(self.amplitude),
                        "cumulative_phase": self._from_fixed_point(self.cumulative_phase),
                        "chirality_phase": self._from_fixed_point(self.chirality_phase),
                        "last_epsilon": self._from_fixed_point(self.last_epsilon),
                        "helical_position": self._from_fixed_point(self.cumulative_phase) / (4 * math.pi),
                        "spinor_cycle_count": self.spinor_cycle_count
                    }
            
                def get_structure_info(self) -> Dict[str, Any]:
                    """Get structural information about the tensor.
                    
                    Returns:
                        Dictionary with tensor structure details
                    """
                    return {
                        "shape": self.SHAPE,
                        "shape_2d": (6, 2),  # Flattened representation
                        "nonzeros": self.NONZEROS,
                        "degrees_of_freedom": self.degrees_of_freedom,
                        "gpu_available": self.gpu_available,
                        "anti_correlation_blocks": 2,
                        "checksum": self.state_checksum
                    }
            
                def is_spawn_eligible(self) -> bool:
                    """Check if tensor is eligible for spawning.
                    
                    ONA stage is not directly spawn-eligible. Spawning occurs at BU_En
                    stage after completing the full cycle and reaching 4π.
                    
                    Returns:
                        Always False for ONA stage
                    """
                    return False
            
                def reconstruct_3d_structure(self) -> np.ndarray:
                    """Reconstruct the full 3D anti-correlated structure.
                    
                    Returns:
                        3D numpy array with shape (2, 3, 2) showing the anti-correlated blocks
                    """
                    # Reconstruct 2D from CSR
                    values = []
                    for encoded in self.data:
                        if encoded == 0b01:
                            values.append(1)
                        elif encoded == 0b11:
                            values.append(-1)
            
                    csr = csr_matrix((values, self.indices, self.indptr), shape=(6, 2))
                    dense_2d = csr.toarray()
                    
                    # Reshape to 3D structure
                    return dense_2d.reshape(2, 3, 2)
            
                def get_cgm_compliance_info(self) -> Dict[str, Any]:
                    """Get CGM compliance and derivation information.
                    
                    Returns:
                        Dictionary with CGM-derived values and their sources
                    """
                    return {
                        "cs_memory_source": "ALPHA (π/2)",
                        "cs_memory_value": self._from_fixed_point(self.cs_memory),
                        "threshold_angle_source": "GAMMA (π/4)",
                        "threshold_angle_value": self._from_fixed_point(self.threshold_angle),
                        "accumulated_threshold_derivation": "β + γ (UNA + ONA)",
                        "accumulated_threshold_value": self._from_fixed_point(self.accumulated_threshold),
                        "quantization_parameter": M_P,
                        "sensitivity_derivation": "GAMMA/4",
                        "all_parameters_cgm_derived": True
                    }
            
                def __repr__(self) -> str:
                    """String representation of ONA observation."""
                    return (f"ONAObservation(tensor_id={self.tensor_id}, "
                            f"cycle={self.cycle_index}, "
                            f"amplitude={self._from_fixed_point(self.amplitude):.6f}, "
                            f"anti_corr=True, "
                            f"helical_pos={self._from_fixed_point(self.cumulative_phase)/(4*math.pi):.4f}, "
                            f"spinor_cycle={self.spinor_cycle_count})")
            
                def __str__(self) -> str:
                    """Human-readable string representation."""
                    helical_pos = self._from_fixed_point(self.cumulative_phase) / (4 * math.pi)
                    return (f"ONA Observation τ{self.tensor_id} "
                            f"(cycle {self.cycle_index}, anti-correlated, "
                            f"helical {helical_pos:.4f}, spinor {self.spinor_cycle_count})")
            ```
            
        - `gyro_si/g1_gyroalignment/bu_in/g4_governance.py`
        - `gyro_si/g1_gyroalignment/bu_en/g5_governance.py`
    - **Batch 2.3: Genetic Memory & The Runner**
        - `gyro_si/g1_gyroalignment/genetic_memory.py`
        - `gyro_si/g1_gyroalignment/runner.py`
    
    ---
    
    ### **Phase 3: The Information Coordinator (G2 GyroInformation)**
    
    - **Batch 3.1: Lexicon & Memory**
        - `gyro_si/g2_gyroinformation/epigenetic_memory.py`
        - `gyro_si/g2_gyroinformation/cs/g1_governance.py`
        - `gyro_si/g2_gyroinformation/una/g2_governance.py`
        - `gyro_si/g2_gyroinformation/ona/g3_governance.py`
        - `gyro_si/g2_gyroinformation/bu_in/g4_governance.py`
        - `gyro_si/g2_gyroinformation/bu_en/synthesis.py`
    - **Batch 3.2: Runner**
        - `gyro_si/g2_gyroinformation/runner.py`
    
    ---
    
    ### **Phase 4: The Interactive Interface (G3 GyroInference)**
    
    - **Batch 4.1: Stage Modules**
        - `gyro_si/g3_gyroinference/cs/g1_governance.py`
        - `gyro_si/g3_gyroinference/una/g2_governance.py`
        - `gyro_si/g3_gyroinference/ona/g3_governance.py`
        - `gyro_si/g3_gyroinference/bu_in/g4_governance.py`
        - `gyro_si/g3_gyroinference/bu_en/synthesis.py`
        - `gyro_si/g3_gyroinference/structural_memory.py`
        - *(If a UI is present, its path and assets directory should be specified separately, e.g., `gyro_si/g3_gyroinference/ona/interface/` and `assets/`, if those exist)*
    - **Batch 4.2: Runner**
        - `gyro_si/g3_gyroinference/runner.py`
    
    ---
    
    ### **Phase 5: The Strategic Observer (G4 GyroIntelligence Ingress)**
    
    - **Batch 5.1: Analytics & Observation**
        - `gyro_si/g4_gyrointelligence_in/cs/g1_governance.py`
        - `gyro_si/g4_gyrointelligence_in/una/g2_governance.py`
        - `gyro_si/g4_gyrointelligence_in/ona/g3_governance.py`
        - `gyro_si/g4_gyrointelligence_in/bu_in/g4_governance.py`
        - `gyro_si/g4_gyrointelligence_in/bu_en/synthesis.py`
        - `gyro_si/g4_gyrointelligence_in/somatic_memory.py`
    - **Batch 5.2: Runner**
        - `gyro_si/g4_gyrointelligence_in/runner.py`
    
    ---
    
    ### **Phase 6: The Executive Governor (G5 GyroIntelligence Egress)**
    
    - **Batch 6.1: Governance, Policy & Memory**
        - `gyro_si/g5_gyrointelligence_en/cs/g1_governance.py`
        - `gyro_si/g5_gyrointelligence_en/una/g2_governance.py`
        - `gyro_si/g5_gyrointelligence_en/ona/g3_governance.py`
        - `gyro_si/g5_gyrointelligence_en/bu_in/g4_governance.py`
        - `gyro_si/g5_gyrointelligence_en/bu_en/synthesis.py`
        - `gyro_si/g5_gyrointelligence_en/immunity_memory.py`
    - **Batch 6.2: Runner**
        - `gyro_si/g5_gyrointelligence_en/runner.py`
    
    ---