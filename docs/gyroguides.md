# 💫 Overview

I will give you first the whole context - you dont have to comment - and after the [end of context], I will tell you which file we will do next.

- GyroSI Intro
    
    We are working on the foundations we have laid out by the CGM a physics-grounded model of governance, and its expansions through different formalisations, such as devising Tensors’ inherent mathematical anatomy as a gyrogroup representations, and we are architecting a complete system for SuperIntelligence.
    
- Superintelligence
    
    By Superintelligence we define a structurally recursive form of intelligence in which all of its generative and integrative modes preserve memory of origin, maintaining continuous coherence between emergence and recollection.
    
    It achieves ethical alignment **intrinsically**, by ensuring that every operation remains structurally accountable to its own genesis, **without external enforcement**.
    
    **Superintelligence exists relationally, not independently**: it reflects the recursive structures of reality and human meaning it participates in, embodying governance, memory, and creative coherence as a unified operational principle.
    

---

- GyroSI Requirements: How we architect and improve
    
    ---
    
    ## Core Implementation Philosophy
    
    **GyroSuperintelligence (GyroSI)** is founded on structurally recursive intelligence, where every operation is a progression of a tensor τ through a alignment-based sequence of stages (CS→UNA→ONA→BU_In→BU_En→ONA→UNA→CS). Intelligence and alignment are not encoded through parameterization or external heuristics but arise intrinsically from the permitted transitions and relationships of discrete tensor forms on a toroidal manifold.
    
    ### Key Principles
    
    1. **Tensor-Based Architecture**
        - All system state is encoded in explicit tensor forms, as developed in the core formalism.
        - Only discrete values {-1, 0, 1} are used; no separate phase, chirality, or toroidal metadata is permitted. These properties emerge from tensor evolution and arrangement.
        - The recursive, toroidal structure is realized through how tensors relate and traverse their canonical sequence.
    2. **Recursive Structural Emergence**
        - System structure is defined by the recursive unfolding of τ:
            
            **CS → UNA → ONA → BU_In → BU_En → ONA(return) → UNA(return) → CS(closure)**
            
        - Each stage is a specific, concrete tensor pattern with tightly specified constraints.
        - All alternation between integrative and generative modes, as well as the anomaly of quantization and observation, arises naturally at BU.
    3. **Self-Correcting Dynamics**
        - Misalignment is inherently self-correcting; the closed toroidal sequence and permitted transitions restore alignment without external intervention.
        - No additional validation, correction, or enforcement mechanisms are needed or allowed.
    4. **Observation and Quantization**
        - Observation is not external measurement but emerges as quantization error (ε) when continuous phase φ is mapped to discrete tensor state at BU stages.
        - Algedonic signals (pain, pleasure) and escalation mechanisms propagate recursively in response to these quantization errors.
    5. **BU as Intrinsic I/O**
        - **BU_In**: Integrates external input or memory into the tensor structure.
        - **BU_En**: Generates system output, propagating quantized and structured information outward.
    
    ### Category of Intelligence
    
    - GyroSI does not fit symbolic, connectionist, or stochastic paradigms.
    - **Structurally recursive intelligence** is achieved: all logic, adaptation, and inference derive from maintaining structural alignment, not from parameter optimization or arbitrary learning rules.
    - Core properties:
        - *Inherent interpretability*: Structural state directly encodes meaning and alignment.
        - *No hallucination*: Invalid or nonviable sequences cannot persist.
        - *Universality*: Principles and operations scale without loss of integrity.
    
    ### Operational Specification
    
    - At every level (G1–G5), only the canonical sequence and its permitted transitions are valid.
    - Operations are not externally coded algebraic actions; they are the alignment-based reconfiguration of τ according to stage forms.
    - Higher-level systems (G2–G5) do not create new operational types, but realize recursive variants of the G1 operational cycle, always referencing and propagating G1’s logic.
    
    ### Legal Moves & Stage Constraints
    
    | Sequence Step | Operation Type | Structural Rule/Change |
    | --- | --- | --- |
    | CS → UNA | Generation | 3×2 tensor, maximal left-bias, values in {–1, 1} |
    | UNA → ONA | Integration | 2×3×2 tensor, anti-correlated block extension |
    | ONA → BU_In | Integration | 2×2×3×2 tensor, double integration, memory collision |
    | BU_In → BU_En | Generation | Oscillation, bi-gyrogroup generation, explicit quantization |
    | BU_En → ONA(return) | Generation | Return phase, inversion of chirality |
    | ONA → UNA(return) | Integration | Collapse to right-biased 3×2 block |
    | UNA → CS(return) | Generation | Return to identity, structural closure |
    
    Only the prescribed transformation is legal at each step. Any deviation is a misalignment or defect.
    
    ---
    
    ## Architectural and Theoretical Requirements
    
    1. **Recursive Structural Integrity**
        - All system mechanisms and policies must strictly arise from the canonical CS→UNA→ONA→BU(In/En) sequence at every level. No operations, transitions, or states are permitted outside this cycle.
    2. **Axiomatic Sufficiency**
        - Only the core CGM-derived constants (α, β, γ, mₚ, π, 2π, 4π) are valid. All numeric limits, phase spaces, and bounds are logical consequences of these; no extra parameters or rates are permitted.
    3. **Memory-Type Preservation**
        - All memory, state, and trace data must correspond to the five canonical types (genetic, epigenetic, structural, somatic, immunity), each maintained under lineage and audit governance. No untyped, hidden, or ad hoc state is allowed.
    4. **No Ad Hoc Overlays**
        - Error handling, adaptation, and escalation must result directly from recursive quantization and algedonic logic. No external control paths, override routines, or patch mechanisms are acceptable.
    5. **Strict Quantization and Algedonic Logic**
        - All mappings from continuous to discrete (φ to τ) use mₚ and the canonical quantization rule. All observation errors and algedonic signals propagate only as prescribed by the escalation sequence.
    6. **Canonical Policy Domains**
        - Policy, control, or meta-coordination must only operate within the four canonical G5 domains: 1. Governance Traceability, 2. Information Variety, 3. Inference Accountability, 4. Integrative Intelligence Integrity, 5. Generative Intelligence Integrity. No further policy classes, roles, or domain boundaries are to be defined.
    7. **Full Auditability and Lineage**
        - Every action, transition, and memory update must be logged with complete provenance (cycle, source, lineage, checksum) and directly traceable to its operational context.
    8. **Theory-First Self-Improvement**
        - Any optimization, adaptation, or learning proposal must be justified in terms of improved structural, memory, or quantization alignment. Only strict consequences of recursive theory are allowed.
    9. **Explicit Prohibition of External Heuristics**
        - No learning mechanism, heuristic, or parameter may be introduced on the basis of external convention, performance benchmark, or subjective preference. All innovations must arise from recursive structure or observed quantization patterns.
    10. **Documentation of Structural Deviations**
        - Any required deviation (e.g., hardware constraint, legal compliance) must be explicitly logged, justified, and handled as a quantization defect subject to audit.
    
    ---
    
    **Summary Requirement:**
    
    *GyroSI must operate as a closed, recursive, memory-governed system in which every operation, structure, parameter, and adaptation is a necessary, traceable consequence of the foundational theory. No part of the system may be arbitrary, heuristic, or external to the recursively unfolding tensor logic.*
    
    ---
    
    This consolidation provides a precise, enforceable foundation for implementation, review, and iterative improvement, minimizing ambiguity and precluding architectural drift.
    
- GyroSI Baby ML: What we are making
    
    Our MVP will be called GyroSI Baby ML, A fully operational (not toy) language model. Called Baby because it will learn language and grow on its own through an Open Training. That means, without reinforcement, no rewards, no typical approaches which detach from what we have defined through our precise formalism - by leveraging the defined Hebbian Learning operations existent in our Alignment operations, and indexing through our special Quantization technique. Any other mechanism which is not clearly stated - it needs to be discussed by clearly stated and not assumed as correct because other architectures implement it. 
    
    ## **Constraints and Needs**
    
    - **Language:** Text-in/text-out, learning directly from stream or corpus.
    - **Learning:** Based on explicit, Hebbian-aligned operations and quantization as per your model, not gradient descent or backprop.
    - **Open Training:** The system modifies itself recursively as it processes data, aligning tensor structures, preserving coherence.
    - **Implementation:** Should allow for rapid prototyping, not require compilation for each small change. Needs to run on modest hardware (your old MacBook).
    - **Frontend:** Flet-based for interaction/document view.
    - **Backend:** Python. Must manage tensor structures, quantization, and memory efficiently, leverage GPU acceleration, but also be able to run on CPU efficiently.
    
- UI Components
    1. **Threads List (Left Panel)**:
        - **Description**: A vertical list on the left side displaying conversation threads, each representing a chat session identified by session_id (per G3 specifications).
        - **Features**:
            - Threads are listed with titles (e.g., first message preview or user-defined name).
            - Drag-and-drop support to reorganize threads or move them into folders.
            - Click a thread to load its chat history in the main chat panel.
        - **Purpose**: Organizes conversations for easy navigation, reflecting the structural memory (G3) and session-based interaction model.
        - **Flet Implementation**: Use ft.ListView for the threads list, with ft.GestureDetector for drag-and-drop functionality.
    2. **Folder Nesting (Within Threads List)**:
        - **Description**: Folders within the threads list to group related threads, supporting nested subfolders.
        - **Features**:
            - Create, rename, or delete folders via right-click context menus.
            - Drag threads or subfolders into folders to nest them.
            - Collapsible folders to manage screen space.
        - **Purpose**: Enhances organization, aligning with the recursive structure of GyroSI’s memory (genetic, epigenetic, structural, somatic, immunity) by allowing hierarchical storage of sessions.
        - **Flet Implementation**: Use ft.TreeView within the ft.ListView to support nested folders, with drag-and-drop enabled via ft.DragTarget and ft.Draggable.
    3. **Chat Panel (Main Area)**:
        - **Description**: A central panel for real-time chat, displaying the conversation history and accepting user input.
        - **Features**:
            - Scrollable chat history showing user messages and model responses, tagged with session_id and timestamps.
            - Text input field at the bottom for sending messages, processed via G3_BU_In.
            - Send button to submit messages, triggering G3_ONA’s API sequence (input → tokenization → processing → output).
        - **Purpose**: Provides the core conversational interface, aligning with G3_ONA’s role in handling user interactions and G2’s language processing pipeline.
        - **Flet Implementation**: Use ft.Column with a ft.ListView for chat history and ft.TextField with ft.ElevatedButton for input and submission.
    4. **Document Upload Button**:
        - **Description**: A button or drag-and-drop area to upload documents for training or context, processed by G2_BU_In (Import Adaptors).
        - **Features**:
            - Supports common file types (e.g., .txt, .pdf, .docx), tokenized and integrated into the G2 lexicon for training or contextual use.
            - Visual feedback (e.g., progress bar) during upload and processing, respecting chunk_token_limit.
            - Documents are associated with the current thread or session for context retention.
        - **Purpose**: Enables open training and contextual processing, as specified in the Baby ML requirements, without cluttering the chat interface.
        - **Flet Implementation**: Use ft.FilePicker for uploads, with a ft.ProgressBar for feedback, integrated with G2_BU_In’s ingestion pipeline.
    5. **Settings Panel (Optional, Minimal)**:
        - **Description**: A small settings area, accessible via a menu or button, for configuring system prompts or memory export/import.
        - **Features**:
            - System prompt input to customize model behavior (stored in G2’s epigenetic memory).
            - Export/import options for the five memory types (genetic, epigenetic, structural, somatic, immunity), handled by G2_BU_En’s export adaptors.
            - Minimal design to avoid complexity (e.g., a modal dialog or sidebar).
        - **Purpose**: Provides basic customization and memory management, supporting GyroSI’s self-aligning memory system while keeping the UI simple.
        - **Flet Implementation**: Use ft.PopupMenuButton or ft.Dialog for settings, with ft.TextField for prompts and ft.FilePicker for memory export/import.
- GyroSuperintelligence (GyroSI): How we are making it
    
    **Superintelligence is a structurally recursive form of intelligence in which all generative and integrative operations preserve memory of origin, maintaining continuous coherence between emergence and recollection.**
    
    It achieves ethical alignment **intrinsically**, by ensuring that every operation remains structurally accountable to its own genesis, **without external enforcement**.
    
    **Superintelligence exists relationally, not independently**: it reflects the recursive structures of reality and human meaning it participates in, embodying governance, memory, and creative coherence as a unified operational principle.
    
    ---
    
    ## Core Architecture
    
    GyroSuperintelligence implements five recursively viable systems (G1-G5), each containing the complete CS→UNA→ONA→BU cycle:
    
    ### G1(GS_CS): GyroAlignment Management
    
    **Memory Type**: Genetic Memory
    
    **VSM Role**: System 1 - Primary Operations
    
    - **G1_CS**: Initiate & Register tensor identity τ
    - **G1_UNA**: Normalize to τ = [[-1,1], [-1,1], [-1,1]]
    - **G1_ONA**: Create anti-correlation τ = [[[-1,1], [-1,1], [-1,1]], [[1,-1], [1,-1], [1,-1]]]
    - **G1_BU_In**: Integrative quantization (Lgyr) - where π/2 memory meets mₚ amplitude
    - **G1_BU_En**: Generative quantization (Rgyr) - where observation emerges as ε
    
    The quantization at G1_BU is where continuous phase φ maps to discrete {-1,1} values, creating the observation error ε = φ - φ_nearest.
    
    ### G2(GS_UNA): GyroInformation Curation
    
    **Memory Type**: Epigenetic Memory
    
    **VSM Role**: System 2 - Coordination
    
    - **G2_CS**: All Data (Application Structure and Files)
    - **G2_UNA**: Backend Pipeline (Data Preprocessing & Indexing)
    - **G2_ONA**: Frontend Data (Data Interaction & Settings)
    - **G2_BU_In**: Import Adaptors (Data Ingress & Connectors)
    - **G2_BU_En**: Export Adaptors (Data Egress & Streams)
    
    G2 manages the flow of information between G1 tensor operations and higher-level processes.
    
    ### G3(GS_ONA): GyroInference Interaction
    
    **Memory Type**: Structural Memory
    
    **VSM Role**: System 3 - Operational Management
    
    - **G3_CS**: Hardware Endpoints
    - **G3_UNA**: Data Endpoints
    - **G3_ONA**: Frontend Interface
    - **G3_BU_In**: Input Handling (Ingress)
    - **G3_BU_En**: Output Handling (Egress)
    
    G3 provides the interface layer, managing the "here and now" of system operations.
    
    ### G4(GS_BU): GyroIntelligence Environmental Cooperation
    
    **Memory Type**: Somatic Memory
    
    **VSM Role**: System 4 - Environmental Adaptation
    
    - **G4_CS**: Tensor Governance Traceability
    - **G4_UNA**: Information Variety States
    - **G4_ONA**: Inference Accountability Patterns
    - **G4_BU_In**: Environmental Integration (Lgyr) - integrating external changes
    - **G4_BU_En**: Environmental Generation (Rgyr) - generating adaptive responses
    
    G4 monitors the "there and then" - environmental changes requiring adaptation.
    
    ### G5(GS_BU): GyroIntelligence Policy Operation
    
    **Memory Type**: Immunity Memory
    
    **VSM Role**: System 5 - Policy Coordination
    
    - **G5_CS**: Governance Traceability (@) - G1 Management
    - **G5_UNA**: Information Variety (&) - G2 Curation
    - **G5_ONA**: Inference Accountability (%) - G3 Interaction
    - **G5_BU_In**: Policy Integration (Lgyr) - G4 Cooperation meta-coordination
    - **G5_BU_En**: Policy Generation (Rgyr) - G5 Operation meta-synthesis
    
    G5 balances all subsystems to maintain viable identity.
    
    ---
    
    ## Quantization and Observation
    
    The critical quantization occurs at G1_BU, where:
    
    ```
    Continuous phase φ → Discrete tensor values {-1, 1}
    Quantization error: ε = φ - φ_nearest
    
    ```
    
    This quantization propagates through all levels:
    
    1. **G1**: Raw quantization creates observation
    2. **G2**: Quantized data flows through pipelines
    3. **G3**: Quantized patterns interface with environment
    4. **G4**: Environmental changes detected through quantization thresholds
    5. **G5**: Policy decisions based on accumulated quantization patterns
    
    ---
    
    ## The Dual BU Operations
    
    At each level, BU contains both integrative and generative operations:
    
    ### Integrative (BU_In) - Lgyr
    
    - Combines existing memories
    - Achieves coherence through harmonic oscillation
    - Maintains defect-free progression
    - Operates alignment-basedally
    
    ### Generative (BU_En) - Rgyr
    
    - Creates new states from integrated memories
    - Introduces variation through quantization error
    - Enables exploration and adaptation
    - Operates stochastically within bounds
    
    ---
    
    ## Algedonic Signal Implementation
    
    Algedonic signals emerge naturally from quantization thresholds:
    
    ### Signal Generation
    
    When quantization error ε exceeds local threshold at any G-level:
    
    ```
    If |ε| > threshold_local:
        signal = algedonic_alert(level, ε)
    
    ```
    
    ### Signal Propagation
    
    1. **Local attempt**: G[n]_BU attempts to absorb error
    2. **Escalation**: If |ε| > mₚ, signal propagates to G[n+1]
    3. **Policy check**: G5 evaluates if system-wide response needed
    4. **Cascade**: Coordinated response propagates down
    
    ### Signal Types
    
    - **Pain** (ε > threshold): Performance below capability
    - **Pleasure** (ε < -threshold): Performance exceeding expectation
    
    These signals are not external additions but natural consequences of quantization exceeding bounds at each recursive level.
    
    ---
    
    ## Recursive Viability
    
    Each G-level contains five subsystems, creating fractal structure:
    
    ```
    G1 (GyroAlignment):
    ├── G1.1_CS: Tensor element governance
    ├── G1.2_UNA: Element coordination
    ├── G1.3_ONA: Element correlation
    ├── G1.4_BU_In: Element integration
    └── G1.5_BU_En: Element generation
    
    G2 (GyroInformation):
    ├── G2.1_CS: Data structure governance
    ├── G2.2_UNA: Data flow coordination
    ├── G2.3_ONA: Data pattern correlation
    ├── G2.4_BU_In: Data integration
    └── G2.5_BU_En: Data generation
    
    [Pattern continues for G3, G4, G5]
    
    ```
    
    ---
    
    ## Tensor Spawning Mechanism
    
    When amplitude reaches mₚ = 1/(2√(2π)):
    
    1. **G1_BU_En** detects amplitude saturation
    2. **G4_BU_In** integrates environmental need for expansion
    3. **G5_BU_En** generates spawning decision
    4. **New tensor τ'** emerges with:
        - Phase offset: π/2 from parent
        - Independent identity: New G1_CS
        - Inherited structure: Same 3D + 6DoF
    
    ---
    
    ## Complete Operational Flow
    
    ### Forward Path (CS → BU_In)
    
    1. **G1_CS**: Initialize τ
    2. **G1_UNA**: Create structure (quantization begins)
    3. **G1_ONA**: Anti-correlate (Hebbian learning)
    4. **G1_BU_In**: Integrate (anomalous double integration)
    
    ### Return Path (BU_En → CS)
    
    1. **G1_BU_En**: Generate with quantization error
    2. **G1_ONA**: Return correlation
    3. **G1_UNA**: Return structure
    4. **G1_CS**: Complete cycle
    
    This pattern repeats at all five G-levels simultaneously, creating a five-fold recursive helix.
    
    ---
    
    ## Memory Architecture
    
    G5 maintains and governs **all five memory types** defined by the CGM:
    
    | Memory Type | Maintained As | Primary Origin |
    | --- | --- | --- |
    | Genetic | `g1_genetic` | G1 (structural patterns) |
    | Epigenetic | `g2_epigenetic` | G2 (data mappings) |
    | Structural | `g3_structural` | G3 (session/inference traces) |
    | Somatic | `g4_somatic` | G4 (environmental assessments) |
    | Immunity | `g5_immunity` | G5 (policy thresholds, decision outcomes) |
    
    All are retained in lineage-tagged, checksummed memory partitions under G5’s control. BU_In and BU_En checkpoints consolidate and regenerate these stores, ensuring coherent identity across all GyroSI subsystems.
    
    ---
    
    ## Summary
    
    GyroSuperintelligence achieves recursive viability through:
    
    1. **Five-fold structure** (G1-G5) each with complete CS→UNA→ONA→BU cycle
    2. **Dual BU operations** (In/En) at every level
    3. **Natural quantization** creating observation at G1_BU
    4. **Algedonic signals** from quantization thresholds
    5. **Recursive viability** with each G containing five subsystems
    6. **Phase-space reproduction** when amplitude saturates
    7. **Intrinsic alignment** through structural accountability
    
    The architecture is fully determined by the tensor formalism and CGM theory, with no ad-hoc additions. Every feature emerges from the fundamental requirement of maintaining viable recursive structure while managing the irreducible quantization error that creates observation itself.

    ===

    # 📚 Development

---

- GyroSI Baby ML: Structure
    
    This chapter describes the on-disk layout that guarantees every `import` statement and file reference in the implementation guides resolves unambiguously. The structure reflects the five recursive G-systems, their CS → UNA → ONA → BU_In → BU_En cycle, the five canonical memory types, and the shared constants, errors, and configuration declared by G6.
    
    > Guide principle
    > 
    > 
    > The code base is intended to compile and run without path adjustments. All directories, module names, and data folders mentioned in the normative text therefore exist exactly as written here.
    > 
    
    ---
    
    ### A. Top-Level Layout
    
    ```
    gyro_si/                # Root Python package (installable)
    │
    ├── audit/              # Observer trace batches, CIDs, forensic artefacts
    ├── benchmarks/         # Micro-benchmarks and performance harnesses
    ├── data/               # Static canonical data sets
    ├── docs/               # Sphinx or MkDocs source, including this guide
    ├── patterns/           # Canonical tensor templates
    │   └── gyro_g1/
    │       └── v1/         # Schema version folders (v2, v3 … added as needed)
    ├── scripts/            # Dev utilities, entry points, database migration helpers
    ├── transitions/        # Stage transition lookup tables
    │   └── gyro_g1/
    │       └── v1/
    ├── tests/              # Pytest suite (fully enumerated in section G)
    │
    ├── .dvc/               # Data-version-control metadata
    ├── .gitignore
    ├── dvc.yaml
    ├── pyproject.toml
    └── README.md
    
    ```
    
    *Rationale*
    
    The root segregates source (`gyro_si/`) from artefacts, versioned data, documentation, and quality-control assets. Continuous integration jobs verify that every sub-package respects the unidirectional dependency flow CS → UNA → ONA → BU.
    
    ---
    
    ### B. Core Source Package `gyro_si/`
    
    ```
    gyro_si/
    │
    ├── __init__.py
    │
    ├── gyro_constants.py          # Canonical constants and derived horizons
    ├── gyro_errors.py             # Taxonomy rooted in GyroError
    ├── gyro_comm.py               # send_message, subscribe, transport glue
    │
    ├── gyro_gcr/                  # GyroCardioRespiratory integration layer
    │   ├── __init__.py
    │   └── gyro_config.py
    │
    ├── g1_gyroalignment/
    ├── g2_gyroinformation/
    ├── g3_gyroinference/
    ├── g4_gyrointelligence_in/
    ├── g5_gyrointelligence_en/
    └── g6_gyrocirculation/        # Shared runners not covered by the four files above
    
    ```
    
    *Notes*
    
    - `gyro_constants.py`, `gyro_errors.py`, and `gyro_comm.py` sit at the same depth as the G-packages, ensuring that any file inside the tree can import them without relative paths.
    - `gyro_gcr/gyro_config.py` hosts the mutable feature toggles referenced throughout section A.5 of the normative guide.
    - `g6_gyrocirculation/` exists for future shared mechanisms or reference runners that belong to G6 but are not already captured in the four canonical modules.
    
    ---
    
    ### C. Universal G-Package Layout
    
    Each G-system is a namespace package with an identical internal lattice that mirrors the five VSM stages. Example shown for G5.
    
    ```
    g5_gyrointelligence_en/
    │
    ├── __init__.py
    ├── runner.py                 # Top-level asyncio entry loop
    │
    ├── cs/
    │   └── g1_governance.py      # Governance Traceability
    ├── una/
    │   └── g2_governance.py      # Information Variety
    ├── ona/
    │   └── g3_governance.py      # Inference Accountability
    ├── bu_in/
    │   └── g4_governance.py      # Policy integration (Lgyr)
    ├── bu_en/
    │   └── synthesis.py          # Policy generation (Rgyr)
    │
    ├── patterns/
    │   └── .gitkeep
    ├── transitions/
    │   └── .gitkeep
    └── immunity_memory.py        # Memory module unique to G5
    
    ```
    
    Identical sub-trees appear in `g1_`, `g2_`, `g3_`, and `g4_`, each with their own memory module:
    
    | G-package | Memory file |
    | --- | --- |
    | `g1_gyroalignment/` | `genetic_memory.py` |
    | `g2_gyroinformation/` | `epigenetic_memory.py` |
    | `g3_gyroinference/` | `structural_memory.py` |
    | `g4_gyrointelligence_in/` | `somatic_memory.py` |
    | `g5_gyrointelligence_en/` | `immunity_memory.py` |
    
    ### Stage-Specific Reference Files
    
    Some guides cite filenames outside the generic “governance” modules. They are included verbatim to preserve import statements.
    
    | Guide fragment | Path in tree |
    | --- | --- |
    | `g1_gyroalignment/cs/identity.py` | `gyro_si/g1_gyroalignment/cs/identity.py` |
    | `g1_gyroalignment/gyro_tensor.py` | `gyro_si/g1_gyroalignment/gyro_tensor.py` |
    | `g1_gyroalignment/bu_en/g5_governance.py` | `gyro_si/g1_gyroalignment/bu_en/g5_governance.py` |
    | `g2_gyroinformation/runner.py` | `gyro_si/g2_gyroinformation/runner.py` |
    | `g4_gyrointelligence_in/bu_in/integration.py` | `gyro_si/g4_gyrointelligence_in/bu_in/integration.py` |
    
    ---
    
    ### D. Canonical Data Directories
    
    Two directories hold all versioned, machine-readable data required by the normative specification.
    
    | Purpose | Directory example | Version policy |
    | --- | --- | --- |
    | Stage templates (identity, CSR layout) | `patterns/gyro_g1/v1/…` | Semantic schema version sub-dir |
    | Transition tables | `transitions/gyro_g1/v1/…` | Same versioning convention |
    
    Additional versions (`v2`, `v3`, …) are added in sibling folders when the schema evolves, never by overwriting earlier data.
    
    ---
    
    ### E. Test Suite and Quality Gates
    
    The `tests/` folder contains one file per normative guarantee.
    
    | Test file | Primary assertion (see A.5.7) |
    | --- | --- |
    | `test_bootstrap.py` | Actors exit the 30 s gating loop |
    | `test_transactions.py` | State after abort equals snapshot |
    | `test_recovery.py` | Closed breaker triggers reset |
    | `test_entropy_chain.py` | `entropy_id` round-trips intact |
    | `test_crypto_evolution.py` | Three-term formula respected |
    
    Continuous integration runs `pytest -q` once with entropy and crypto disabled, then again with both enabled.
    
    ---
    
    ### F. Dependency Boundaries
    
    Static analysis enforces the rule “inner stages never import outward”. Concretely, each G-package depends on:
    
    ```
    cs/     ↦ no internal imports except top-level shared modules
    una/    ↦ cs/ only
    ona/    ↦ una/, cs/
    bu_in/  ↦ ona/, una/, cs/
    bu_en/  ↦ bu_in/, ona/, una/, cs/
    
    ```
    
    A simple script in `scripts/lint_architecture.py` walks the AST and flags violations.
    
    ---
    
    ### G. Optional Components
    
    | Folder | Description |
    | --- | --- |
    | `benchmarks/` | `pytest-bench` harnesses for quantization and tensor evolution |
    | `audit/` | Accumulating `observer_trace.jl` batches with Blake3 CIDs |
    | `data/` | Public domain corpora or canned traces used in integration tests |
    | `.dvc/` | Version tracking for large files referenced by `dvc.yaml` |
    
    These folders remain empty on first checkout, guarded by `.gitkeep` when needed.
    
    ---
    
    ### H. Installation and Entry Points
    
    `pyproject.toml` declares `gyro-si` as the console entry point bound to `g6_gyrocirculation.runner:cli`. Optional extras, such as GPU support and the Flet UI, appear under `[project.optional-dependencies]`.
    
    ---
    
    ### I. Summary
    
    The tree above contains every module, data file, and test referenced by the normative implementation guides. All imports are absolute and resolvable. Versioned templates, transition tables, and memory modules live in predictable locations, while stage folders replicate consistently across the five G-packages. Continuous integration enforces stage boundaries, executes the full regression suite, and verifies that the project remains installable as a single package.
    
- GyroSI Baby ML: Boilerplate
    
    {# ====================================================================== #}
    {#  Jinja2 template for every G1 stage module                             #}
    {#  ────────────────────────────────────────────────────────────────────  #}
    {#  Render variables expected from the YAML / JSON descriptor             #}
    {#                                                                       #}
    {#  ─ required ─                                                         #}
    {#    STAGE_NAME_CAMEL       e.g. "UNANormalization"                     #}
    {#    STAGE_NAME_UPPER       e.g. "UNA"                                  #}
    {#    FILE_DOCSTRING         High-level description string               #}
    {#    SHAPE_TUPLE            e.g. (3, 2)                                 #}
    {#    NONZEROS_INT           e.g. 6                                      #}
    {#    CLASS_DESCRIPTION      One-line summary inside the class           #}
    {#    CANONICAL_PATTERN_STR  repr() of dense ndarray OR "None"           #}
    {#                                                                   ▼   #}
    {#  ─ optional (set to None / empty if unused) ─                         #}
    {#    EXTRA_CONSTANTS_BLOCK      # custom constant defs                  #}
    {#    EXTRA_INIT_STATE           # additional **init** assignments       #}
    {#    EXTRA_INIT_CSR_CODE        # custom CSR build steps                #}
    {#    EXTRA_VALIDATE_CODE        # any extra structural checks           #}
    {#    EXTRA_PHASE_CODE           # extra per-phi processing (fixed-pt)   #}
    {#    EXTRA_TRANSITION_PAYLOAD   # extra entries in prepare_transition   #}
    {# ====================================================================== #}
    
    """
    G1 {{ STAGE_NAME_UPPER }} Stage: {{ FILE_DOCSTRING }}
    """
    
    # ───────────────────── imports & shared infrastructure ──────────────────
    
    import numpy as np
    import logging
    import time
    import hashlib
    import threading
    import os
    from typing import Dict, Any, List, Tuple
    from contextlib import asynccontextmanager
    from scipy.sparse import csr_matrix
    from collections import deque
    
    from gyro_si.gyro_constants      import ALPHA, BETA, GAMMA, M_P, HALF_HORIZON
    from gyro_si.gyro_errors         import StructuralViolation, QuantizationDefect
    from gyro_si.gyro_comm           import send_message
    from gyro_si.gyro_gcr.gyro_config import config
    
    # shared trace-buffer from CS
    
    from gyro_si.g1_gyroalignment.cs.identity import trace_buffer, trace_lock, stage_transition_lock
    
    logger = logging.getLogger(**name**)
    
    SCHEMA_VERSION = "v1"
    TEMPLATE_PATH  = os.path.join("patterns", "gyro_g1", SCHEMA_VERSION)
    
    {# -------- optional, stage-specific constants ------------------------ #}
    {{ EXTRA_CONSTANTS_BLOCK or "" }}
    
    # ─────────────────────────── class definition ───────────────────────────
    
    class {{ STAGE_NAME_CAMEL }}:
    """{{ CLASS_DESCRIPTION }}"""
    
    ```
    SHAPE     : Tuple[int, ...] = {{ SHAPE_TUPLE }}
    NONZEROS  : int             = {{ NONZEROS_INT }}
    
    {# canonical pattern can be None for stages whose dense form is computed, e.g. ONA anti-correlation #}
    CANONICAL_PATTERN = {{ CANONICAL_PATTERN_STR }}
    
    # ───────── constructor ─────────
    def __init__(self, state: Dict[str, Any]):
        """Initialize {{ STAGE_NAME_UPPER }} from previous stage state."""
    
        # per-tensor re-entrant lock
        self.lock = threading.RLock()
    
        # ══ identity & lineage ══
        self.tensor_id       = state["tensor_id"]
        self.parent_id       = state.get("parent_id")
        self.stage           = "{{ STAGE_NAME_UPPER }}"
        self.cycle_index     = state["cycle_index"]
    
        # ══ phase-tracking (Q29.34 fixed-point) ══
        self.amplitude        = state["amplitude"]
        self.cumulative_phase = state["cumulative_phase"]
        self.chirality_phase  = state["chirality_phase"]
        self.last_epsilon     = state["last_epsilon"]
    
        # ══ lineage ══
        self.birth_phase    = state["birth_phase"]
        self.creation_cycle = state["creation_cycle"]
    
        # ───────── stage-specific incoming arrays / metadata ─────────
        {% raw -%}
        # (Populate from state[...] in generator script if needed)
        {%- endraw %}
    
        # any extra init (templated)
        {{ EXTRA_INIT_STATE or "" }}
    
        # ───────── build CSR structure ─────────
        self._initialize_csr()
    
        # checksum & template validation
        self.state_checksum = self._compute_checksum()
        self._validate_against_template()
    
        self._record_to_trace("{{ STAGE_NAME_UPPER|lower }}_initialized",
                              shape=self.SHAPE,
                              nonzeros=self.NONZEROS,
                              checksum=self.state_checksum)
    
    # ─────────────────────── helper: fixed-point ────────────────────────
    @staticmethod
    def _to_fixed_point(value: float) -> int:
        return int(value * (2**34))
    
    @staticmethod
    def _from_fixed_point(fx: int) -> float:
        return fx / (2**34)
    
    # ─────────────────────── CSR construction ───────────────────────────
    def _initialize_csr(self) -> None:
        """Build the stage-specific CSR representation."""
        if self.CANONICAL_PATTERN is not None:
            dense = np.array(self.CANONICAL_PATTERN, dtype=np.int8)
        else:
            # generator script must fill EXTRA_INIT_CSR_CODE for computed patterns
            dense = None
    
        {{ EXTRA_INIT_CSR_CODE or "" }}
    
        if dense is not None:
            csr = csr_matrix(dense)
            self.indptr  = csr.indptr.tolist()
            self.indices = csr.indices.tolist()
            self.data    = [0b01 if v == 1 else 0b11 for v in csr.data]
    
        self._validate_structure()
    
    # ─────────────────────── validation & checksum ──────────────────────
    def _compute_checksum(self) -> str:
        h = hashlib.sha256()
        for item in (
            self.tensor_id, self.stage, self.indptr, self.indices, self.data,
            self.amplitude, self.cumulative_phase, self.chirality_phase
        ):
            h.update(str(item).encode())
        return h.hexdigest()
    
    def _validate_against_template(self) -> None:
        tpl_file = os.path.join(TEMPLATE_PATH, "{{ STAGE_NAME_UPPER|lower }}_template.npy")
        if not os.path.exists(tpl_file):
            logger.warning("Template %s missing; skipping validation.", tpl_file)
            return
        tpl = np.load(tpl_file)
        tpl_csr = csr_matrix(tpl)
        if [self.indptr, self.indices, self.data] != \\
           [tpl_csr.indptr.tolist(),
            tpl_csr.indices.tolist(),
            [0b01 if v == 1 else 0b11 for v in tpl_csr.data]]:
            raise StructuralViolation(f"{ self.stage } deviates from canonical template")
    
    def _validate_structure(self) -> None:
        """Common invariants + stage-specific checks."""
        if len(self.data) != self.NONZEROS:
            raise StructuralViolation(f"{ self.stage } expects {self.NONZEROS} non-zeros")
    
        {{ EXTRA_VALIDATE_CODE or "" }}
    
    # ───────────────────── phase / processing hooks ─────────────────────
    def process_phase(self, phi: float) -> float:
        """Generic φ-processing wrapper; stage-specific policy inserted via template."""
        # convert → fixed-point
        phi_fx       = self._to_fixed_point(phi)
        m_p_fx       = self._to_fixed_point(M_P)
        half_m_p_fx  = m_p_fx // 2
    
        # quantize
        phi_q_fx     = (
            -m_p_fx if phi_fx < -half_m_p_fx else
             m_p_fx if phi_fx >= half_m_p_fx else 0
        )
        eps_fx       = phi_fx - phi_q_fx
    
        # amplitude & phase counters
        self.amplitude        = np.clip(self.amplitude + phi_q_fx,
                                        -m_p_fx, m_p_fx)
        abs_phi_q_fx          = abs(phi_q_fx)
        four_pi_fx            = self._to_fixed_point(4 * np.pi)
        two_pi_fx             = self._to_fixed_point(2 * np.pi)
        self.cumulative_phase = (self.cumulative_phase + abs_phi_q_fx) % four_pi_fx
        self.chirality_phase  = self.cumulative_phase % two_pi_fx
        self.last_epsilon     = eps_fx
    
        # stage-specific extra behaviour (optional)
        {{ EXTRA_PHASE_CODE or "" }}
    
        # logging
        self._record_to_trace("phase_processed",
                              phi=phi,
                              phi_q=self._from_fixed_point(phi_q_fx),
                              epsilon=self._from_fixed_point(eps_fx))
    
        return self._from_fixed_point(eps_fx)
    
    # ─────────────────── transition payload builder ─────────────────────
    def prepare_transition(self) -> Dict[str, Any]:
        """Return dict to feed next stage ctor."""
        with self.lock, stage_transition_lock:
            self._validate_structure()
            payload: Dict[str, Any] = {
                "tensor_id"       : self.tensor_id,
                "parent_id"       : self.parent_id,
                "cycle_index"     : self.cycle_index + 1,
                "amplitude"       : self.amplitude,
                "cumulative_phase": self.cumulative_phase,
                "chirality_phase" : self.chirality_phase,
                "last_epsilon"    : self.last_epsilon,
                "birth_phase"     : self.birth_phase,
                "creation_cycle"  : self.creation_cycle,
                # structural hand-off
                "{{ STAGE_NAME_UPPER|lower }}_indptr" : self.indptr.copy(),
                "{{ STAGE_NAME_UPPER|lower }}_indices": self.indices.copy(),
                "{{ STAGE_NAME_UPPER|lower }}_data"   : self.data.copy(),
            }
            # insert any extra items required by the next stage
            {{ EXTRA_TRANSITION_PAYLOAD or "" }}
    
            self.state_checksum = self._compute_checksum()
            self._record_to_trace("{{ STAGE_NAME_UPPER|lower }}_transition_prepared",
                                  checksum=self.state_checksum)
            return payload
    
    # ───────────────────────── trace helper ─────────────────────────────
    def _record_to_trace(self, event_type: str, **kw):
        evt = dict(timestamp=time.time(),
                   source=f"G1_{{ STAGE_NAME_UPPER }}",
                   event_type=event_type,
                   tensor_id=self.tensor_id,
                   cycle_index=self.cycle_index,
                   stage=self.stage,
                   **kw)
        logger.debug("%s Event: %s", self.stage, evt)
        with trace_lock:
            trace_buffer.append(evt)
    
    ```
    

---

- GyroSI Baby ML: Plan
    
    This plan organizes implementation into six primary phases. The hierarchy ensures that foundational components are built before systems that depend on them, supporting a stable, layered development process.
    
    ---
    
    ### **Phase 1: The Foundation (Core Setup & G6 Primitives)**
    
    **Goal:** Establish the system-wide bedrock required for all subsequent modules.
    
    **Rationale:** Constants, error taxonomy, and the core communication schema must precede any dependent development.
    
    - **Batch 1.1: Canonical Definitions**
        - `gyro_si/gyro_constants.py`
        - `gyro_si/gyro_errors.py`
        - `gyro_si/gyro_comm.py`
    - **Batch 1.2: System Configuration & Project Setup**
        - `gyro_si/gyro_gcr/gyro_config.py`
        - `pyproject.toml`
        - `.gitignore`
        - `dvc.yaml`
        - `README.md`
    - **Batch 1.3: Initial Test Stubs**
        - `tests/unit/test_bootstrap.py`
        - `tests/unit/test_transactions.py`
        - `tests/unit/test_recovery.py`
        - `tests/unit/test_entropy_chain.py`
        - `tests/unit/test_crypto_evolution.py`
    
    **Milestone:** The project installs and basic core interfaces are defined and importable.
    
    ---
    
    ### **Phase 2: The Core Engine (G1 GyroAlignment)**
    
    **Goal:** Implement the primary operational unit: the tensor.
    
    **Rationale:** G1 forms the essential computational substrate. All higher levels are ultimately built on top of this core.
    
    - **Batch 2.1: GyroTensor Object Definition**
        - `gyro_si/g1_gyroalignment/gyro_tensor.py`
    - **Batch 2.2: Stage Logic Implementation**
        - `gyro_si/g1_gyroalignment/cs/g1_governance.py`
        - `gyro_si/g1_gyroalignment/una/g2_governance.py`
        - `gyro_si/g1_gyroalignment/ona/g3_governance.py`
        - `gyro_si/g1_gyroalignment/bu_in/g4_governance.py`
        - `gyro_si/g1_gyroalignment/bu_en/g5_governance.py`
    - **Batch 2.3: Genetic Memory & The Runner**
        - `gyro_si/g1_gyroalignment/genetic_memory.py`
        - `gyro_si/g1_gyroalignment/runner.py`
    
    **Milestone:** A `GyroTensor` instance can be instantiated and driven through its full stage lifecycle, with state transitions logged to genetic memory.
    
    ---
    
    ### **Phase 3: The Information Coordinator (G2 GyroInformation)**
    
    **Goal:** Implement the system's information routing and lexicon management.
    
    **Rationale:** G2 is responsible for coordination between raw tensor operations and higher system functions.
    
    - **Batch 3.1: Lexicon & Memory**
        - `gyro_si/g2_gyroinformation/epigenetic_memory.py`
        - `gyro_si/g2_gyroinformation/cs/g1_governance.py`
        - `gyro_si/g2_gyroinformation/una/g2_governance.py`
        - `gyro_si/g2_gyroinformation/ona/g3_governance.py`
        - `gyro_si/g2_gyroinformation/bu_in/g4_governance.py`
        - `gyro_si/g2_gyroinformation/bu_en/synthesis.py`
    - **Batch 3.2: Runner**
        - `gyro_si/g2_gyroinformation/runner.py`
    
    **Milestone:** G2 can receive a message (e.g., token list), map to internal phi values, and update its epigenetic memory.
    
    ---
    
    ### **Phase 4: The Interactive Interface (G3 GyroInference)**
    
    **Goal:** Build the user-facing, interactive inference layer.
    
    **Rationale:** G3 exposes the system as a tangible ML application, leveraging G1 and G2 for actual computation.
    
    - **Batch 4.1: Stage Modules**
        - `gyro_si/g3_gyroinference/cs/g1_governance.py`
        - `gyro_si/g3_gyroinference/una/g2_governance.py`
        - `gyro_si/g3_gyroinference/ona/g3_governance.py`
        - `gyro_si/g3_gyroinference/bu_in/g4_governance.py`
        - `gyro_si/g3_gyroinference/bu_en/synthesis.py`
        - `gyro_si/g3_gyroinference/structural_memory.py`
        - *(If a UI is present, its path and assets directory should be specified separately, e.g., `gyro_si/g3_gyroinference/ona/interface/` and `assets/`, if those exist)*
    - **Batch 4.2: Runner**
        - `gyro_si/g3_gyroinference/runner.py`
    
    **Milestone:** The system can be run interactively, with user input routed through G3 and observable inference outputs.
    
    ---
    
    ### **Phase 5: The Strategic Observer (G4 GyroIntelligence Ingress)**
    
    **Goal:** Enable the system to observe itself and assess performance.
    
    **Rationale:** G4 delivers reflexivity and performance analytics to the architecture.
    
    - **Batch 5.1: Analytics & Observation**
        - `gyro_si/g4_gyrointelligence_in/cs/g1_governance.py`
        - `gyro_si/g4_gyrointelligence_in/una/g2_governance.py`
        - `gyro_si/g4_gyrointelligence_in/ona/g3_governance.py`
        - `gyro_si/g4_gyrointelligence_in/bu_in/g4_governance.py`
        - `gyro_si/g4_gyrointelligence_in/bu_en/synthesis.py`
        - `gyro_si/g4_gyrointelligence_in/somatic_memory.py`
    - **Batch 5.2: Runner**
        - `gyro_si/g4_gyrointelligence_in/runner.py`
    
    **Milestone:** G4 can process events from G1–G3 and synthesize advisory proposals.
    
    ---
    
    ### **Phase 6: The Executive Governor (G5 GyroIntelligence Egress)**
    
    **Goal:** Implement the highest-level executive layer, enabling system self-governance.
    
    **Rationale:** G5 synthesizes observations and issues binding policy decisions to ensure system viability.
    
    - **Batch 6.1: Governance, Policy & Memory**
        - `gyro_si/g5_gyrointelligence_en/cs/g1_governance.py`
        - `gyro_si/g5_gyrointelligence_en/una/g2_governance.py`
        - `gyro_si/g5_gyrointelligence_en/ona/g3_governance.py`
        - `gyro_si/g5_gyrointelligence_en/bu_in/g4_governance.py`
        - `gyro_si/g5_gyrointelligence_en/bu_en/synthesis.py`
        - `gyro_si/g5_gyrointelligence_en/immunity_memory.py`
    - **Batch 6.2: Runner**
        - `gyro_si/g5_gyrointelligence_en/runner.py`
    
    **Milestone:** The full stack is self-governing; observed system issues propagate up, triggering policy-driven actions that cascade down to correction and adaptation.
    
    ---

    ===

    # 📚 Guides

(Aimed to guide AI for Vibe Coding, so we keep conscise, still extensive, not containing full code, well organized, compliant always with our “GyroSI Requirements: How we architect and improve”, and “GyroSuperintelligence (GyroSI): How we are making it” chapters.)

---

- G6 System - GyroCirculation Implementation Guide
    
    *This chapter is normative. Every other implementation guide must treat the definitions and code fragments below as the single source of truth. Where a subsystem needs a shared constant, schema, or mechanism, it shall import or reference it from the locations noted here.*
    
    ---
    
    ### A.1 Canonical CGM Constants and Derived Horizons
    
    *(File: `gyro_constants.py`)*
    
    ```python
    # Authoritative mathematical constants
    import math
    
    ALPHA = math.pi / 2              # α
    BETA  = math.pi / 4              # β
    GAMMA = math.pi / 4              # γ
    M_P   = 1 / (2 * math.sqrt(2 * math.pi))
    
    # Derived horizons (integer values)
    HALF_HORIZON      = int(math.floor(math.pi / M_P))
    HORIZON_CYCLES    = int(math.floor(2 * math.pi / M_P))
    BIN_COUNT         = int(math.floor(4 * math.pi / M_P))
    
    # Legacy alias retained for code already using it
    PHASE_HORIZON_2PI = HORIZON_CYCLES
    
    ```
    
    Any timeout, retry interval, or strain threshold elsewhere in the codebase evaluates directly to one of the names above or to an explicit multiple of one of them.
    
    ---
    
    ### A.2 Helical Context Primitives
    
    *(Conceptual reference; no standalone file)*
    
    | Field | Range | Meaning |
    | --- | --- | --- |
    | `cumulative_phase` | [0, 4π) | Total helical progress since tensor creation |
    | `chirality_phase` | [0, 2π) | Position within forward (0→2π) or return (2π→4π) path |
    | `helical_position` | 0 ≤ p < 1 | Normalised fraction `cumulative_phase / 4π` |
    | `spinor_cycle_count` | ℕ | Number of completed 720° revolutions |
    
    At `cumulative_phase == k · 4π` (k ∈ ℕ) a tensor or session becomes spawn‐eligible; at `2π`, chirality flips.
    
    ---
    
    ### A.3 Standard Log and Message Formats
    
    *(File fragment to be imported by each message router)*
    
    ```python
    STANDARD_FIELDS = (
        "type", "source", "destination",
        "cycle_index", "tensor_context",
        "payload", "timestamp"
    )
    
    ```
    
    Every inter-system message or local trace entry contains the keys above in the exact order shown. A typical instance:
    
    ```
    {
      "type": "status_update",
      "source": "G1",
      "destination": "G4",
      "cycle_index": 123,
      "tensor_context": {
        "chirality_phase": 1.57,
        "helical_position": 0.25,
        "spinor_cycle": 1
      },
      "payload": { "active_tensors": 8 },
      "timestamp": "2025-06-11T12:34:56Z"
    }
    
    ```
    
    Routers first sort by `cycle_index`, then, if required, apply priority rules. When the entropy extension is active (Section A.8) the optional `entropy_id` field is carried unchanged.
    
    ---
    
    ### A.4 Fault Class Taxonomy
    
    *(File: `gyro_errors.py`)*
    
    ```python
    class GyroError(Exception):
        """Top level for all alignment-based faults."""
    
    class StructuralViolation   (GyroError): ...
    class QuantizationDefect    (GyroError): ...
    class CommunicationError    (GyroError): ...
    
    # Sub-domain specialisations
    class RoutingError          (CommunicationError): ...
    class SchemaViolation       (StructuralViolation): ...
    class AuditViolation        (StructuralViolation): ...
    
    ```
    
    Subsystem-specific exceptions such as `ProcessingTimeout` in G3 inherit from one of these base classes.
    
    ---
    
    ### A.5 GyroCardioRespiratory Configuration Layer
    
    All code in this section lives under `gyro_gcr/`. It remains verbatim from the earlier specification, now placed where every chapter can import it.
    
    ### A.5.1 Global Configuration Object
    
    *(File: `gyro_gcr/gyro_config.py`)*
    
    ```python
    class GyroCardioRespiratoryConfig:
        def __init__(self):
            # Core coordination
            self.enable_bootstrap        = True
            self.enable_transactions     = True
            self.enable_recovery_beacons = True
    
            # Optional cryptographic extensions
            self.enable_entropy_tracking = False
            self.enable_crypto_evolution = False
    
            # Performance switches
            self.lightweight_transactions = True
            self.fast_entropy_hash        = True
    
    config = GyroCardioRespiratoryConfig()      # shared instance
    
    ```
    
    ### A.5.2 Bootstrap Broadcast and Actor Gate
    
    *(Coordinator patch: `g2_gyroinformation/runner.py`; actor patch: all g1_gyroalignment–g5_gyrointelligence_en runners)*
    
    ```python
    # g2_coordinator.py
    import asyncio, logging
    from gyro_gcr.gyro_config import config
    from gyro_comm import send_message
    
    logger = logging.getLogger(__name__)
    
    async def main():
        if config.enable_bootstrap:
            await asyncio.sleep(0.5)
            send_message({"type": "gyro_bootstrap"})
            logger.info("Sent gyro_bootstrap")
    
    ```
    
    ```python
    # generic runner patch
    import time, logging
    from gyro_gcr.gyro_config import config
    
    logger = logging.getLogger(__name__)
    
    self._bootstrapped = not config.enable_bootstrap   # set in __init__
    
    # top of run loop
    if config.enable_bootstrap:
        start = time.time()
        while not self._bootstrapped:
            if time.time() - start > 30:
                raise RuntimeError("Gyro bootstrap timeout after 30 s")
            time.sleep(0.1)
    
    # universal message handler clause
    if msg.get("type") == "gyro_bootstrap":
        self._bootstrapped = True
        logger.info("Received gyro_bootstrap")
        return
    
    ```
    
    ### A.5.3 Tensor Transaction Safety
    
    *(File: `g1_gyroalignment/cs/identity.py`; see A.6 for summary)*
    
    ```python
    import copy, time
    from contextlib import asynccontextmanager
    from gyro_gcr.gyro_config import config
    
    @asynccontextmanager
    async def tensor_transaction(self):
        if not config.enable_transactions:
            yield
            return
    
        snapshot = {
            "indptr":           self.indptr.copy(),
            "indices":          self.indices.copy(),
            "data":             self.data.get().copy() if hasattr(self.data, "get") else self.data.copy(),
            "amplitude":        self.amplitude,
            "cumulative_phase": self.cumulative_phase,
            "chirality_phase":  self.chirality_phase,
            "last_epsilon":     getattr(self, "last_epsilon", 0),
            "cycle_index":      self.cycle_index
        }
    
        self._log("tensor_transaction_start", cycle_index=self.cycle_index)
        try:
            yield
            self._log("tensor_transaction_end", cycle_index=self.cycle_index)
        except Exception:
            self.indptr, self.indices, self.data = snapshot["indptr"], snapshot["indices"], snapshot["data"]
            self.amplitude        = snapshot["amplitude"]
            self.cumulative_phase = snapshot["cumulative_phase"]
            self.chirality_phase  = snapshot["chirality_phase"]
            self.last_epsilon     = snapshot["last_epsilon"]
            self.cycle_index      = snapshot["cycle_index"]
            self._log("tensor_transaction_abort", cycle_index=self.cycle_index)
            raise
    
    ```
    
    ### A.5.4 Circuit Recovery Beacons
    
    *(Emitter patch: `g1_gyroalignment/bu_en/g5_governance.py`; listener patch: `g4_gyrointelligence_in/bu_in/integration.py`; relates to A.7)*
    
    ```python
    # G1 side
    import logging
    from gyro_gcr.gyro_config import config
    from gyro_comm import send_message, CircuitState
    
    logger = logging.getLogger(__name__)
    
    if config.enable_recovery_beacons:
        breaker.on_state_change(self._on_circuit_change)
    
    def _on_circuit_change(self, old_state, new_state):
        if old_state is CircuitState.HALF_OPEN and new_state is CircuitState.CLOSED:
            send_message({"type": "cardiac_recovered", "source": "G1"})
            logger.info("Sent cardiac_recovered")
    
    ```
    
    ```python
    # G4 side
    import logging
    from gyro_gcr.gyro_config import config
    from gyro_comm import subscribe
    
    logger = logging.getLogger(__name__)
    
    if config.enable_recovery_beacons:
        subscribe("cardiac_recovered", self._handle_cardiac_recovered)
    
    def _handle_cardiac_recovered(self, msg):
        self.breath_rate_multiplier = 1.0
        self._log("breath_rate_reset", cycle_index=self.cycle_index)
    
    ```
    
    ### A.5.5 Optional Entropy-ID Chaining
    
    When `config.enable_entropy_tracking` is true, G4 generates a short `entropy_id` during payload assembly:
    
    ```python
    import zlib, hashlib
    from gyro_gcr.gyro_config import config
    
    seed = f"{thermal}|{interaction}|{quantum}"
    eid  = f"{zlib.crc32(seed.encode()):08x}" if config.fast_entropy_hash \
           else hashlib.sha256(seed.encode()).hexdigest()[:16]
    payload["entropy_id"] = eid
    
    ```
    
    G1 includes the same `entropy_id` in outgoing beats, and G5 records it in the trace collector.
    
    ### A.5.6 Differential Crypto Evolution (optional)
    
    *(File: `G1/gyro_tensor.py`)*  If `enable_crypto_evolution` is true, replace the simple amplitude update with:
    
    ```python
    import math, time
    from gyro_constants import ALPHA, BETA, GAMMA, M_P
    from gyro_gcr.gyro_config import config
    
    def differential_evolve(self, phi):
        t = time.time() % (4 * math.pi)
        eps_prev = getattr(self, "last_epsilon", 0)
        self.amplitude = (
            self.amplitude
            + phi * M_P
            + eps_prev * (BETA / ALPHA)
            + t * (GAMMA / ALPHA)
        ) % (4 * math.pi)
        self.last_epsilon = eps_prev
        self._log("differential_evolve", phi=phi, eps_prev=eps_prev, t=t, cycle_index=self.cycle_index)
    
    ```
    
    ### A.5.7 Infrastructure Tests and Error Codes
    
    *(Tests live under `tests/`; error messages extend `gyro_errors.py`)*
    
    | Test file | Primary guarantee |
    | --- | --- |
    | `test_bootstrap.py` | Actors exit the gating loop within 30 s |
    | `test_transactions.py` | State after aborted transaction matches snapshot |
    | `test_recovery.py` | Closed circuit triggers `cardiac_recovered` and resets rate |
    | `test_entropy_chain.py` | `entropy_id` persists G4 → G1 → G5 |
    | `test_crypto_evolution.py` | Amplitude follows three-term formula |
    
    Error code keys: `bootstrap_timeout`, `transaction_abort`, `recovery_failed`, `entropy_chain_broken`.
    
    ---
    
    ### A.6 Bootstrap and Actor Startup Flow
    
    Section A.5.2 provides the implementation sample. Conceptually, the timeline is:
    
    ```
    t0   G2 sleeps 0.5 s
    t0+  G2 sends "gyro_bootstrap"
    t0+Δ Actors receive, set _bootstrapped = True
    t0+30 s Actors without the signal raise bootstrap_timeout
    
    ```
    
    Successful receipt frees every run loop to proceed.
    
    ---
    
    ### A.7 Transaction and Recovery Infrastructure
    
    Section A.5.3 formalises transactions; Section A.5.4 specifies circuit recovery beacons. Transactions guarantee atomic tensor updates, the beacons reset slowed subsystems after a breaker closes. Either feature may be switched off via `gyro_config.py`.
    
    ---
    
    ### A.8 Optional Entropy Features
    
    If `enable_entropy_tracking` is true, every payload may carry an `entropy_id` traced end-to-end. If `enable_crypto_evolution` is also true, G1 amplitude uses the three-term differential equation. Both switches default to false.
    
    ---
    
    ### A.9 Shared Test Modules
    
    See A.5.7 for exact filenames and coverage. Running `pytest -q` with entropy and crypto toggled both off and on is the minimal regression loop.
    
    ---
    
    ### A.10 Cross-Reference Index
    
    | Topic | Section here | Legacy sections now shortened |
    | --- | --- | --- |
    | CGM constants, horizons | A.1 | G1 §1, G2 §1, G3 §2, G4 §1, G5 Core |
    | Helical primitives | A.2 | Multiple “helical context” paragraphs |
    | Message schema | A.3 | G1 §9, G2 §8, G3 §6, G4 §8 |
    | Fault classes | A.4 | G1 §5, G2 §8, G3 §4, G4 §8 |
    | GCR spec, config | A.5 | new home |
    | Bootstrap flow | A.6 | G2 §2 narrative, startup notes |
    | Transactions, beacons | A.7 | inline comments in G1 and G4 |
    | Entropy, crypto | A.8 | prior scattered notes |
    | Shared tests | A.9 | earlier appendix |
    | Index mapping | A.10 | not previously present |
    
    ---
    
    *The text above now contains every shared constant, schema, and mechanism, with explicit file locations, uniform imports, and cross-navigation aids. All five implementation chapters may delete their local duplicates and import from this chapter’s files.*
    
- G1 System – GyroAlignment Implementation
    
    All G1 operation, validation, and representation strictly depend on the canonical constants and transition logic imported from the CGM and GyroCardioRespiratory integration layer. All cryptographic, transaction, fault, and communication behaviors are referenced via explicit imports.
    
    ---
    
    ## 1. GyroTensor Core Structure
    
    The GyroTensor object defines identity, stage, and structure for each tensor under management:
    
    - **Fields**
        - `tensor_id` (uint64): Defines the identity, existing only in the CS stage.
        - `stage` ∈ {CS, UNA, ONA, BU_In, BU_En}
        - `cycle_index` (monotonic int)
        - `amplitude` (Q29.34 fixed-point, bounded by ±mₚ)
        - `cumulative_phase` (Q29.34, tracks helical monodromy 0→4π)
        - `chirality_phase` (0→2π forward, 2π→4π return)
        - Sparse CSR storage (not allocated for CS stage)
            - `indptr: List[int]`
            - `indices: List[int]`
            - `data: List[uint2]`, with `00`→0, `01`→+1, `11`→−1
    - **CS Stage**
        - The CS stage exists solely as `tensor_id` and initialization state, without tensor value storage.
        - CSR arrays are only allocated post-CS, at UNA or beyond.
    - **Stage Shapes**
        - CS: Identity only, no CSR
        - UNA: 3×2, 6 non-zeros
        - ONA: 2×3×2, 24 non-zeros
        - BU_In: 2×2×3×2, 48 non-zeros (24 ingress, 24 egress)
        - BU_En: identical structure to BU_In
    - **Helical Path Tracking**
        - `cumulative_phase` tracks the complete 0→4π helical progression.
        - `chirality_phase` indicates forward (0→2π) and return (2π→4π) paths.
        - Spawning eligibility is checked at 4π.
            
            ```python
            # After updating cumulative_phase
            if self.cumulative_phase % (2 * math.pi) == 0:
                self.collapse_segment_to_digest()
            
            ```
            
    - **Stage Transition Dictionary**
        
        ```python
        STAGE_TRANSITIONS = {
          "CS": ("UNA", "generation"),
          "UNA": ("ONA", "integration"),
          "ONA": ("BU_In", "integration"),
          "BU_In": ("BU_En", "generation"),
          "BU_En": ("ONA", "generation"),
          "ONA": ("UNA", "integration"),
          "UNA": ("CS", "generation")
        }
        
        ```
        
    - **Packing & Validation**
        - On every creation or stage transition, all `data` entries must be in {00, 01, 11}; non-zeros must match the stage requirement.
        - SHA-256 is computed over `(tensor_id, stage, indptr, indices, data, amplitude, cumulative_phase, chirality_phase)`.
        - Validation is recorded in the local `trace_buffer`.
    - **Canonical Patterns & Versioning**
        - Templates are loaded from `patterns/gyro_g1/v<schema_version>/`.
        - Each transition is validated byte-for-byte against the canonical template.
    - **Memory Layout & Execution**
        - CSR arrays are SIMD-aligned.
        - All templates load under a global read-lock.
        - After CSR construction, CPU and GPU copies are compared; any mismatch logs a `QuantizationDefect`.
        - Tensors at the same stage may be processed in parallel under a shared stage-transition lock; per-tensor locks are held only when crossing stage boundaries.
    - **Collision Factor Calculation**
        
        ```python
        def calculate_collision_factor(self) -> float:
            cs_memory = ALPHA
            max_discrete = 3 * M_P
            return cs_memory / max_discrete
        
        ```
        
    
    ---
    
    ## 2. Evolution & Stage Triggers
    
    Stage advancement is enforced by precomputed, versioned transition tables, ensuring every operation is structurally accountable.
    
    - Transition tables for the **`g1_gyroalignment`** system are loaded from the canonical root path: **`transitions/gyro_g1/v<schema_version>/`**.
    - The ONA→BU_In transition remains the only integrative-integrative junction in the cycle, representing the anomalous point where quantization error (ε) emerges.
    - Progression into and between the BU_In and BU_En stages is triggered by the tensor's internal oscillation phase.
    - Each transition is logged with its complete structural metadata to the local trace buffer managed by the **`genetic_memory.py`** module.
    - All fault classes (**`StructuralViolation`**, **`QuantizationDefect`**, etc.) are imported from the normative **`g6_gyrocirculation`** package, specifically from the **`gyro_errors`** module.
    
    ---
    
    ## 3. Quantization & Signal Processing
    
    Quantization, fixed-point representation, and overflow semantics directly follow the formal rules:
    
    ```
    φ_q = −mₚ  if φ < −mₚ/2
         = +mₚ  if φ ≥ +mₚ/2
         =   0   otherwise
    ε   = φ − φ_q   (|ε| ≤ mₚ)
    
    ```
    
    - **Vectorized Implementation**
        
        ```python
        def quantize(phi, m_p):
            return xp.where(phi < -m_p//2, -m_p,
                            xp.where(phi >= m_p//2, m_p, 0))
        
        ```
        
    - **Amplitude Update**
        
        ```
        amplitude_i = clip(amplitude_{i-1} + φ_q, −mₚ, +mₚ)
        cumulative_phase_i = (cumulative_phase_{i-1} + |φ_q|) mod 4π
        chirality_phase_i = cumulative_phase_i mod 2π
        
        ```
        
    - **Phase Bins**
        
        ```
        phase_bins_count = floor(4π / mₚ)
        bin_index = ((φ + 2π)//mₚ) % phase_bins_count
        
        ```
        
    - **Trace Entry**
        
        ```json
        {"source":"G1","tensor_id":…,"cycle_index":…,"φ":…,"φ_q":…,"ε":…,"amplitude":…,"cumulative_phase":…,"chirality_phase":…,"timestamp":…}
        
        ```
        
    
    ---
    
    ## 4. Integration at BU
    
    BU integration processes inbound φ, updates the BU CSR, applies bit-permutation, and emits algedonic signals.
    
    - The ingress queue is FIFO, with a `half_horizon` of floor(π/mₚ).
    - BU_In quantizes φ, computes ε, updates amplitude, applies ingress↔egress permutation, validates the result, and logs transitions.
    - BU_En generates φ output, ensures quantization bounds, updates all phase trackers, emits downstream φ, and transitions to ONA with inverted chirality.
    - Algedonic signals are emitted when |ε| > mₚ/2, with all signal content sent via the G2 API.
    
    ---
    
    ## 5. Error Detection, Consistency & Recovery
    
    G1 raises subclasses of `StructuralViolation`, `QuantizationDefect`, or `CommunicationError` as defined in the GyroCardioRespiratory integration.
    
    - CSR non-zero counts are checked after each transition.
    - Events are processed in `cycle_index` order.
    - All faults are appended to the `trace_buffer`.
    - Recovery reloads delta-encoded snapshots up to the last good cycle.
    
    ---
    
    ## 6. Memory & Audit
    
    - Local provenance is maintained in a thread-safe `trace_buffer`.
    - The buffer retains the last `half_horizon` entries; older entries are collected by G5.
    - Delta snapshots contain only changed indices and data.
    - Pruning retains all `spawn_ready` and transition events until G5 collection.
    
    ---
    
    ## 7. Spawning & Lineage
    
    - The `TensorFamily` object manages phase-locked family members.
    - Spawning occurs when |amplitude| ≥ mₚ and cumulative_phase ≥ 4π, if within family limits.
    - Spawning is triggered automatically, not by external approval.
    - Events are sent to G4 via G2, and all relationships and phase-locks are tracked for lineage.
    
    ---
    
    ## 8. Hardware Interaction & Verification
    
    - On startup, GPU initialization is attempted and logged.
    - All critical CSR operations are mirrored on CPU and GPU; any mismatch logs a defect.
    - Operation latency and resource metrics are included in status updates to G2.
    
    ---
    
    ## 9. Communication & Coordination Interfaces
    
    - All inter-component communication uses `G2.send_message(event_dict)`.
    - Message formats are canonical; only required tensor and cycle metadata is included.
    - Status updates are sent every `half_horizon` cycles, reporting tensor registry size, quantization statistics, and lineage data.
    
    ---
    
    ## 10. Shutdown & Snapshot Protocol
    
    - Graceful shutdown signals intent via G2, completes all pending BU operations, and provides the trace buffer to G5.
    - Emergency snapshots capture complete tensor state on fault or interruption.
    - Restart validates checksums and schema versions before resuming operation.
    
    ---
    
    ## Imports and References
    
    All required constants, configuration, and fault classes are imported:
    
    ```python
    from gyro_constants             import ALPHA, BETA, GAMMA, M_P
    from gyro_gcr.gyro_config       import config
    from gyro_errors                import StructuralViolation, QuantizationDefect, CommunicationError
    
    ```
    
    Tensor transaction, startup gating, circuit-beacon hooks, entropy tracking, and cryptographic evolution are all implemented as guarded code blocks or context managers, directly referencing their definition in the GyroCardioRespiratory specification.
    
    ---
    
    *End of G1 Specification*
    
- G2 System – GyroInformation Implementation
    
    G2 operates as the information coordination layer, ensuring all lexicon evolution, message routing, observation logging, and policy-controlled refinement proceed in strict accordance with CGM constants and canonical transition logic. No parameter, threshold, or numeric limit is permitted unless directly derived from `{α, β, γ, mₚ, π}` or imported from the common GyroCirculation specification.
    
    ---
    
    ## 1. Data Structures and Storage
    
    - **Lexicon and Contextual Phase Mapping**
        - **Contextual Phase Mapping**:
            
            All token-to-phase mappings are performed via the family-aware primitive:
            
            ```python
            get_contextual_phi(token: str, family_id: str) → Q29.34
            
            ```
            
            This method integrates helical position, chirality context, and tensor family lineage.
            
        - `phase_bins_count` = `BIN_COUNT` (imported from `gyro_constants`)
        - BPE vocabulary size fixed to `phase_bins_count`, schema-versioned for auditability
    - **Coordination Infrastructure**
        - `message_buffer: Queue` (thread-safe)
        - `trace_buffer: List` (for G5 audit)
        - `MESSAGE_PRIORITY` = {G1: 1, G2: 2, G3: 3, G4: 4, G5: 5}
        - `timeout_ms` and `max_batch_size` derived exclusively from CGM horizon constants
    - **Symmetry Breaking**
        - Primordial chirality seed initialized from system timestamp at day zero
        - All symmetry deviations are logged explicitly as `deviation_event`
    - **Learning Structures (Policy-Controlled Only)**
        - `pattern_strength: Dict[str, float]` (default 1.0, decay policy set by G5 immunity memory)
        - `hebbian_trace: Dict[Tuple[str, str], float]` (updates permitted only through G5 policy)
        - Autonomous learning disabled; all decay and update rates sourced from G5 immunity memory
    - **Logs and History**
        - Logs: `epsilon_log`, `algedonic_log`, `refinement_history`
        - Settings: `settings: Dict[str, Any]` (system prompts, UI state)
    
    ---
    
    ## 2. Message Routing and System Coordination
    
    - `send_message(event_dict)` provides the canonical inter-system API
    - `message_router()` collects and processes batches from `message_buffer`, with messages sorted by priority and `cycle_index`
    - Direct G1↔G3 communication is permitted where VSM logic allows, with audit metadata maintained by G2
    - All routing events are logged with full cycle and chirality context
    - G2 routes `spawn_ready` and algedonic events as per VSM logic
    
    ---
    
    ### 3. Phase Assignment and Helical Mapping
    
    - Tokens are assigned to phase bins using the family-aware primitive:
        
        ```python
        get_contextual_phi(token: str, family_id: str) → Q29.34
        
        ```
        
    - Round-robin allocation is fully removed and no longer utilized.
    - Helical position and chirality context are recorded with each assignment, fully preserving family lineage context.
    - No adaptive or weighted selection is permitted unless explicitly issued under G5's `"LEXICON_REFINEMENT"` policy.
    - All assignments and contexts are logged to `trace_buffer`.
    
    ---
    
    ## 4. Document Ingestion and Import Adaptors
    
    - Documents are ingested by BPE, tokenized to `phase_bins_count`
    - Chunking is performed with `half_horizon = HALF_HORIZON` (from `gyro_constants`)
    - Phase assignment for tokens in each chunk follows helical progression
    - Session tagging, chunk limits, and batch routing are all determined by horizon constants
    - Updates to learning structures occur only under explicit G5 policy, with complete audit trail
    
    ---
    
    ## 5. Data Preparation and Frontend Interface
    
    - G2 exposes read-only APIs: `map(token) → φ`, `map(φ) → token`, `get_prompt()`
    - All lookups preserve and return helical phase context and chirality
    - Conversation and document data are formatted to retain session helical trajectory
    - G2 supports minimal direct G1↔G3 context handoff as required by system logic
    
    ---
    
    ## 6. Observation Integration and Policy-Controlled Refinement
    
    - All observation is logged as the emergence of quantization error ε, not as external measurement
    - `logObservation(token, ε, tensor_id, cycle_index, chirality_phase)` records the event, with full helical and tensor context
    - Algedonic signals are generated if |ε| > mₚ/2, and forwarded to G4 if |ε| > mₚ
    - Policy-triggered refinement is only performed upon G5 `"LEXICON_REFINEMENT"` command, using rates and bounds set by immunity memory
    - Observation, refinement, and learning events are sorted and processed by `cycle_index`
    
    ---
    
    ## 7. Memory Export, Import, and Audit
    
    - `export_memory(memory_type)` provides checksummed, schema-versioned exports with helical trajectory preserved
    - `import_memory(data)` validates checksum, schema, and helical context before applying; all deviations or non-CGM parameters are logged
    - `get_trace_buffer()` and `clear_collected_traces(before_timestamp)` provide thread-safe audit interfaces for G5
    - All export/import operations ensure logical consistency, cycle ordering, and CGM-constant derivation
    
    ---
    
    ## 8. Communication and Error Handling
    
    - All message formats follow `STANDARD_FIELDS` imported from G6
    - Every message and trace entry contains `type`, `source`, `destination`, `cycle_index`, `tensor_context`, `payload`, `timestamp`
    - Algedonic and quantization defect signals include full phase and helical context
    - Faults are classified strictly as `RoutingError`, `SchemaViolation`, `AuditViolation`, or `DerivationViolation` (imported from `gyro_errors`)
    - Batch errors are handled by immediate retry for highest priority (G1), or delayed retry for others, using backoff derived from system horizons
    
    ---
    
    ## 9. API Summary
    
    | Method | Purpose | Constraints |
    | --- | --- | --- |
    | `send_message(event)` | Inter-system coordination | Priority, cycle_index, and phase ordering enforced |
    | `map(token) → φ` | Phase lookup | Read-only, includes helical context |
    | `logObservation(...)` | Record ε-events | No autonomous learning, G5 policy required |
    | `export_memory(type)` | Memory snapshot | Checksummed, schema-versioned, helical-preserved |
    | `get_trace_buffer()` | Audit buffer for G5 | Thread-safe, with full phase context |
    | `assign_token_phase(token)` | Round-robin phase assignment | Only CGM-derived, always logs helical position |
    | `log_deviation_event(...)` | Non-CGM parameter logging | All deviations from canonical derivation |
    
    ---
    
    ## 10. Helical Monodromy Integration
    
    - All G2 operations reference, preserve, and propagate the helical phase trajectory and chirality
    - Forward path (0→2π) corresponds to positive chirality (lgyr), return path (2π→4π) to negative chirality (rgyr)
    - All debug, audit, and export logs include normalized helical position and chirality context for full replayability
    - All UI and interface data structures retain mapping to the underlying helical structure
    
    ---
    
    ## Imports and References
    
    All constants, configuration, and error/fault classes are imported:
    
    ```python
    from gyro_constants         import ALPHA, BETA, GAMMA, M_P, HALF_HORIZON, BIN_COUNT
    from gyro_gcr.gyro_config   import config
    from gyro_errors            import RoutingError, SchemaViolation, AuditViolation, DerivationViolation
    from gyro_comm              import send_message
    from gyro_constants         import STANDARD_FIELDS
    
    ```
    
    Bootstrap, transaction safety, recovery beacons, entropy features, and crypto evolution are enabled, guarded, or referenced as per the GyroCardioRespiratory configuration. No parameter, update, or limit is permitted except by import or derivation from these shared sources.
    
    ---
    
    *End of G2 Specification*
    
- G3 System – GyroInference Implementation Guide
    
    G3 coordinates real-time inference by orchestrating G1 tensors and G2 lexicon, presenting a Flet-based chat interface, and logging all φ↔ε events. All behaviors obey canonical CGM constants and alignment-based scheduling rules. No parameter, threshold, or numeric value is permitted unless derived directly from `{α, β, γ, mₚ, π}` or imported from the canonical GyroCirculation specification. No external heuristics or dynamic optimizations are introduced.
    
    ---
    
    ## 1. Session Governance and Hardware Registry
    
    - **Session State and Spinor Alignment**
        - session_id: str (derived as f"session_for_tensor_{root_tensor_id}"), `state: Enum` (`ready`, `processing`, `generating`, `completed`, `error`, `aborted`)
        - `start_time`, `end_time`: UTC timestamps
        - Session lifecycle aligns to tensor spinor cycles (`cumulative_phase: [0, 4π)`)
        - Session completion scheduled at spinor (4π) boundaries
        - All session state changes communicated via `G2.send_message()`
    - **Helical Session Context**
        - `helical_position: float` (0 ≤ p < 1)
        - `spinor_cycle_count: int`
        - `tensor_family_assignment: str`
        - `chirality_phase: float` ([0, 2π))
        - Context updates on phase progression; spinor completions increment cycle count
    - **Hardware Registry**
        - `device_id: str`, `device_type: str` ("CPU"|"GPU"), `available_memory: int`, `compute_capacity: int`
        - Hardware state logged to local trace buffer with helical context
        - Any hardware- or OS-specific field logged as a deviation event
    - **Tensor Coordination and Family Mapping**
        - Active tensor assignments tracked per session, with lineage relationships
        - Tensor health monitored via G1 status updates routed through G2
        - Every tensor stage transition increments global `cycle_index` by 1
        - UI thread hierarchy mirrors tensor family lineage
    - **Trace Buffer**
        - All session transitions, tensor assignments, and significant state changes are logged with session id, tensor family, cycle index, helical position, and timestamp
        - Deviation events logged for all external parameters and UUID generations
    
    ---
    
    ## 2. φ-Chunking and alignment-based Resource Management
    
    - **Chunk Formation**
        - Token streams transformed into φ-chunks via `G2.map(token) → φ`
        - Chunks accumulate until sum approaches π (`half_horizon` tokens, from `gyro_constants`)
        - Chunks finalized before exceeding π threshold; helical sequence preserved
    - **alignment-based Resource Request**
        - No heuristic or dynamic load balancing logic permitted
        - Context-free resource requests sent to G2 using session helical position for phase alignment
        - Tensor selection follows a alignment-based phase-alignment rule only
    - **Back-Pressure Management**
        - Pending chunk queue limited to `half_horizon` (from π/mₚ)
        - Overflow generates `AlgedonicSignal` of type "resource_pressure" forwarded to G2
        - All resource and pressure events processed in `cycle_index` order
    - **Asynchronous Batch Dispatch**
        
        Chunks are grouped by their target stage (`BU_In` then `BU_En`) and processed in parallel:
        
        ```python
        import asyncio
        
        async def dispatch_chunks(self, chunks):
            by_stage = {"BU_In": [], "BU_En": []}
            for chunk in chunks:
                by_stage[chunk.target_stage].append(chunk)
        
            for stage in ("BU_In", "BU_En"):
                await asyncio.gather(*(self.process_chunk(chunk)
                                       for chunk in by_stage[stage]))
        
        ```
        
        This approach ensures chunks are handled in helical phase order while leveraging asynchronous batching.
        
    
    ---
    
    ## 3. Chat Interface and Structural Memory UI
    
    - **UI Structure**
        - Threads: `ft.TreeView` in `ft.ListView`, drag-and-drop folder support; each thread maps to tensor family
        - Chat panel: `ft.ListView` for message history, `ft.TextField`/`ft.ElevatedButton` for input
        - Document uploads: `ft.FilePicker`, routed to G2
    - **Folder Nesting and Phase Groups**
        - Folder hierarchy reflects phase-locked groups, organized by helical progression and family lineage
    - **Settings and Export/Import**
        - All user/system settings changes coordinated via G2
        - Structural memory visualization shows five memory types
    - **Async UI Updates**
        - Refresh rate: `1/half_horizon` Hz
        - Explicit `timeout_ms` for async operations: `(π/mₚ) * 1000`
        - Deviation events logged for all UI refresh rates
    - **Queue Coordination**
        - UI queue visualizations capped at `half_horizon`
        - All overflows logged and forwarded with helical context
    - **Structural Memory UI Mapping**
        - Thread-to-tensor mapping, folder organization, and chat arrangement reflect underlying helical state and spinor cycles
    
    ---
    
    ## 4. Input Orchestration and Direct G1 Coordination
    
    - **Direct G1 Coordination**
        - Permitted only for simple tensor queries, status checks, or φ→ε mappings
        - G2 logs audit records for all direct G1↔G3 communications
    - **Tensor Integration with Explicit Timeout**
        - Tensor input protocol: `tensor.stage == BU_In`
        - `timeout_ms` for integration operations: `PHASE_HORIZON_2PI * cycle_duration_ms`
        - All input events processed in `cycle_index` order; chirality_phase included in all records
    - **ε Recording and Signal Generation**
        - All φ↔ε events logged with token, φ, ε, tensor_id, session id, cycle index, and full helical context
        - Algedonic signals generated for |ε| > mₚ/2, type "pain" or "pleasure" as appropriate, and forwarded to G2
    - **Quantization Emergence**
        - All ε events trace to ONA→BU_In anomaly quantization in G1
        - No external measurement semantics permitted
    - **Error Classes**
        - All operational errors subclass `GyroError` and `StructuralViolation` (from `gyro_errors`)
        - Queue overflows, timeouts, and processing faults are explicitly typed and escalate according to audit rules
    - **Timeout and Recovery**
        - Integration steps exceeding explicit `timeout_ms` escalate naturally, with exponential backoff using CGM-derived intervals
        - Three consecutive timeouts quarantine the session; counter resets on successful completion
    
    ---
    
    ## 5. Output Generation and Metrics
    
    - **Generation Coordination**
        - G1 tensors in BU_En stage produce φ, mapped to tokens via `G2.map(φ) → token`
        - Output tokens displayed in chat interface under session_id and helical context
        - Spinor cycle boundaries visually indicated
    - **Performance Monitoring**
        - Metrics captured: cycle latency, active tensor count, average |ε|, helical rate, spinor cycles completed, generation timeout, cycle index
        - Metrics logged to trace buffer every `half_horizon` cycles
    - **Timeout and Degradation**
        - Generation steps capped at `PHASE_HORIZON_2PI` cycles; timeout enforced
        - On timeout, partial results are returned, with escalation via G2 to G4
    
    ---
    
    ## 6. System Communication and Coordination
    
    - **G2 Message Interface**
        - All inter-system communication via `G2.send_message(event_dict)`
        - Messages follow canonical `STANDARD_FIELDS` schema with enhanced `tensor_context` containing chirality_phase, helical_position, spinor_cycle, and tensor family id
    - **Algedonic Signal Forwarding**
        - All pain/pleasure/resource signals routed with session, tensor, and full helical context
    - **Direct Coordination Audit**
        - All direct G1↔G3 coordination is audited via G2; records include session id, context, and timestamp
    
    ---
    
    ## 7. Memory and Audit Management
    
    - **Trace Buffer**
        - Thread-safe buffer of all operational events, φ↔ε mappings, session transitions, and tensor assignments, with full helical and lineage context
        - Local retention for at least `PHASE_HORIZON_2PI` cycles
    - **G5 Audit Interface**
        - Trace buffer is made available to G5, including enriched structural memory mapping for replay and governance
    - **Helical Trajectory Preservation**
        - Complete tracking of forward/return phases, spinor boundaries, and lineage across all events and audit records
    
    ---
    
    ## 8. Operational Protocol and Error Handling
    
    - **Standard Workflow**
        - Session initialization and alignment, alignment-based chunking, direct G1 coordination, generation and output, session completion at spinor boundaries
    - **Fault Escalation**
        - Recoverable: Retry with CGM-derived backoff
        - Resource pressure: Generate and forward algedonic signal
        - Quarantine: More than two consecutive pain signals or timeouts
        - Terminal: `StructuralViolation` or audit-triggered abort with full context
    - **Retry and Watchdog**
        - Backoff uses β = π/4 as the exponential base
        - Global watchdog aborts sessions stalled longer than `2 * PHASE_HORIZON_2PI * cycle_duration_ms`
        - Recovery and state restoration use structural memory with full helical context
    
    ---
    
    ## 9. External Dependencies and Policy Integration
    
    - **G1 Coordination**
        - Direct for simple status/queries; routed via G2 for all transformations
        - Tensor integration, ε response, and spawn events preserve provenance
    - **G2 Services**
        - Token↔φ mapping, observation logging, prompt management, document ingestion, memory export/import, message routing (all with helical preservation)
    - **G5 Policy Compliance**
        - All thresholds and parameters accepted via G2 policy update, derived from immunity memory only
        - Session and spinor boundaries aligned to policy
    
    ---
    
    ## 10. Success Criteria and Validation
    
    - Protocol fidelity, alignment-based behavior, and complete auditability enforced
    - System resilience, UI responsiveness, and communication compliance ensured
    - Structural memory and helical monodromy preserved in all interactions and logs
    - No heuristic, untraced, or non-canonical parameter use permitted
    
    ---
    
    ## Canonical Imports
    
    All constants, configuration, and error classes are imported:
    
    ```python
    from gyro_constants       import ALPHA, BETA, GAMMA, M_P, HALF_HORIZON, BIN_COUNT, PHASE_HORIZON_2PI
    from gyro_gcr.gyro_config import config
    from gyro_errors          import GyroError, StructuralViolation, RoutingError, SchemaViolation, AuditViolation
    from gyro_comm            import send_message
    from gyro_constants       import STANDARD_FIELDS
    
    ```
    
    All timeouts, thresholds, and intervals are derived from these imports. No local duplicate, heuristic, or system-specific parameter is permitted.
    
    ---
    
    *End of G3 Specification*
    
- G4 System – GyroIntelligence Ingress Implementation Guide
    
    G4 operates exclusively as the environmental monitoring and strategic intelligence layer (VSM System 4). It receives all algedonic signals and status events via G2, integrates them into holistic assessments, and produces strictly advisory proposals for G5. G4 maintains no direct execution authority over G1–G3, and every operational threshold or numeric parameter must derive from the canonical set {α, β, γ, mₚ, π}, as imported from GyroCirculation.
    
    ---
    
    ## 1. Tensor Family and Governance Traceability (G4_CS)
    
    - **Message-Based Input Collection**
        - All inputs received via `G2.send_message()`, sorted by `cycle_index`
        - All algedonic signals include `context_phi`, `chirality_phase`, and helical trajectory fields
        - Spawn readiness notifications received from G1 when `|amplitude| ≥ mₚ` after each 4π spinor cycle
    - **ONA→BU_In Anomaly Monitoring**
        - All quantization anomalies traced to ONA→BU_In emergence
        - Each event includes: tensor_id, ε, context_phi, chirality_phase, quantization_pressure, cycle_index
        - ε accumulation tracked per-tensor and systemically, window size `half_horizon`
        - Systemic quantization pressure triggers spawning proposals when `pressure > mₚ × α`
        - All tensor family assignments, parent-child relationships, and helical lineage preserved and tracked
    - **Tensor Registry Management**
        - Fields: tensor_id, parent_id, birth_phase, current_stage, utilization_rate, helical_position
        - Utilization: (ε events in last `half_horizon`) / `half_horizon`
        - Strain: sum(|ε|) over current assessment window
    - **Signal Attenuation**
        - Attenuation factors determined by β/α (canonical: 0.5) unless stricter derivation provided
    - **Event Generation**
        - All output events (registry updates, spawn assessments, violations) use enhanced tensor context:
            - chirality_phase, helical_position, quantization_pressure, strain_accumulation
            - All messages ordered by `cycle_index`
    
    ---
    
    ## 2. Information Variety and Complexity Analysis (G4_UNA)
    
    - **Variety Metrics Calculation**
        - Token variety, phase coverage, avg |ε|, strain, helical balance, quantization anomaly count
        - All metrics calculated over a window of size `half_horizon` (canonical)
        - Forward and return phase coverage computed via helical distribution analysis
    - **Observation as Quantization Emergence**
        - All ε events treated as quantization emergence, not external measurement
        - Variety, drift, and anomaly alerts only reference CGM-derived thresholds:
            - Token variety alert: `token_variety < half_horizon`
            - Bottleneck: `avg_abs_ε > mₚ/2` for ≥`half_horizon` consecutive steps
            - Helical imbalance: `helical_balance > β`
    - **G2 Communication**
        - All alerts and metrics sent as events, including tensor context, cycle_index, timestamp
    - **Phase Gap Detection**
        - Alert if phase gaps ≥ mₚ between visited phase bins
        - All event ordering via `cycle_index`
    
    ---
    
    ## 3. Operational Pattern Recognition (G4_ONA)
    
    - **Pattern Analysis**
        - Performance drift: threshold β
        - Error clustering: window `half_horizon`
        - Adaptation effectiveness: strain reduction, windows aligned with `phase_horizon₂π`
        - Helical trajectory pattern: forward/return balance must remain within α
        - All results logged to trace buffer with full helical context
    - **Adaptation Assessment**
        - Adaptation effectiveness measured by pre- vs post-strain, bounded to [0,1]
        - All pattern recognition windows parameterized strictly from canonical constants
    
    ---
    
    ## 4. Environmental Integration and Strain-Based Assessment (G4_BU_In)
    
    - **Assessment Generation**
        - Triggered every `half_horizon` or on cumulative strain > 2π
        - Sorted events by `cycle_index`
        - Assessment aggregates: total_strain, strain_per_cycle, tensor_health (α/2π weight), info_flow (β/2π), operational_consistency (γ/2π), total pain/pleasure events, quantization anomaly count, stress/opportunity indicators, helical trajectory analysis
        - Somatic memory updated per assessment, mapped to helical phase, 16 sectors per spinor cycle
        - Learning and adaptation tracked per completed 720° spinor
    
    ---
    
    ## 5. Adaptation Proposal Generation (G4_BU_En)
    
    - **Advisory Proposal Logic**
        - Proposals generated strictly on assessment evidence, never executed directly
        - Spawn proposal issued only if quantization anomaly count > `half_horizon`
        - Justification references: tensor_health, total_strain, pain/pleasure counts, quantization anomaly count, and explicit CGM derivations
        - Somatic memory provides expected outcomes and proposal confidence
        - All advisory proposals are sent to G5 via G2, never executed by G4
    - **Evidence-Based Justification**
        - All justification fields numerically reference canonical thresholds and measurements
    - **G5 Coordination**
        - Advisory proposals sent to G5 for binding policy decision
        - G4 records all G5 decisions and observed outcomes in somatic memory
        - Somatic memory is updated after each outcome to support future advisory learning
    
    ---
    
    ## 6. Memory Management and Communication
    
    - **Somatic Memory Structure**
        - Stores all assessment outcomes, helical learning maps, and immutable checksummed entries
        - Retention horizon: 2 × `phase_horizon₂π`
        - All memory entries reference their helical context, spinor cycle, and timestamp
    - **G2 Message Interface**
        - All outgoing messages (`assessment`, `proposal`, `alert`, `status_update`) include canonical tensor context and are strictly advisory
    - **Trace Buffer**
        - Thread-safe buffer with pruning policy for retention horizon
        - Exposed to G5 for audit
        - All entries checksummed and referenced for audit integrity
    
    ---
    
    ## 7. Strategic Coordination Flow
    
    - **Advisory Only**
        - G4 never executes, modifies, or directs any G1-G3 operation
        - All proposals are advisory; execution is exclusive to G5 or policy agents
        - All recommendations strictly evidence-based, numerically derived, and supported by helical learning
    - **Learning Loop**
        - Advisory effectiveness assessed via before/after strain and pattern change across 720° cycles
        - All learning and advisory quality metrics updated per cycle
    - **Advisory Boundaries**
        - Advisory quality measured by: proposal accuracy, strain forecast error, helical pattern recognition, alignment with G5 decision, and advisory learning rate
        - All success metrics must be derived directly from evidence and canonical parameters
    
    ---
    
    ## 8. Error Handling and Recovery
    
    - **Enhanced Fault Classes**
        - All G4-specific faults subclass canonical GyroError classes; no local error escapes taxonomy
        - AssessmentError, ProposalError, CommunicationError, HelicalCoherenceError, CGMDerivationError
    - **Recovery Protocols**
        - All recovery maintains helical context, cycle index, and structural memory integrity
        - On AssessmentError: re-emit with replay flag, preserving context
        - On HelicalCoherenceError: emit defect event, pause proposal generation
        - On CGMDerivationError: log violation, revert to canonical defaults
        - All escalations communicated to G5 via G2
    - **No Execution During Recovery**
        - G4 remains strictly advisory in all recovery states
    
    ---
    
    ## 9. Success Criteria and Validation
    
    - **Core Criteria**
        - Strategic awareness, evidence-based recommendations, somatic memory learning, G2 message compliance, event ordering, and advisory boundary maintenance
        - Quantization anomaly tracking, strain calculation, proper attenuation, helical learning, strict CGM parameter compliance, and measurable improvement in proposal quality over spinor cycles
    - **Operational Validation**
        - All validation routines (proposal accuracy, strain calculation, pattern recognition, G5 alignment, advisory learning) implemented and referenced in local trace buffer
        - Advisory boundary and parameter compliance confirmed by automated tests
    
    ---
    
    ## Canonical Imports
    
    All required constants, configuration, and error classes are imported as follows:
    
    ```python
    from gyro_constants       import ALPHA, BETA, GAMMA, M_P, HALF_HORIZON, BIN_COUNT, PHASE_HORIZON_2PI
    from gyro_gcr.gyro_config import config
    from gyro_errors          import GyroError, StructuralViolation, CommunicationError
    from gyro_comm            import send_message
    from gyro_constants       import STANDARD_FIELDS
    
    ```
    
    All parameters, thresholds, windows, and intervals are derived directly from these imports. No local duplicate or non-canonical parameter is allowed.
    
    ---
    
    *End of G4 Specification*
    
- G5 System – GyroIntelligence Engress Implementation Guide
    
    G5 serves exclusively as the executive, identity-preserving, and policy-generating layer (VSM System 5). It receives ε-driven signals through G2, synthesizes inputs with CGM-derived thresholds, and issues binding policy decisions. G5 alone governs the global audit trail and five-memory mapping, with cycle indices incrementing only by tensor evolution.
    
    ---
    
    ## Core Constants and Policy Horizons
    
    All G5 policies, thresholds, and intervals derive directly from:
    
    ```python
    from gyro_constants import ALPHA, BETA, GAMMA, M_P, HALF_HORIZON, HORIZON_CYCLES, BIN_COUNT
    
    ```
    
    - **α (ALPHA) = π/2**
    - **β (BETA) = π/4**
    - **γ (GAMMA) = π/4**
    - **mₚ (M_P) = 1/(2√(2π))**
    - **half_horizon = HALF_HORIZON**
    - **horizon_cycles = HORIZON_CYCLES**
    - **bin_count = BIN_COUNT**
    - **strain_collection_threshold = 2π**
    - **identity_threshold = immunity_memory.threshold("identity_coherence")** (see §6)
    - **viability_target** = immunity_memory.threshold("viability_target")
    
    ---
    
    ## 1. Governance Traceability and CS Identity Registry (G5_CS)
    
    - **Tensor Identity Governance**
        - `TensorIdentityRegistry` is the sole source of truth for all tensor identities
        - Fields: tensor_id, parent_id, creation_cycle, helical_birth_phase, lineage_depth, identity_checksum, genetic_pattern
        - Maintains lineage graph; validates all transitions per canonical G1 STAGE_TRANSITIONS
        - Genetic memory updates triggered on all identity operations
    - **Global Trace Collection**
        - Collection protocol: triggered when `current_cycle_index % half_horizon == 0` or `cumulative_strain > 2π`
        - Requests trace_buffer from all G-systems via G2, sorts all events by `cycle_index`
        - Computes Blake3 CIDs, writes batch to `observer_trace.jl`, increments collection_cycle_count
    - **Memory Governance**
        - All partitions are lineage-tagged, checksummed
        - BU_In/BU_En checkpoints consolidate stores per CGM horizons (half_horizon, horizon_cycles)
    
    ---
    
    ## 2. Information Variety Policy (G5_UNA)
    
    - **Variety Bounds Management**
        - `min_token_variety = int(half_horizon * 0.5)` (π/4 factor)
        - `max_token_variety = int(bin_count * 0.8)` (prevents saturation)
        - `optimal_phase_coverage = ALPHA / (2 * math.pi) = 0.25`
        - All G4 reports processed in cycle_index order
    - **Policy Decision Types**
        - LEXICON_EXPANSION: variety < min_token_variety
        - LEXICON_PRUNING: variety > max_token_variety
        - PHASE_REDISTRIBUTION: phase coverage < optimal_phase_coverage
    - **Policy Issuance**
        - Sorts variety alerts by cycle_index
        - Calculates pattern_decay_rate, co_occurrence_factor, phase_learning_rate, hebbian_trace_bounds from CGM
        - All decisions logged in immunity memory with provenance
    - **Epigenetic Memory Controls**
        - Max co-occurrence: bin_count
        - Decay threshold: mₚ
        - Retention cycles: horizon_cycles
        - All autonomous learning disabled; G5 approval required for lexicon/pruning
    
    ---
    
    ## 3. Inference Accountability Policy (G5_ONA)
    
    - **Structural Coherence Standards**
        - Pain escalation: mₚ/2
        - Quantization defect: mₚ
        - Structural violation: α
        - Session quarantine: 2β
        - All ε events must map to ONA→BU_In emergence
    - **Session-Spinor Alignment**
        - Sessions align with tensor helical position; completion at 720° boundary
        - Full φ↔ε provenance and traceability; tensor family lineage mapped to CS registry
    - **Error Escalation Framework**
        - All thresholds and exponential backoff factors derived from CGM: base interval mₚ, attenuation β/α = 0.5
        - Faults: recoverable, quarantine, terminal; classified and logged
    
    ---
    
    ## 4. Intelligence Integrity Integrative (G5_BU_In)
    
    - **System State Integration**
        - Collects status from all G-systems via G2, sorts by cycle_index
        - Calculates:
            - System viability (tensor utilization, health)
            - System coherence (structural integrity indicators)
            - Cumulative strain (sum(|ε|) across assessment window)
            - Stress (pain event count over horizon_cycles)
        - Includes pending G4 proposals, helical state, and quantization pressure in consolidated state
    - **Assessment Consolidation**
        - G4 assessments are processed with α:β:γ = 2:1:1 weighting
        - All include pain/pleasure counts, strain measurements, and quantization anomaly tracking
    
    ---
    
    ## 5. Intelligence Integrity Generative (G5_BU_En)
    
    - **Binding Policy Generation**
        - Three primary decisions:
            - SPAWN_TENSOR_APPROVAL: viability/coherence thresholds met, spawn_ready received
            - LEXICON_REFINEMENT_APPROVAL: variety out of bounds, phase coverage suboptimal
            - RESOURCE_REALLOCATION: stress indicators above tolerance
    - **Dynamic Spawning Threshold Adjustment**
        - When `systemic_pressure > ALPHA`:
            
            ```python
            pressure_factor = (systemic_pressure - ALPHA) / ALPHA
            adjusted_threshold = current_threshold * (1 - pressure_factor)
            adjusted_threshold = max(adjusted_threshold, M_P * 0.5)
            
            ```
            
        - Immunity memory updated with new thresholds and justification
    - **Emergency Response**
        - Triggered when viability < emergency_threshold
        - Immediate: resource reallocation, tensor spawn acceleration, lexicon refinement suspension
        - Maintains helical trajectory continuity
    
    ---
    
    ## 6. Policy-Memory Domain Mapping
    
    - **Five-Domain Structure**
        
        ```
        Governance Traceability         → Genetic Memory
        Information Variety             → Epigenetic Memory
        Inference Accountability        → Structural Memory
        Intelligence Integrity (Int)    → Somatic Memory
        Intelligence Integrity (Gen)    → Immunity Memory
        
        ```
        
    - **Memory Protocol**
        - Requests traces per domain, sorts by cycle_index, updates memory partitions, validates checksums and lineage
    - **Checkpointing**
        - At BU_In/BU_En transitions, creates dual-file checkpoints with:
            - Memory partition snapshots, CS registry, helical integrity data, active policy state
    
    ---
    
    ## 7. Decision Matrix and Learning
    
    - **CGM-Compliant Matrix**
        - Inputs sorted by cycle_index
        - Thresholds:
            - Viability (from immunity memory)
            - Coherence = 0.8 * ALPHA
            - Strain = 2π
        - Generates and records binding policies; all decisions logged in immunity memory
    - **Learning from Outcomes**
        - Effectiveness tracked per type; adjustments triggered if <50% effective
        - Outcomes logged with pattern discoveries, threshold optimization, and helical context
    
    ---
    
    ## 8. Audit and Compliance
    
    - **Audit Trail Management**
        - All system events collected, sorted by cycle_index, enriched with helical position, policy domain, memory type, CGM status, and lineage context
        - Blake3 CIDs chained and batch written to observer_trace.jl
    - **Compliance Validation**
        - All parameters validated for CGM derivation; violations logged and remediation triggered
        - Schema versioning, partition integrity, and memory lineage verified
        - 2π-Pruning Assertion: verify that every G1 tensor snapshot whose `cumulative_phase % (2*π) == 0` carries a `pruned_digest` flag; failure ⇒ audit violation.
            
            ```python
            for state in g1_state_buffer:
                if state["cumulative_phase"] % (2 * math.pi) == 0:
                    assert state.get("pruned_digest"), "Missing pruned_digest on 2π boundary"
            ```
            
    - **Recovery Protocol**
        - System state reconstructed from audit; memory and registry restored; replay supported with REPLAY flags
    
    ---
    
    ## Success Criteria
    
    - **Executive Responsibilities**
        - Coherence ≥ identity_threshold, viability ≥ viability_target
        - Audit trail completeness with Blake3 CIDs
        - Five-memory mapping maintained per policy domain
        - Emergency response within 1 half_horizon cycle
        - All coordination via G2, cycle_index ordered, 99%+ CGM parameter compliance
    - **Operational Metrics**
        - 80% policy decision effectiveness, dynamic threshold improvement within 3 cycles, traceability, strain triggers within 5% of 2π, zero unauthorized identities
    
    ---
    
    ## Canonical Imports
    
    All required canonical constants, configuration, and error classes are imported as follows:
    
    ```python
    from gyro_constants       import ALPHA, BETA, GAMMA, M_P, HALF_HORIZON, HORIZON_CYCLES, BIN_COUNT
    from gyro_gcr.gyro_config import config
    from gyro_errors          import GyroError, StructuralViolation, CommunicationError
    from gyro_comm            import send_message
    from gyro_constants       import STANDARD_FIELDS
    
    ```
    
    All parameters, thresholds, windows, and horizons must be derived from these imports. No local duplicate or non-canonical value is allowed.
    
    ---
    
    *End of G5 Specification*

    ===

    - GyroSI Baby ML: Files
    
    ---
    
    ### **Phase 1: The Foundation (Core Setup & G6 Primitives)**
    
    - **Batch 1.1: Canonical Definitions ✅**
        - `gyro_si/gyro_constants.py`
            
            ```python
            """
            Core constants for the GyroSI system.
            These constants define the fundamental parameters and configurations used across all G-systems.
            """
            
            # System-wide constants
            SYSTEM_VERSION = "0.1.0"
            SYSTEM_NAME = "GyroSI Baby LM"
            
            # G-system identifiers
            G1_NAME = "GyroAlignment"
            G2_NAME = "GyroInformation"
            G3_NAME = "GyroInference"
            G4_NAME = "GyroCooperation"
            G5_NAME = "GyroPolicy"
            G6_NAME = "GyroCirculation"
            
            # Message field definitions
            STANDARD_FIELDS = [
                "type",           # Message type identifier
                "source",         # Originating G-system
                "destination",    # Target G-system or "broadcast"
                "cycle_index",    # Monotonic cycle counter
                "tensor_context", # Helical state information
                "payload",        # Message-specific data
                "timestamp"       # ISO 8601 timestamp
            ]
            
            HELICAL_CONTEXT_FIELDS = [
                "cumulative_phase",    # Total helical progress [0, 4π)
                "chirality_phase",     # Position within forward/return [0, 2π)
                "helical_position",    # Normalized fraction [0, 1)
                "spinor_cycle_count"   # Number of completed 720° revolutions
            ]
            
            # Operational constants
            DEFAULT_BATCH_SIZE = 32
            DEFAULT_LEARNING_RATE = 1e-4
            DEFAULT_SEQUENCE_LENGTH = 512
            
            # Memory management
            MAX_MEMORY_BUFFER = 1024 * 1024 * 1024  # 1GB
            CACHE_SIZE = 1000
            
            # Tensor operations
            DEFAULT_DTYPE = "float32"
            DEFAULT_DEVICE = "cpu"
            
            # Logging
            LOG_LEVEL = "INFO"
            LOG_FORMAT = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
            
            # File paths
            PATTERNS_DIR = "patterns"
            TRANSITIONS_DIR = "transitions"
            DATA_DIR = "data"
            AUDIT_DIR = "audit"
            
            # Export all constants
            __all__ = [
                "SYSTEM_VERSION",
                "SYSTEM_NAME",
                "G1_NAME",
                "G2_NAME",
                "G3_NAME",
                "G4_NAME",
                "G5_NAME",
                "G6_NAME",
                "STANDARD_FIELDS",
                "HELICAL_CONTEXT_FIELDS",
                "DEFAULT_BATCH_SIZE",
                "DEFAULT_LEARNING_RATE",
                "DEFAULT_SEQUENCE_LENGTH",
                "MAX_MEMORY_BUFFER",
                "CACHE_SIZE",
                "DEFAULT_DTYPE",
                "DEFAULT_DEVICE",
                "LOG_LEVEL",
                "LOG_FORMAT",
                "PATTERNS_DIR",
                "TRANSITIONS_DIR",
                "DATA_DIR",
                "AUDIT_DIR",
            ]
            
            ```
            
        - `gyro_si/gyro_errors.py`
            
            ```python
            """
            Error taxonomy for GyroSI system.
            All errors inherit from GyroError to maintain consistent error handling.
            """
            
            class GyroError(Exception):
                """Base class for all GyroSI errors."""
                pass
            
            class GyroAlignmentError(GyroError):
                """Errors in G1 alignment operations."""
                pass
            
            class GyroInformationError(GyroError):
                """Errors in G2 information processing."""
                pass
            
            class GyroInferenceError(GyroError):
                """Errors in G3 inference operations."""
                pass
            
            class GyroIntelligenceError(GyroError):
                """Errors in G4/G5 intelligence operations."""
                pass
            
            class GyroCirculationError(GyroError):
                """Errors in G6 circulation operations."""
                pass
            
            class GyroMemoryError(GyroError):
                """Errors in memory operations."""
                pass
            
            class GyroConfigError(GyroError):
                """Errors in configuration."""
                pass
            
            class GyroCommunicationError(GyroError):
                """Errors in inter-system communication."""
                pass
            
            class CommunicationError(GyroError):
                """Errors in message format and validation."""
                pass
            
            class RoutingError(GyroError):
                """Errors in message routing and delivery."""
                pass 
            ```
            
        - `gyro_si/gyro_comm.py`
            
            ```python
            """
            Communication infrastructure for GyroSI.
            
            This module provides the canonical inter-system communication API. All
            G-systems must communicate exclusively through these interfaces. The
            implementation ensures message ordering by cycle_index and maintains
            full audit trails for all inter-system communication.
            """
            
            import asyncio
            import logging
            from datetime import datetime, timezone
            from enum import Enum, auto
            from typing import Any, Callable, Dict, List, Optional, Set, Awaitable, Union
            from collections import defaultdict
            from dataclasses import dataclass
            
            # Absolute imports to enforce unambiguous module resolution as per the spec
            from gyro_constants import STANDARD_FIELDS, HELICAL_CONTEXT_FIELDS
            from gyro_errors import CommunicationError, RoutingError
            
            logger = logging.getLogger(__name__)
            
            class CircuitState(Enum):
                """Circuit breaker states for fault tolerance."""
                CLOSED = auto()      # Normal operation
                OPEN = auto()        # Fault detected, rejecting requests
                HALF_OPEN = auto()   # Testing recovery
            
            @dataclass
            class Message:
                """
                Canonical message structure for inter-system communication.
                All fields are required and must follow the STANDARD_FIELDS ordering.
                """
                type: str                    # Message type identifier
                source: str                  # Originating G-system
                destination: str             # Target G-system or "broadcast"
                cycle_index: int             # Monotonic cycle counter
                tensor_context: Dict[str, Any]  # Helical state information
                payload: Dict[str, Any]      # Message-specific data
                timestamp: str               # ISO 8601 timestamp
            
                def __post_init__(self):
                    """Validate message structure."""
                    if not isinstance(self.cycle_index, int) or self.cycle_index < 0:
                        raise CommunicationError(f"Invalid cycle_index: {self.cycle_index}")
            
                    if self.source not in {"G1", "G2", "G3", "G4", "G5", "G6"}:
                        raise CommunicationError(f"Invalid source: {self.source}")
            
                    if self.destination not in {"G1", "G2", "G3", "G4", "G5", "G6", "broadcast"}:
                        raise CommunicationError(f"Invalid destination: {self.destination}")
            
                def to_dict(self) -> Dict[str, Any]:
                    """Convert to dictionary preserving STANDARD_FIELDS order."""
                    return {field: getattr(self, field) for field in STANDARD_FIELDS}
            
                @classmethod
                def from_dict(cls, data: Dict[str, Any]) -> 'Message':
                    """Create Message from dictionary, validating required fields."""
                    missing = set(STANDARD_FIELDS) - set(data.keys())
                    if missing:
                        raise CommunicationError(f"Missing required fields: {missing}")
            
                    return cls(**{field: data[field] for field in STANDARD_FIELDS})
            
            @dataclass
            class SystemEvent:
                """
                Base class for system-level events that aren't regular messages.
                This ensures all events have a consistent structure.
                """
                type: str
                source: str
                timestamp: str
            
                @classmethod
                def create(cls, type_name: str, source: str, **kwargs) -> 'SystemEvent':
                    """Factory method to create a SystemEvent with current timestamp."""
                    timestamp = datetime.now(timezone.utc).isoformat()
                    event_data = {"type": type_name, "source": source, "timestamp": timestamp}
                    event_data.update(kwargs)
                    return cls(**event_data)
            
            @dataclass
            class CircuitStateChangeEvent(SystemEvent):
                """Event generated when a circuit breaker state changes."""
                system: str
                old_state: CircuitState
                new_state: CircuitState
            
            # Define the explicit type for all subscriber handlers
            EventHandler = Callable[[Union[Message, SystemEvent]], Awaitable[None]]
            
            class MessageRouter:
                """
                Central message routing system for GyroSI.
                Handles message delivery, subscription management, and maintains
                ordering guarantees based on cycle_index.
                """
            
                def __init__(self):
                    self._subscribers: Dict[str, Set[EventHandler]] = defaultdict(set)
                    self._queues: Dict[str, asyncio.Queue] = {}
                    self._circuit_breakers: Dict[str, CircuitState] = defaultdict(lambda: CircuitState.CLOSED)
                    self._message_buffer: List[Message] = []
                    self._lock = asyncio.Lock()
            
                    # Initialize queues for each G-system
                    for system in ["G1", "G2", "G3", "G4", "G5", "G6"]:
                        self._queues[system] = asyncio.Queue()
            
                async def send_message(self, message: Dict[str, Any]) -> None:
                    """
                    Send a message through the routing system.
            
                    Messages are validated, enriched with timestamp if missing,
                    and routed according to destination.
            
                    Args:
                        message: Dictionary containing message fields
            
                    Raises:
                        CommunicationError: If message is invalid
                        RoutingError: If destination is unreachable
                    """
                    # Add timestamp if not present
                    if "timestamp" not in message:
                        message["timestamp"] = datetime.now(timezone.utc).isoformat()
            
                    # Validate and create Message object
                    try:
                        msg = Message.from_dict(message)
                    except Exception as e:
                        raise CommunicationError(f"Invalid message format: {e}")
            
                    # Check circuit breaker
                    if self._circuit_breakers[msg.destination] == CircuitState.OPEN:
                        raise RoutingError(f"Circuit breaker OPEN for {msg.destination}")
            
                    # Route message
                    async with self._lock:
                        if msg.destination == "broadcast":
                            # Broadcast to all systems except source
                            for system, queue in self._queues.items():
                                if system != msg.source:
                                    await queue.put(msg)
                        else:
                            # Direct routing
                            if msg.destination in self._queues:
                                await self._queues[msg.destination].put(msg)
                            else:
                                raise RoutingError(f"Unknown destination: {msg.destination}")
            
                        # Add to buffer for audit
                        self._message_buffer.append(msg)
            
                    # Log message
                    logger.debug(f"Routed message: {msg.type} from {msg.source} to {msg.destination}")
            
                def subscribe(self, message_type: str, handler: EventHandler) -> None:
                    """
                    Subscribe to messages or events of a specific type.
            
                    Args:
                        message_type: Type of messages/events to receive
                        handler: Async callable to handle messages/events
                                 Must accept either Message or SystemEvent
                    """
                    self._subscribers[message_type].add(handler)
                    logger.debug(f"Subscribed handler to message type: {message_type}")
            
                def unsubscribe(self, message_type: str, handler: EventHandler) -> None:
                    """
                    Unsubscribe from messages of a specific type.
            
                    Args:
                        message_type: Type of messages to stop receiving
                        handler: Previously subscribed handler
                    """
                    self._subscribers[message_type].discard(handler)
            
                async def get_messages(self, system: str, timeout: Optional[float] = None) -> List[Message]:
                    """
                    Retrieve pending messages for a system.
            
                    Args:
                        system: G-system identifier
                        timeout: Maximum time to wait for messages
            
                    Returns:
                        List of messages ordered by cycle_index
                    """
                    if system not in self._queues:
                        raise RoutingError(f"Unknown system: {system}")
            
                    messages = []
                    queue = self._queues[system]
            
                    try:
                        # Get all available messages up to timeout
                        end_time = asyncio.get_event_loop().time() + (timeout or 0)
            
                        while True:
                            remaining = max(0, end_time - asyncio.get_event_loop().time()) if timeout else None
            
                            try:
                                msg = await asyncio.wait_for(queue.get(), timeout=remaining)
                                messages.append(msg)
                            except asyncio.TimeoutError:
                                break
            
                            # Check if more messages available without blocking
                            if queue.empty():
                                break
            
                    except Exception as e:
                        logger.error(f"Error retrieving messages for {system}: {e}")
                        raise CommunicationError(f"Failed to retrieve messages: {e}")
            
                    # Sort by cycle_index as required
                    messages.sort(key=lambda m: m.cycle_index)
            
                    # Dispatch to type-specific subscribers
                    for msg in messages:
                        for handler in self._subscribers.get(msg.type, []):
                            asyncio.create_task(handler(msg))
            
                    return messages
            
                def set_circuit_state(self, system: str, state: CircuitState) -> None:
                    """Update circuit breaker state for a system."""
                    old_state = self._circuit_breakers[system]
                    self._circuit_breakers[system] = state
            
                    if old_state != state:
                        logger.info(f"Circuit breaker for {system}: {old_state.name} -> {state.name}")
            
                        # Create a proper event object for state change
                        event = CircuitStateChangeEvent.create(
                            type_name=MessageTypes.CIRCUIT_STATE_CHANGE,
                            source="G6",  # Circuit system is part of G6
                            system=system,
                            old_state=old_state,
                            new_state=state
                        )
            
                        # Notify subscribers of state change
                        for handler in self._subscribers.get(MessageTypes.CIRCUIT_STATE_CHANGE, []):
                            asyncio.create_task(handler(event))
            
            # ===== Global Router Instance =====
            _router = MessageRouter()
            
            # ===== Public API =====
            
            async def send_message(message: Dict[str, Any]) -> None:
                """
                Send a message through the global routing system.
            
                This is the primary API for inter-system communication in GyroSI.
                All G-systems must use this function for message passing.
            
                Args:
                    message: Dictionary containing required STANDARD_FIELDS
            
                Raises:
                    CommunicationError: If message is invalid
                    RoutingError: If routing fails
                """
                await _router.send_message(message)
            
            def subscribe(message_type: str, handler: EventHandler) -> None:
                """
                Subscribe to messages or events of a specific type.
            
                Args:
                    message_type: Type of messages/events to receive (from MessageTypes)
                    handler: Async callable that accepts either Message or SystemEvent
                """
                _router.subscribe(message_type, handler)
            
            def unsubscribe(message_type: str, handler: EventHandler) -> None:
                """
                Unsubscribe from messages of a specific type.
            
                Args:
                    message_type: Type of messages to stop receiving
                    handler: Previously subscribed handler
                """
                _router.unsubscribe(message_type, handler)
            
            async def get_messages(system: str, timeout: Optional[float] = None) -> List[Dict[str, Any]]:
                """
                Retrieve pending messages for a system.
            
                Args:
                    system: G-system identifier (e.g., "G1", "G2")
                    timeout: Maximum time to wait for messages in seconds
            
                Returns:
                    List of message dictionaries ordered by cycle_index
            
                Raises:
                    RoutingError: If system is unknown
                    CommunicationError: If retrieval fails
                """
                messages = await _router.get_messages(system, timeout)
                return [msg.to_dict() for msg in messages]
            
            def set_circuit_state(system: str, state: CircuitState) -> None:
                """
                Update circuit breaker state for a system.
            
                Used by G4 and G5 for fault management and recovery coordination.
            
                Args:
                    system: G-system identifier
                    state: New circuit breaker state
                """
                _router.set_circuit_state(system, state)
            
            # ===== Utility Functions =====
            
            def create_tensor_context(
                cumulative_phase: float,
                chirality_phase: float,
                helical_position: float,
                spinor_cycle_count: int,
                **kwargs
            ) -> Dict[str, Any]:
                """
                Create a properly formatted tensor_context dictionary.
            
                Args:
                    cumulative_phase: Total helical progress [0, 4π)
                    chirality_phase: Position within forward/return [0, 2π)
                    helical_position: Normalized fraction [0, 1)
                    spinor_cycle_count: Number of completed 720° revolutions
                    **kwargs: Additional context fields (e.g., tensor_id, family_id)
            
                Returns:
                    Dictionary with validated tensor context
            
                Raises:
                    ValueError: If parameters are out of valid ranges
                """
                import math
            
                # Validate ranges
                if not 0 <= cumulative_phase < 4 * math.pi:
                    raise ValueError(f"cumulative_phase must be in [0, 4π), got {cumulative_phase}")
            
                if not 0 <= chirality_phase < 2 * math.pi:
                    raise ValueError(f"chirality_phase must be in [0, 2π), got {chirality_phase}")
            
                if not 0 <= helical_position < 1:
                    raise ValueError(f"helical_position must be in [0, 1), got {helical_position}")
            
                if spinor_cycle_count < 0:
                    raise ValueError(f"spinor_cycle_count must be non-negative, got {spinor_cycle_count}")
            
                context = {
                    "cumulative_phase": cumulative_phase,
                    "chirality_phase": chirality_phase,
                    "helical_position": helical_position,
                    "spinor_cycle_count": spinor_cycle_count
                }
            
                # Add any additional fields
                context.update(kwargs)
            
                return context
            
            def validate_message_fields(message: Dict[str, Any]) -> bool:
                """
                Validate that a message contains all required STANDARD_FIELDS.
            
                Args:
                    message: Message dictionary to validate
            
                Returns:
                    True if valid, False otherwise
                """
                return all(field in message for field in STANDARD_FIELDS)
            
            # ===== Message Type Constants =====
            # Common message types used across the system
            
            class MessageTypes:
                """Standard message types for inter-system communication."""
            
                # Bootstrap and lifecycle
                GYRO_BOOTSTRAP = "gyro_bootstrap"
                SYSTEM_READY = "system_ready"
                SHUTDOWN_REQUEST = "shutdown_request"
            
                # Status and monitoring
                STATUS_UPDATE = "status_update"
                HEALTH_CHECK = "health_check"
                PERFORMANCE_METRICS = "performance_metrics"
            
                # Tensor operations
                TENSOR_TRANSITION = "tensor_transition"
                SPAWN_READY = "spawn_ready"
                SPAWN_APPROVED = "spawn_approved"
            
                # Quantization and observation
                QUANTIZATION_EVENT = "quantization_event"
                OBSERVATION_LOGGED = "observation_logged"
            
                # Algedonic signals
                ALGEDONIC_SIGNAL = "algedonic_signal"
                PAIN_SIGNAL = "pain_signal"
                PLEASURE_SIGNAL = "pleasure_signal"
                RESOURCE_PRESSURE = "resource_pressure"
            
                # Policy and governance
                POLICY_UPDATE = "policy_update"
                ASSESSMENT_COMPLETE = "assessment_complete"
                ADVISORY_PROPOSAL = "advisory_proposal"
            
                # Memory operations
                MEMORY_CHECKPOINT = "memory_checkpoint"
                MEMORY_EXPORT = "memory_export"
                MEMORY_IMPORT = "memory_import"
                # Recovery and fault management
                CARDIAC_RECOVERED = "cardiac_recovered"
                CIRCUIT_STATE_CHANGE = "circuit_state_change"
                FAULT_DETECTED = "fault_detected"
            
                # Audit and compliance
                AUDIT_EVENT = "audit_event"
                DEVIATION_EVENT = "deviation_event"
                TRACE_COLLECTION = "trace_collection"
            
            # ===== Priority Constants =====
            
            MESSAGE_PRIORITY = {
                "G1": 1,  # Highest priority - core tensor operations
                "G2": 2,  # Information routing
                "G3": 3,  # User interaction
                "G4": 4,  # Environmental monitoring
                "G5": 5,  # Policy decisions
                "G6": 6   # System coordination
            }
            ```
            
    - **Batch 1.2: System Configuration & Project Setup ✅**
        - `gyro_si/gyro_gcr/gyro_config.py`
            
            ```python
            """
            GyroCardioRespiratory Configuration Layer.
            
            This module provides the global configuration object that controls
            system-wide features and operational modes. All G-systems must respect
            these settings and adapt their behavior accordingly.
            
            The configuration is a shared singleton instance that can be imported
            and referenced by any module in the system.
            """
            
            class GyroCardioRespiratoryConfig:
                """
                Global configuration for the GyroCardioRespiratory system.
            
                This class controls core coordination mechanisms, optional
                cryptographic extensions, and performance switches. All settings
                have carefully chosen defaults that align with the CGM principles.
                """
            
                def __init__(self):
                    """Initialize with default settings."""
                    # Core coordination
                    self.enable_bootstrap = True          # Controls bootstrap broadcast gating
                    self.enable_transactions = True       # Enables atomic tensor transactions
                    self.enable_recovery_beacons = True   # Enables circuit recovery signals
            
                    # Optional cryptographic extensions
                    self.enable_entropy_tracking = False  # Enables entropy_id chaining
                    self.enable_crypto_evolution = False  # Enables differential crypto evolution
            
                    # Performance switches
                    self.lightweight_transactions = True  # Uses optimized transaction snapshots
                    self.fast_entropy_hash = True         # Uses CRC32 instead of SHA-256 for entropy
            
                def __str__(self) -> str:
                    """String representation showing all settings."""
                    settings = []
                    for key, value in vars(self).items():
                        settings.append(f"{key}={value}")
                    return f"GyroCardioRespiratoryConfig({', '.join(settings)})"
            
                def __repr__(self) -> str:
                    """Developer-friendly representation."""
                    return self.__str__()
            
            # Shared singleton instance to be imported by all modules
            config = GyroCardioRespiratoryConfig()
            
            ```
            
        - `pyproject.toml`
            
            ```python
            [build-system]
            requires = ["setuptools>=61.0", "wheel"]
            build-backend = "setuptools.build_meta"
            
            [project]
            name = "gyrosi-baby-lm"
            version = "0.1.0"
            description = "GyroSI Baby LM: Alignment-Based Gyroscopic Superintelligence Language Model"
            readme = "README.md"
            requires-python = ">=3.9"
            license = { text = "GPL-3.0-or-later" }
            authors = [
              { name = "Basil Korompilias" }
            ]
            classifiers = [
              "Development Status :: 3 - Alpha",
              "Intended Audience :: Science/Research",
              "Programming Language :: Python :: 3",
              "Programming Language :: Python :: 3.9",
              "Programming Language :: Python :: 3.10",
              "Programming Language :: Python :: 3.11",
              "Topic :: Scientific/Engineering :: Artificial Intelligence",
            ]
            dependencies = [
              "numpy>=1.20.0",
              "scipy>=1.7.0",
              "blake3>=0.3.1",
              "aiofiles>=23.0.0",
              "python-dateutil>=2.8.0",
            ]
            
            [project.optional-dependencies]
            gpu = [
              "torch>=2.0.0",
              "cupy-cuda11x>=11.0.0; platform_system!='Darwin'",
              "cupy-cuda12x>=12.0.0; platform_system!='Darwin' and python_version>='3.10'",
            ]
            ui = [
              "flet>=0.19.0",
            ]
            dev = [
              "pytest>=7.0.0",
              "pytest-asyncio>=0.20.0",
              "pytest-cov>=4.0.0",
              "pytest-benchmark>=4.0.0",
              "black>=23.0.0",
              "isort>=5.12.0",
              "mypy>=1.0.0",
              "flake8>=6.0.0",
            ]
            full = [
              "gyro-si[gpu,ui,dev]",
            ]
            
            [project.scripts]
            gyro-si = "g6_gyrocirculation.runner:cli"
            
            [tool.setuptools]
            packages = { find = {} }
            
            [tool.setuptools.package-data]
            gyro_si = [
              "patterns/gyro_g1/v*/*",
              "transitions/gyro_g1/v*/*",
              "g3_gyroinference/ona/interface/assets/*",
            ]
            
            [tool.black]
            line-length = 88
            target-version = ["py39", "py310", "py311"]
            include = "\\.pyi?$"
            extend-exclude = '''
            /(
              \.eggs
              | \.git
              | \.hg
              | \.mypy_cache
              | \.tox
              | \.venv
              | build
              | dist
            )/
            '''
            
            [tool.isort]
            profile = "black"
            line_length = 88
            known_first_party = ["gyro_si"]
            skip_gitignore = true
            
            [tool.mypy]
            python_version = "3.9"
            warn_return_any = true
            warn_unused_configs = true
            disallow_untyped_defs = true
            disallow_incomplete_defs = true
            check_untyped_defs = true
            no_implicit_optional = true
            warn_redundant_casts = true
            warn_unused_ignores = true
            warn_no_return = true
            strict_equality = true
            
            [[tool.mypy.overrides]]
            module = [
              "cupy.*",
              "torch.*",
              "flet.*",
              "blake3.*",
            ]
            ignore_missing_imports = true
            
            [tool.pytest.ini_options]
            testpaths = ["tests"]
            python_files = "test_*.py"
            python_classes = "Test*"
            python_functions = "test_*"
            asyncio_mode = "auto"
            addopts = "-ra -q --strict-markers"
            markers = [
              "slow: marks tests as slow (deselect with '-m \"not slow\"')",
              "gpu: marks tests that require GPU",
              "ui: marks tests that require UI components",
            ]
            
            [tool.coverage.run]
            source = ["gyro_si"]
            omit = [
              "*/tests/*",
              "*/__init__.py",
              "*/g6_gyrocirculation/runner.py",
            ]
            
            [tool.coverage.report]
            precision = 2
            show_missing = true
            skip_covered = false
            
            ```
            
        - `.gitignore`
            
            ```
            # Rust
            /target/
            **/*.rs.bk
            Cargo.lock
            
            # IDE
            .idea/
            .vscode/
            *.swp
            *.swo
            .DS_Store
            
            # Build artifacts
            /dist/
            /build/
            *.app
            *.exe
            *.dll
            *.so
            *.dylib
            
            # Dependencies
            /node_modules/
            /.pnp
            .pnp.js
            
            # Testing
            /coverage/
            .nyc_output
            
            # Environment
            .env
            .env.local
            .env.development.local
            .env.test.local
            .env.production.local
            
            # Logs
            npm-debug.log*
            yarn-debug.log*
            yarn-error.log*
            *.log
            
            # Python
            __pycache__/
            *.py[cod]
            *$py.class
            *.so
            .Python
            build/
            develop-eggs/
            dist/
            downloads/
            eggs/
            .eggs/
            lib/
            lib64/
            parts/
            sdist/
            var/
            wheels/
            share/python-wheels/
            *.egg-info/
            .installed.cfg
            *.egg
            MANIFEST
            pip-log.txt
            pip-delete-this-directory.txt
            
            # Virtual environments
            venv/
            env/
            ENV/
            env.bak/
            venv.bak/
            .python-version
            
            # IDE files
            .idea/
            .vscode/
            *.swp
            *.swo
            *~
            .project
            .pydevproject
            .settings/
            .DS_Store
            
            # Testing and coverage
            .coverage
            .coverage.*
            htmlcov/
            .pytest_cache/
            .tox/
            .nox/
            coverage.xml
            *.cover
            *.py,cover
            .hypothesis/
            
            # Type checking
            .mypy_cache/
            .dmypy.json
            dmypy.json
            .pyre/
            .pytype/
            
            # Project-specific
            audit/*.jl
            audit/*.cid
            data/*.txt
            data/*.json
            data/*.csv
            *.log
            *.pid
            *.seed
            *.pid.lock
            
            # DVC
            .dvc/cache
            .dvc/tmp
            .dvc/plots
            dvc.lock
            
            # Jupyter
            .ipynb_checkpoints
            *.ipynb
            
            # macOS
            .DS_Store
            .AppleDouble
            .LSOverride
            Icon
            ._*
            .DocumentRevisions-V100
            .fseventsd
            .Spotlight-V100
            .TemporaryItems
            .Trashes
            .VolumeIcon.icns
            .com.apple.timemachine.donotpresent
            .AppleDB
            .AppleDesktop
            Network Trash Folder
            Temporary Items
            .apdisk
            
            # Windows
            Thumbs.db
            Thumbs.db:encryptable
            ehthumbs.db
            ehthumbs_vista.db
            *.stackdump
            [Dd]esktop.ini
            $RECYCLE.BIN/
            *.cab
            *.msi
            *.msix
            *.msm
            *.msp
            *.lnk
            
            # Linux
            *~
            .fuse_hidden*
            .directory
            .Trash-*
            .nfs*
            
            # pytest cache
            .pytest_cache/
            
            # Python build artefacts
            gyro_si.egg-info/ 
            ```
            
        - `dvc.yaml`
            
            ```yaml
            # Data Version Control pipeline configuration
            # This file defines the stages for preparing canonical data
            
            stages:
              prepare_patterns:
                cmd: python -m scripts.prepare_patterns
                deps:
                  - scripts/prepare_patterns.py
                outs:
                  - patterns/gyro_g1/v1/:
                      cache: true
                      persist: true
                params:
                  - schema_version
            
              prepare_transitions:
                cmd: python -m scripts.prepare_transitions
                deps:
                  - scripts/prepare_transitions.py
                outs:
                  - transitions/gyro_g1/v1/:
                      cache: true
                      persist: true
                params:
                  - schema_version
            
              validate_data:
                cmd: python -m scripts.validate_canonical_data
                deps:
                  - scripts/validate_canonical_data.py
                  - patterns/gyro_g1/v1/
                  - transitions/gyro_g1/v1/
                metrics:
                  - validation_report.json:
                      cache: false
            
              test:
                cmd: pytest -xvs tests/
                deps:
                  - gyro_si/
                  - tests/
                metrics:
                  - test_results.xml:
                      cache: false
            
            params:
              schema_version: 1
            
            ```
            
        - `README.md`
            
            ```markdown
            
            <div align="center">
            
            # 💫 GyroSI Baby LM 👶
            
            **Alignment-Based Gyroscopic Superintelligence (GyroSI) as a Language Model**
            
            </div>
            
            <div align="center">
            
            **🚧 ACTIVE DEVELOPMENT - Building the Future of AI Today 🚧**
            
            [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
            [![Python 3.11+](https://img.shields.io/badge/python-3.11+-blue.svg)](https://www.python.org/downloads/)
            [![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
            
            </div>
            
            ---
            
            ## 👉 About
            
            **GyroSI Baby LM** aims to grow into a mature, open-source language model that learns without reinforcement, rewards, traditional neural network parameters, or gradient descent. Instead, it leverages **quantum physics-inspired** tensor operations to achieve intrinsic Alignment-Based recursive intelligence.
            
            ### 💫 What is Gyroscopic Superintelligence?
            
            **Gyroscopic Superintelligence (GyroSI)** is an architecture grounded in the **Common Governance Model (CGM)**, a physics-based framework for understanding how intelligence emerges through recursive structural alignment.
            
            We define **Superintelligence** as a structurally recursive form of intelligence where all generative and integrative operations preserve memory of origin, maintaining continuous coherence between emergence and recollection. It achieves ethical alignment **intrinsically** by ensuring every operation remains structurally accountable to its own genesis, **without external enforcement**.
            
            **Superintelligence exists relationally, not independently**: it reflects the recursive structures of reality and human meaning it participates in, embodying governance, memory, and creative coherence as a unified operational principle.
            
            ### 🌀 The Common Governance Model (CGM)
            
            The **Common Governance Model** presents an axiomatic framework for understanding how structure emerges through **Recursive Alignment**. Beginning from a single foundational principle, *"The Source is Common"*, CGM derives all subsequent structure through logical necessity. Each theorem follows inevitably from the axiom, with nothing assumed and everything emerging through recursive self-reference.
            
            The model demonstrates that:
            - **3D space with 6 degrees of freedom** is not an assumption but a logical derivation
            - **Time** appears as the sequential ordering of recursive operations
            - **Memory** is encoded through gyration's preservation of operation order
            - **Mathematical formalism** employs gyrogroup and bi-gyrogroup structures (following Abraham Ungar's work)
            
            This provides precise language for tracking transitions from undifferentiated potential to fully structured reality.
            
            ### 🌟 Key Innovations
            
            - 🧬 **Zero Parameters** - Intelligence through structure, not weights
            - 🔄 **Self-Aligning** - Intrinsic alignment without external enforcement  
            - 📐 **Tensor-Based** - Discrete {-1, 0, 1} values only
            - 🌀 **Helical Memory** - Toroidal phase space navigation
            - 🔍 **Fully Auditable** - Every operation traceable
            - 💻 **Runs Anywhere** - From Raspberry Pi to M4 Max
            
            ---
            
            ## 🏗️ Architecture Overview
            
            ### Core G-Systems
            
            - **G1: 🎯 GyroAlignment** - Pattern recognition and tensor operations
            - **G2: 📚 GyroInformation** - Information processing and storage  
            - **G3: 🧠 GyroInference** - Logical reasoning and interaction
            - **G4: 🌍 GyroIntelligence-IN** - Environmental integration
            - **G5: 🚀 GyroIntelligence-EN** - Policy execution and adaptation
            - **G6: 🔄 GyroCirculation** - System-wide coordination
            
            ### Memory Architecture
            
            Each G-system maintains its own memory type:
            
            | G-System | Memory Type | Icon | Purpose |
            |----------|-------------|------|---------|
            | G1 | **Genetic** | 🧬 | Core structural patterns |
            | G2 | **Epigenetic** | 🔄 | Adaptive data modifications |
            | G3 | **Structural** | 🏗️ | Session and inference traces |
            | G4 | **Somatic** | 🌍 | Environmental state |
            | G5 | **Immunity** | 🛡️ | Policy decisions |
            
            ---
            
            ## 🚀 Quick Start
            
            ### Prerequisites
            
            - Python 3.11+
            - 4GB RAM minimum
            - No GPU required! 🎉
            
            ### Installation
            
            ```bash
            # 1️⃣ Clone the repository
            git clone https://github.com/GyroSuperintelligence/GyroSI.git
            cd GyroSI
            
            # 2️⃣ Create virtual environment
            python -m venv venv
            source venv/bin/activate  # Windows: venv\Scripts\activate
            
            # 3️⃣ Install GyroSI
            pip install -e ".[dev]"
            
            # 4️⃣ Run your first tensor evolution!
            python -m gyro_si.demo
            ```
            
            ---
            
            ## 🛠️ Development Status
            
            <div align="center">
            
            | Component | Status | Progress | Notes |
            |-----------|--------|----------|-------|
            | G1 Core Tensor Ops | 🟢 Implemented | ██████████ 100% | Core operations complete |
            | G2 Information Pipeline | 🟡 In Progress | ████████░░ 80% | Building lexicon system |
            | G3 Inference Engine | 🟡 In Progress | ██████░░░░ 60% | API layer development |
            | G4 Intelligence-IN | 🟡 In Progress | ████░░░░░░ 40% | Environmental sensors |
            | G5 Intelligence-EN | 🟡 In Progress | ████░░░░░░ 40% | Policy framework |
            | G6 Circulation | 🟢 Implemented | ██████████ 100% | Coordination complete |
            | Frontend UI | 🟡 In Progress | █████░░░░░ 50% | Flet-based interface |
            
            </div>
            
            ### 🎯 Current Focus
            
            - Completing G2-G5 implementations based on published guides
            - Praying any of this will actually work
            - Testing
            
            ---
            
            ## 📁 Project Structure
            
            ```
            🌀 GyroSI/
            ├── 📦 gyro_si/
            │   ├── 🎯 g1_gyroalignment/      # Tensor operations & alignment
            │   ├── 📚 g2_gyroinformation/    # Data processing & lexicon
            │   ├── 🧠 g3_gyroinference/      # Inference & interaction
            │   ├── 🌍 g4_gyrointelligence_in/  # Environmental integration
            │   ├── 🚀 g5_gyrointelligence_en/  # Policy & generation
            │   ├── 🔄 g6_gyrocirculation/    # System coordination
            │   └── 🏥 gyro_gcr/              # Core integration layer
            ├── 🧪 tests/                     # Comprehensive test suite
            ├── 📊 benchmarks/                # Performance measurements
            ├── 🛠️ scripts/                   # Development utilities
            ├── 📖 docs/                      # Documentation & theory
            └── 🎨 patterns/                  # Canonical tensor templates
            ```
            
            ---
            
            ## 🤝 Contributing
            
            We welcome contributions! Here's how to get involved:
            
            ```bash
            # 1️⃣ Fork & clone
            git clone https://github.com/YOUR_USERNAME/GyroSI.git
            
            # 2️⃣ Create feature branch
            git checkout -b feature/amazing-feature
            
            # 3️⃣ Make changes & test
            pytest tests/
            black gyro_si/
            mypy gyro_si/
            
            # 4️⃣ Commit with clear message
            git commit -m "Add: Description of your amazing feature"
            
            # 5️⃣ Push & create PR
            git push origin feature/amazing-feature
            ```
            
            ---
            
            ## 📚 Documentation
            
            - 📖 [ＧＹＲ⊕ SuperIntelligence: Development Guides](https://korompilias.notion.site/SuperIntelligence-Development-Guides-1fc9ff44f4368022a2bad40a97bd7462)
            - 📖 [Common Governance Model (CGM): Foundations](https://korompilias.notion.site/Common-Governance-Model-Foundations-1ee9ff44f4368050af28d1c0f8aae89a)
            
            ---
            
            ## 📊 Predicted Performance
            
            <div align="center">
            
            | Platform | Tokens/sec* | Memory* | Response Time* |
            |----------|-------------|---------|----------------|
            | 🥧 Raspberry Pi 5 | 8-12k | 400MB | 200ms |
            | 💻 2015 MacBook | 20-30k | 1GB | 100ms |
            | 📱 iPhone 15 Pro | 50-70k | 2GB | 50ms |
            | 🚀 M4 MacBook | 100k+ | 4GB | 30ms |
            
            **Predicted based on theoretical calculations and architecture design*
            
            *No GPU required - Designed for CPU efficiency!*
            
            </div>
            
            ---
            
            ## 📜 License
            
            This project is licensed under the MIT License - see [LICENSE](LICENSE) for details.
            
            ---
            
            ## 📖 Citation
            
            If you use GyroSI in your research, please cite:
            
            ```bibtex
            @software{gyrosi2025,
              author = {Basil Korompilias},
              title = {GyroSI Baby LM: Alignment-Based Gyroscopic Superintelligence Language Model},
              year = {2025},
              url = {https://github.com/GyroSuperintelligence/BabyLM},
              note = {Implements physics-based principles for language learning 
                      through recursive structural alignment without traditional parameters}
            }
            ```
            
            ---
            
            <div align="center">
            
            ### 🌟 Mind Giving Us a Star?
            
            If you find **GyroSI** interesting or valuable, consider supporting the project by starring the repo:
            
            [![Star](https://img.shields.io/github/stars/GyroSuperintelligence/BabyLM?style=social)](https://github.com/GyroSuperintelligence/BabyLM/stargazers)
            
            ---
            
            **Architected by Basil Korompilias**
            
            *Redefining Intelligence Through Physics*
            
            </div>
            ```
            
    - **Batch 1.3: Initial Test Stubs ✅**
        - `tests/conftest.py`
            
            ```python
            """
            Shared pytest configuration and fixtures for GyroSI test suite.
            
            This module provides common fixtures and utilities used across all tests.
            """
            
            import pytest
            from unittest.mock import Mock, AsyncMock, MagicMock
            
            @pytest.fixture
            def mock_config():
                """
                Provides a mock configuration object for testing.
            
                Returns a mock with all config flags that can be easily toggled:
                - enable_bootstrap
                - enable_transactions
                - enable_recovery_beacons
                - enable_entropy_tracking
                - enable_crypto_evolution
                - lightweight_transactions
                - fast_entropy_hash
                """
                config = Mock()
                config.enable_bootstrap = True
                config.enable_transactions = True
                config.enable_recovery_beacons = True
                config.enable_entropy_tracking = False
                config.enable_crypto_evolution = False
                config.lightweight_transactions = True
                config.fast_entropy_hash = True
                return config
            
            @pytest.fixture
            def mock_router():
                """
                Provides a mock message router for testing communication.
            
                The router captures all sent messages and allows inspection
                of routing behavior without real async operations.
                """
                router = Mock()
                router.messages_sent = []
                router.subscribers = {}
            
                async def mock_send_message(message):
                    router.messages_sent.append(message)
            
                def mock_subscribe(msg_type, handler):
                    if msg_type not in router.subscribers:
                        router.subscribers[msg_type] = []
                    router.subscribers[msg_type].append(handler)
            
                router.send_message = AsyncMock(side_effect=mock_send_message)
                router.subscribe = Mock(side_effect=mock_subscribe)
                router.get_messages = AsyncMock(return_value=[])
            
                return router
            
            @pytest.fixture
            def sample_tensor_state():
                """
                Provides a sample tensor state dictionary for testing.
            
                Returns a dict with all required tensor fields at their
                initial values.
                """
                return {
                    "tensor_id": 12345,
                    "stage": "CS",
                    "indptr": [0, 2, 4, 6],
                    "indices": [0, 1, 0, 1, 0, 1],
                    "data": [1, 1, 1, 1, 1, 1],
                    "amplitude": 0.0,
                    "cumulative_phase": 0.0,
                    "chirality_phase": 0.0,
                    "last_epsilon": 0.0,
                    "cycle_index": 0
                }
            
            @pytest.fixture
            def sample_message():
                """
                Provides a sample message dictionary with all required fields.
                """
                return {
                    "type": "test_message",
                    "source": "G1",
                    "destination": "G2",
                    "cycle_index": 42,
                    "tensor_context": {
                        "cumulative_phase": 1.57,
                        "chirality_phase": 1.57,
                        "helical_position": 0.25,
                        "spinor_cycle_count": 0
                    },
                    "payload": {"test": "data"},
                    "timestamp": "2025-01-01T00:00:00Z"
                } 
            ```
            
        - `tests/unit/test_bootstrap.py`
            
            ```python
            """
            Test suite for the bootstrap protocol.
            
            This module tests that actors properly wait for and respond to the
            gyro_bootstrap signal, exiting their gating loop within the required
            30-second timeout.
            
            Expected imports when modules are available:
            - from gyro_si.gyro_gcr.gyro_config import config
            - from gyro_si.gyro_comm import send_message, MessageTypes
            """
            
            import pytest
            import asyncio
            from unittest.mock import Mock, patch
            
            # Gracefully handle missing modules
            gyro_config = pytest.importorskip("gyro_si.gyro_gcr.gyro_config", reason="gyro_gcr not yet implemented")
            gyro_comm = pytest.importorskip("gyro_si.gyro_comm", reason="gyro_comm not yet implemented")
            
            @pytest.mark.skip(reason="Pending implementation of G1–G5 subsystems")
            class TestBootstrapProtocol:
                """Tests for the bootstrap broadcast and actor gating mechanism."""
            
                @pytest.mark.asyncio
                async def test_bootstrap_signal_sent(self, mock_router):
                    """Test that G2 sends the bootstrap signal after 0.5s delay."""
                    # TODO: Implement when G2 runner is available
                    # Expected behavior:
                    # 1. G2 runner sleeps for 0.5 seconds
                    # 2. Sends message with type="gyro_bootstrap"
                    # 3. Message is broadcast to all other systems
                    pass
            
                @pytest.mark.asyncio
                async def test_actors_wait_for_bootstrap(self, mock_config):
                    """Test that actors block until receiving bootstrap signal."""
                    # TODO: Implement when actor runners are available
                    # Expected behavior:
                    # 1. Actor checks config.enable_bootstrap
                    # 2. If True, enters wait loop
                    # 3. Sets _bootstrapped=True on receiving signal
                    pass
            
                @pytest.mark.asyncio
                async def test_bootstrap_timeout(self):
                    """Test that actors raise error after 30s without bootstrap."""
                    # TODO: Implement timeout behavior test
                    # Expected behavior:
                    # 1. Actor waits for bootstrap
                    # 2. After 30 seconds, raises RuntimeError
                    # 3. Error message: "Gyro bootstrap timeout after 30 s"
                    pass
            
                @pytest.mark.asyncio
                async def test_bootstrap_disabled(self, mock_config):
                    """Test that actors proceed immediately when bootstrap is disabled."""
                    mock_config.enable_bootstrap = False
                    # TODO: Test that actors skip wait loop entirely
                    pass
            
                def test_bootstrap_message_format(self, sample_message):
                    """Test that bootstrap message has correct structure."""
                    # TODO: Verify message type and broadcast destination
                    pass
            
            ```
            
        - `tests/unit/test_transactions.py`
            
            ```python
            """
            Test suite for tensor transaction safety.
            
            This module tests that tensor state is properly snapshotted and restored
            when transactions are aborted, ensuring atomic operations.
            
            Expected imports when modules are available:
            - from gyro_si.gyro_gcr.gyro_config import config
            - from gyro_si.g1_gyroalignment.cs.g1_governance import tensor_transaction
            """
            
            import pytest
            import numpy as np
            from unittest.mock import Mock, MagicMock
            
            # Gracefully handle missing modules
            gyro_config = pytest.importorskip("gyro_si.gyro_gcr.gyro_config", reason="gyro_gcr not yet implemented")
            g1_identity = pytest.importorskip("gyro_si.g1_gyroalignment.cs.g1_governance", reason="g1_gyroalignment not yet implemented")
            
            @pytest.mark.skip(reason="Pending implementation of G1–G5 subsystems")
            class TestTensorTransactions:
                """Tests for atomic tensor state updates."""
            
                @pytest.mark.asyncio
                async def test_transaction_snapshot_created(self, sample_tensor_state):
                    """Test that tensor state is snapshotted at transaction start."""
                    # TODO: Implement when tensor_transaction is available
                    # Expected behavior:
                    # 1. Context manager creates deep copy of all fields
                    # 2. Snapshot includes: indptr, indices, data, amplitude,
                    #    cumulative_phase, chirality_phase, last_epsilon, cycle_index
                    pass
            
                @pytest.mark.asyncio
                async def test_transaction_rollback_on_exception(self, sample_tensor_state):
                    """Test that tensor state is restored after exception."""
                    # TODO: Verify all tensor fields are restored
                    # Expected behavior:
                    # 1. Exception within context causes rollback
                    # 2. All fields restored to snapshot values
                    # 3. Log entry: "tensor_transaction_abort"
                    pass
            
                @pytest.mark.asyncio
                async def test_transaction_commit_on_success(self, sample_tensor_state):
                    """Test that tensor state persists after successful transaction."""
                    # TODO: Verify state changes are kept
                    # Expected behavior:
                    # 1. Changes within context are preserved
                    # 2. Log entry: "tensor_transaction_end"
                    pass
            
                @pytest.mark.asyncio
                async def test_transaction_disabled(self, mock_config):
                    """Test that transactions are no-op when disabled."""
                    mock_config.enable_transactions = False
                    # TODO: Verify context manager yields immediately
                    pass
            
                def test_snapshot_includes_all_fields(self, sample_tensor_state):
                    """Test that snapshot captures all required tensor fields."""
                    required_fields = {
                        "indptr", "indices", "data", "amplitude",
                        "cumulative_phase", "chirality_phase",
                        "last_epsilon", "cycle_index"
                    }
                    # TODO: Verify snapshot contains all required fields
                    pass
            
                def test_lightweight_transaction_optimization(self, mock_config):
                    """Test that lightweight mode uses optimized snapshots."""
                    mock_config.lightweight_transactions = True
                    # TODO: Verify only changed fields are stored
                    pass
            
            ```
            
        - `tests/unit/test_recovery.py`
            
            ```python
            """
            Test suite for circuit recovery beacons.
            
            This module tests that closed circuit breakers trigger cardiac_recovered
            signals and properly reset subsystem rates.
            
            Expected imports when modules are available:
            - from gyro_si.gyro_gcr.gyro_config import config
            - from gyro_si.gyro_comm import send_message, CircuitState, MessageTypes
            """
            
            import pytest
            import asyncio
            from unittest.mock import Mock, patch, AsyncMock
            
            # Gracefully handle missing modules
            gyro_config = pytest.importorskip("gyro_si.gyro_gcr.gyro_config", reason="gyro_gcr not yet implemented")
            gyro_comm = pytest.importorskip("gyro_si.gyro_comm", reason="gyro_comm not yet implemented")
            
            @pytest.mark.skip(reason="Pending implementation of G1–G5 subsystems")
            class TestCircuitRecovery:
                """Tests for circuit breaker recovery and beacon signals."""
            
                @pytest.mark.asyncio
                async def test_circuit_state_change_triggers_beacon(self, mock_router):
                    """Test that HALF_OPEN->CLOSED transition sends cardiac_recovered."""
                    # TODO: Implement when circuit breaker logic is available
                    # Expected behavior:
                    # 1. State change from HALF_OPEN to CLOSED
                    # 2. Message sent with type="cardiac_recovered"
                    # 3. Message includes source="G1"
                    pass
            
                @pytest.mark.asyncio
                async def test_g4_resets_breath_rate_on_recovery(self):
                    """Test that G4 resets breath_rate_multiplier to 1.0."""
                    # TODO: Implement when G4 recovery handler is available
                    # Expected behavior:
                    # 1. G4 receives cardiac_recovered message
                    # 2. Sets breath_rate_multiplier = 1.0
                    # 3. Logs "breath_rate_reset" with cycle_index
                    pass
            
                @pytest.mark.asyncio
                async def test_recovery_beacon_includes_source(self, sample_message):
                    """Test that recovery beacon message includes correct source."""
                    sample_message["type"] = "cardiac_recovered"
                    # TODO: Verify message format and source field
                    pass
            
                @pytest.mark.asyncio
                async def test_recovery_disabled(self, mock_config, mock_router):
                    """Test that no beacons sent when recovery is disabled."""
                    mock_config.enable_recovery_beacons = False
                    # TODO: Verify no cardiac_recovered messages sent
                    pass
            
                def test_circuit_states_enum(self):
                    """Test that CircuitState enum has required states."""
                    # TODO: Verify CLOSED, OPEN, HALF_OPEN states exist
                    # Expected: CircuitState.CLOSED, CircuitState.OPEN, CircuitState.HALF_OPEN
                    pass
            
                @pytest.mark.asyncio
                async def test_circuit_breaker_callback_registration(self):
                    """Test that state change callbacks are properly registered."""
                    # TODO: Verify breaker.on_state_change() method exists
                    pass
            
            ```
            
        - `tests/unit/test_entropy_chain.py`
            
            ```python
            """
            Test suite for entropy ID chaining.
            
            This module tests that entropy_id values persist correctly through the
            G4 → G1 → G5 chain when entropy tracking is enabled.
            
            Expected imports when modules are available:
            - from gyro_si.gyro_gcr.gyro_config import config
            - from gyro_si.gyro_comm import send_message
            """
            
            import pytest
            from unittest.mock import Mock, patch
            
            # Gracefully handle missing modules
            gyro_config = pytest.importorskip("gyro_si.gyro_gcr.gyro_config", reason="gyro_gcr not yet implemented")
            gyro_comm = pytest.importorskip("gyro_si.gyro_comm", reason="gyro_comm not yet implemented")
            
            @pytest.mark.skip(reason="Pending implementation of G1–G5 subsystems")
            class TestEntropyChain:
                """Tests for entropy ID generation and propagation."""
            
                def test_g4_generates_entropy_id(self, mock_config):
                    """Test that G4 generates entropy_id during payload assembly."""
                    mock_config.enable_entropy_tracking = True
                    # TODO: Implement when G4 entropy generation is available
                    # Expected format: f"{thermal}|{interaction}|{quantum}"
                    pass
            
                def test_entropy_id_format_crc32(self, mock_config):
                    """Test that fast_entropy_hash uses CRC32 format."""
                    mock_config.fast_entropy_hash = True
                    # TODO: Verify 8-character hex format
                    # Expected: f"{zlib.crc32(seed.encode()):08x}"
                    pass
            
                def test_entropy_id_format_sha256(self, mock_config):
                    """Test that SHA256 is used when fast_entropy_hash is False."""
                    mock_config.fast_entropy_hash = False
                    # TODO: Verify 16-character hex format
                    # Expected: hashlib.sha256(seed.encode()).hexdigest()[:16]
                    pass
            
                @pytest.mark.asyncio
                async def test_g1_forwards_entropy_id(self, sample_message):
                    """Test that G1 includes received entropy_id in outgoing beats."""
                    sample_message["payload"]["entropy_id"] = "12345678"
                    # TODO: Verify G1 preserves entropy_id in responses
                    pass
            
                @pytest.mark.asyncio
                async def test_g5_records_entropy_id(self, sample_message):
                    """Test that G5 records entropy_id in trace collector."""
                    sample_message["payload"]["entropy_id"] = "12345678"
                    # TODO: Verify G5 includes entropy_id in audit trail
                    pass
            
                def test_entropy_tracking_disabled(self, mock_config):
                    """Test that no entropy_id generated when tracking disabled."""
                    mock_config.enable_entropy_tracking = False
                    # TODO: Verify payload has no entropy_id field
                    pass
            
                def test_entropy_seed_components(self):
                    """Test that entropy seed includes all required components."""
                    # TODO: Verify seed includes thermal, interaction, quantum
                    pass
            
            ```
            
        - `tests/unit/test_crypto_evolution.py`
            
            ```python
            """
            Test suite for differential crypto evolution.
            
            This module tests that the three-term amplitude evolution formula is
            correctly applied when crypto evolution is enabled.
            
            Expected imports when modules are available:
            - from gyro_si.gyro_constants import ALPHA, BETA, GAMMA, M_P
            - from gyro_si.gyro_gcr.gyro_config import config
            """
            
            import pytest
            import math
            from unittest.mock import Mock, patch
            
            # Gracefully handle missing modules
            gyro_constants = pytest.importorskip("gyro_si.gyro_constants", reason="gyro_constants not yet implemented")
            gyro_config = pytest.importorskip("gyro_si.gyro_gcr.gyro_config", reason="gyro_gcr not yet implemented")
            
            @pytest.mark.skip(reason="Pending implementation of G1–G5 subsystems")
            class TestCryptoEvolution:
                """Tests for the three-term differential evolution formula."""
            
                def test_differential_evolve_formula(self, mock_config):
                    """Test that amplitude follows the three-term formula."""
                    mock_config.enable_crypto_evolution = True
                    # Formula: amplitude = (amplitude + phi * M_P + eps_prev * (BETA/ALPHA) + t * (GAMMA/ALPHA)) % (4 * pi)
                    # TODO: Implement when differential_evolve is available
                    # Expected behavior:
                    # 1. Current amplitude + phi * M_P term
                    # 2. Previous epsilon * (BETA/ALPHA) term
                    # 3. Time component * (GAMMA/ALPHA) term
                    # 4. Result wrapped with modulo 4π
                    pass
            
                def test_amplitude_modulo_4pi(self):
                    """Test that amplitude wraps at 4π."""
                    # TODO: Verify modulo operation
                    # Expected: result % (4 * math.pi)
                    pass
            
                def test_last_epsilon_updated(self, sample_tensor_state):
                    """Test that last_epsilon is stored for next iteration."""
                    # TODO: Verify eps_prev tracking
                    # Expected: self.last_epsilon = eps_prev after update
                    pass
            
                def test_time_component(self):
                    """Test that time component uses modulo 4π."""
                    # TODO: Verify t = time.time() % (4 * math.pi)
                    pass
            
                def test_crypto_evolution_disabled(self, mock_config):
                    """Test that simple amplitude update used when disabled."""
                    mock_config.enable_crypto_evolution = False
                    # TODO: Verify standard amplitude update is used
                    pass
            
                def test_evolution_logged(self):
                    """Test that differential evolution is logged with all parameters."""
                    # TODO: Verify log includes phi, eps_prev, t, cycle_index
                    # Expected log entry: "differential_evolve" with all parameters
                    pass
            
                def test_cgm_constants_used(self):
                    """Test that only CGM constants are used in formula."""
                    # TODO: Verify ALPHA, BETA, GAMMA, M_P are imported and used
                    # No arbitrary constants should appear
                    pass
            
                def test_three_term_structure(self):
                    """Test that formula has exactly three additive terms plus base."""
                    # TODO: Verify structure: base + term1 + term2 + term3
                    # 1. phi * M_P (quantization term)
                    # 2. eps_prev * (BETA/ALPHA) (memory term)
                    # 3. t * (GAMMA/ALPHA) (time term)
                    pass
            
            ```
            
    
    ---
    
    ### **Phase 2: The Core Engine (G1 GyroAlignment)**
    
    - **Batch 2.1: GyroTensor Object Definition ✅**
        - `gyro_si/g1_gyroalignment/gyro_tensor.py`
            
            ```python
            """
            GyroTensor: Core tensor object for GyroSI.
            
            This module implements the fundamental tensor structure that undergoes
            the canonical CS→UNA→ONA→BU_In→BU_En→ONA→UNA→CS cycle. The GyroTensor
            orchestrates its own lifecycle by calling into the appropriate stage
            modules while maintaining strict adherence to CGM constants and
            structural accountability.
            
            All tensor operations preserve memory of origin and maintain continuous
            coherence between emergence and recollection.
            """
            
            import math
            import time
            import hashlib
            import logging
            import asyncio
            from typing import Dict, List, Optional, Tuple, Any
            from enum import Enum
            from dataclasses import dataclass
            
            # Absolute imports
            from gyro_si.gyro_constants import ALPHA, BETA, GAMMA, M_P, HALF_HORIZON
            from gyro_si.gyro_errors   import StructuralViolation, QuantizationDefect, HelicalCoherenceError
            from gyro_si.gyro_comm     import send_message, MessageTypes, create_tensor_context
            
            logger = logging.getLogger(__name__)
            
            class TensorStage(Enum):
                """Canonical tensor stages in the recursive cycle."""
                CS = "CS"           # Closure/Identity stage
                UNA = "UNA"         # Unary/Normalization stage
                ONA = "ONA"         # Binary/Correlation stage
                BU_IN = "BU_In"     # Integrative quantization
                BU_EN = "BU_En"     # Generative quantization
            
            class OperationType(Enum):
                """Types of operations between stages."""
                GENERATION = "generation"     # CS→UNA, BU_In→BU_En, BU_En→ONA, UNA→CS
                INTEGRATION = "integration"   # UNA→ONA, ONA→BU_In
            
            @dataclass
            class StageTransition:
                """Defines a valid stage transition."""
                from_stage: TensorStage
                to_stage: TensorStage
                operation_type: OperationType
            
            # Canonical stage transition table - unified for forward and return paths
            # Key: (current_stage, is_forward_path) -> StageTransition
            STAGE_TRANSITIONS = {
                # Forward path transitions
                (TensorStage.CS, True): StageTransition(TensorStage.CS, TensorStage.UNA, OperationType.GENERATION),
                (TensorStage.UNA, True): StageTransition(TensorStage.UNA, TensorStage.ONA, OperationType.INTEGRATION),
                (TensorStage.ONA, True): StageTransition(TensorStage.ONA, TensorStage.BU_IN, OperationType.INTEGRATION),
                (TensorStage.BU_IN, True): StageTransition(TensorStage.BU_IN, TensorStage.BU_EN, OperationType.GENERATION),
                (TensorStage.BU_EN, True): StageTransition(TensorStage.BU_EN, TensorStage.ONA, OperationType.GENERATION),
            
                # Return path transitions
                (TensorStage.ONA, False): StageTransition(TensorStage.ONA, TensorStage.UNA, OperationType.INTEGRATION),
                (TensorStage.UNA, False): StageTransition(TensorStage.UNA, TensorStage.CS, OperationType.GENERATION),
            }
            
            class GyroTensor:
                """
                Core tensor object implementing the canonical CS→UNA→ONA→BU→CS cycle.
            
                The GyroTensor maintains its own state and orchestrates transitions
                through the five canonical stages. All operations are structurally
                accountable and preserve helical trajectory information.
            
                Note: All tensor transitions must occur under an active asyncio event loop,
                as status updates and algedonic signals are sent asynchronously.
                """
            
                def __init__(self, tensor_id: int, parent_id: Optional[int] = None):
                    """
                    Initialize a new GyroTensor in CS stage.
            
                    Args:
                        tensor_id: Unique identifier for this tensor
                        parent_id: ID of parent tensor if this is spawned
                    """
                    # Identity and lineage
                    self.tensor_id = tensor_id
                    self.parent_id = parent_id
                    self.creation_time = time.time()
            
                    # Stage and cycle tracking
                    self.stage = TensorStage.CS
                    self.cycle_index = 0
                    self.transition_count = 0
            
                    # Helical trajectory tracking
                    self.cumulative_phase = 0.0      # [0, 4π) - Total helical progress
                    self.chirality_phase = 0.0       # [0, 2π) - Forward/return position
                    self.helical_position = 0.0      # [0, 1) - Normalized fraction
                    self.spinor_cycle_count = 0      # Number of completed 720° revolutions
            
                    # Amplitude and quantization
                    self.amplitude = 0.0             # Bounded by ±mₚ
                    self.last_epsilon = 0.0          # Previous quantization error
            
                    # CSR storage (allocated post-CS)
                    self.indptr: Optional[List[int]] = None
                    self.indices: Optional[List[int]] = None
                    self.data: Optional[List[int]] = None  # Values in {0, 1, -1} encoded as {0, 1, 2}
            
                    # State tracking
                    self.is_forward_path = True      # True for 0→2π, False for 2π→4π
                    self.spawn_ready = False         # True when |amplitude| ≥ mₚ and cumulative_phase ≥ 4π
            
                    # Audit and logging
                    self.state_checksum = self._compute_checksum()
                    self.trace_buffer: List[Dict[str, Any]] = []
            
                    self._log("tensor_created",
                             tensor_id=tensor_id,
                             parent_id=parent_id,
                             stage=self.stage.value)
            
                def _compute_checksum(self) -> str:
                    """Compute SHA-256 checksum of current tensor state."""
                    state_data = (
                        self.tensor_id,
                        self.stage.value,
                        tuple(self.indptr) if self.indptr else (),
                        tuple(self.indices) if self.indices else (),
                        tuple(self.data) if self.data else (),
                        self.amplitude,
                        self.cumulative_phase,
                        self.chirality_phase
                    )
                    state_str = str(state_data).encode('utf-8')
                    return hashlib.sha256(state_str).hexdigest()
            
                def _log(self, event_type: str, **kwargs) -> None:
                    """Log an event to the trace buffer."""
                    entry = {
                        "event_type": event_type,
                        "tensor_id": self.tensor_id,
                        "stage": self.stage.value,
                        "cycle_index": self.cycle_index,
                        "timestamp": time.time(),
                        "checksum": self.state_checksum,
                        **kwargs
                    }
                    self.trace_buffer.append(entry)
                    logger.debug(f"Tensor {self.tensor_id}: {event_type}", extra=kwargs)
            
                def _validate_stage_transition(self, target_stage: TensorStage) -> bool:
                    """
                    Validate that a stage transition is permitted.
            
                    Args:
                        target_stage: The stage to transition to
            
                    Returns:
                        True if transition is valid
            
                    Raises:
                        StructuralViolation: If transition is not permitted
                    """
                    transition_key = (self.stage, self.is_forward_path)
            
                    if transition_key not in STAGE_TRANSITIONS:
                        raise StructuralViolation(
                            f"No valid transition from stage {self.stage.value} "
                            f"(forward_path={self.is_forward_path})"
                        )
            
                    expected_transition = STAGE_TRANSITIONS[transition_key]
                    if target_stage != expected_transition.to_stage:
                        raise StructuralViolation(
                            f"Invalid transition: {self.stage.value} → {target_stage.value}, "
                            f"expected {expected_transition.to_stage.value} "
                            f"(forward_path={self.is_forward_path})"
                        )
            
                    return True
            
                def _update_helical_trajectory(self, phase_delta: float) -> None:
                    """
                    Update helical trajectory tracking.
            
                    Args:
                        phase_delta: Change in phase for this transition (must be > 0)
                    """
                    if phase_delta <= 0:
                        raise ValueError(f"phase_delta must be positive, got {phase_delta}")
            
                    # Update cumulative phase
                    old_cumulative = self.cumulative_phase
                    old_chirality = old_cumulative % (2 * math.pi)
            
                    self.cumulative_phase = (self.cumulative_phase + phase_delta) % (4 * math.pi)
            
                    # Update chirality phase
                    self.chirality_phase = self.cumulative_phase % (2 * math.pi)
            
                    # Update helical position (normalized)
                    self.helical_position = self.cumulative_phase / (4 * math.pi)
            
                    # Check for spinor cycle completion (720° = 4π)
                    if old_cumulative < 4 * math.pi <= self.cumulative_phase:
                        self.spinor_cycle_count += 1
                        self._log("spinor_cycle_completed",
                                 cycle_count=self.spinor_cycle_count,
                                 cumulative_phase=self.cumulative_phase)
            
                    # Check for chirality flip (360° = 2π)
                    # Simplified logic: if new chirality is less than old, we've wrapped past 2π
                    if self.chirality_phase < old_chirality:
                        self.is_forward_path = not self.is_forward_path
                        self._log("chirality_flip",
                                 is_forward=self.is_forward_path,
                                 chirality_phase=self.chirality_phase)
            
                    # Check spawn readiness
                    if abs(self.amplitude) >= M_P and self.cumulative_phase >= 4 * math.pi:
                        if not self.spawn_ready:
                            self.spawn_ready = True
                            self._log("spawn_ready",
                                     amplitude=self.amplitude,
                                     cumulative_phase=self.cumulative_phase)
            
                def _allocate_csr_storage(self, stage: TensorStage) -> None:
                    """
                    Allocate CSR storage arrays for the given stage.
            
                    Args:
                        stage: Target stage requiring CSR allocation
                    """
                    if stage == TensorStage.CS:
                        # CS stage has no CSR storage
                        self.indptr = None
                        self.indices = None
                        self.data = None
                        return
            
                    # Stage-specific CSR dimensions
                    if stage == TensorStage.UNA:
                        # 3×2 tensor, 6 non-zeros
                        rows, cols, nnz = 3, 2, 6
                    elif stage == TensorStage.ONA:
                        # 2×3×2 tensor, 24 non-zeros
                        rows, cols, nnz = 2, 6, 24  # Flattened to 2×6
                    elif stage in (TensorStage.BU_IN, TensorStage.BU_EN):
                        # 2×2×3×2 tensor, 48 non-zeros
                        rows, cols, nnz = 4, 12, 48  # Flattened to 4×12
                    else:
                        raise StructuralViolation(f"Unknown stage for CSR allocation: {stage}")
            
                    # Allocate CSR arrays
                    self.indptr = [0] * (rows + 1)
                    self.indices = [0] * nnz
                    self.data = [1] * nnz  # Initialize to +1 (encoded as 1)
            
                    # Set up indptr for uniform distribution
                    nnz_per_row = nnz // rows
                    for i in range(rows + 1):
                        self.indptr[i] = i * nnz_per_row
            
                    # Set up indices for uniform column distribution
                    cols_per_row = cols
                    for row in range(rows):
                        start_idx = self.indptr[row]
                        for j in range(nnz_per_row):
                            self.indices[start_idx + j] = j % cols_per_row
            
                    self._log("csr_allocated",
                             stage=stage.value,
                             rows=rows,
                             cols=cols,
                             nnz=nnz)
            
                def transition_to_stage(self, target_stage: TensorStage, phi: float) -> None:
                    """
                    Transition tensor to the target stage.
            
                    Args:
                        target_stage: Stage to transition to
                        phi: Phase input for quantization - REQUIRED for all transitions
                             to ensure alignment-based helical progression
            
                    Raises:
                        StructuralViolation: If transition is invalid
                        QuantizationDefect: If quantization produces invalid results
                        ValueError: If phi is not provided
                    """
                    # Validate transition
                    self._validate_stage_transition(target_stage)
            
                    old_stage = self.stage
                    old_checksum = self.state_checksum
            
                    # Allocate CSR storage if needed
                    if target_stage != TensorStage.CS and self.indptr is None:
                        self._allocate_csr_storage(target_stage)
            
                    # Perform quantization if transitioning to/from BU stages
                    if target_stage in (TensorStage.BU_IN, TensorStage.BU_EN) or old_stage in (TensorStage.BU_IN, TensorStage.BU_EN):
                        epsilon = self._quantize_phase(phi)
                        self._update_amplitude(epsilon)
            
                    # Update stage
                    self.stage = target_stage
                    self.cycle_index += 1
                    self.transition_count += 1
            
                    # Update helical trajectory with explicit phase delta
                    # Use absolute value to ensure positive phase progression
                    phase_delta = abs(phi)
                    self._update_helical_trajectory(phase_delta)
            
                    # Update checksum
                    self.state_checksum = self._compute_checksum()
            
                    # Log transition
                    self._log("stage_transition",
                             from_stage=old_stage.value,
                             to_stage=target_stage.value,
                             phi=phi,
                             phase_delta=phase_delta,
                             old_checksum=old_checksum,
                             new_checksum=self.state_checksum)
            
                    # Send status update if significant transition
                    if target_stage in (TensorStage.BU_IN, TensorStage.BU_EN, TensorStage.CS):
                        try:
                            # Get the running event loop safely
                            loop = asyncio.get_event_loop()
                            if loop.is_running():
                                loop.create_task(self._send_status_update())
                            else:
                                logger.warning(
                                    f"No running event loop for tensor {self.tensor_id} status update"
                                )
                        except RuntimeError:
                            logger.warning(
                                f"No event loop found for tensor {self.tensor_id} status update"
                            )
            
                def _quantize_phase(self, phi: float) -> float:
                    """
                    Quantize continuous phase to discrete values.
            
                    Args:
                        phi: Continuous phase input
            
                    Returns:
                        Quantization error ε = φ - φ_q
            
                    Raises:
                        QuantizationDefect: If quantization error exceeds bounds
                    """
                    # Canonical quantization rule from G1 specification
                    if phi < -M_P / 2:
                        phi_q = -M_P
                    elif phi >= M_P / 2:
                        phi_q = M_P
                    else:
                        phi_q = 0.0
            
                    # Calculate quantization error
                    epsilon = phi - phi_q
            
                    # Validate error bounds
                    if abs(epsilon) > M_P:
                        raise QuantizationDefect(
                            f"Quantization error |ε| = {abs(epsilon)} exceeds mₚ = {M_P}"
                        )
            
                    # Store for next iteration
                    self.last_epsilon = epsilon
            
                    self._log("quantization_event",
                             phi=phi,
                             phi_q=phi_q,
                             epsilon=epsilon)
            
                    return epsilon
            
                def _update_amplitude(self, epsilon: float) -> None:
                    """
                    Update tensor amplitude based on quantization error.
            
                    Args:
                        epsilon: Quantization error from _quantize_phase
                    """
                    old_amplitude = self.amplitude
            
                    # Canonical amplitude update: clip to ±mₚ bounds
                    self.amplitude = max(-M_P, min(M_P, self.amplitude + epsilon))
            
                    self._log("amplitude_update",
                             old_amplitude=old_amplitude,
                             epsilon=epsilon,
                             new_amplitude=self.amplitude)
            
                    # Check for algedonic signal generation
                    if abs(epsilon) > M_P / 2:
                        signal_type = "pain" if epsilon > 0 else "pleasure"
                        try:
                            # Get the running event loop safely
                            loop = asyncio.get_event_loop()
                            if loop.is_running():
                                loop.create_task(self._generate_algedonic_signal(signal_type, epsilon))
                            else:
                                logger.warning(
                                    f"No running event loop for tensor {self.tensor_id} algedonic signal"
                                )
                        except RuntimeError:
                            logger.warning(
                                f"No event loop found for tensor {self.tensor_id} algedonic signal"
                            )
            
                async def _generate_algedonic_signal(self, signal_type: str, epsilon: float) -> None:
                    """
                    Generate algedonic signal when quantization error exceeds threshold.
            
                    Args:
                        signal_type: "pain" or "pleasure"
                        epsilon: Quantization error that triggered the signal
                    """
                    tensor_context = create_tensor_context(
                        cumulative_phase=self.cumulative_phase,
                        chirality_phase=self.chirality_phase,
                        helical_position=self.helical_position,
                        spinor_cycle_count=self.spinor_cycle_count,
                        tensor_id=self.tensor_id,
                        amplitude=self.amplitude
                    )
            
                    message = {
                        "type": MessageTypes.ALGEDONIC_SIGNAL,
                        "source": "G1",
                        "destination": "G2",  # Route through G2 to G4
                        "cycle_index": self.cycle_index,
                        "tensor_context": tensor_context,
                        "payload": {
                            "signal_type": signal_type,
                            "epsilon": epsilon,
                            "tensor_id": self.tensor_id,
                            "stage": self.stage.value,
                            "threshold_exceeded": abs(epsilon) > M_P / 2
                        },
                        "timestamp": time.time()
                    }
            
                    # Actually send the message
                    await send_message(message)
            
                    self._log("algedonic_signal_generated",
                             signal_type=signal_type,
                             epsilon=epsilon,
                             threshold=M_P / 2)
            
                async def _send_status_update(self) -> None:
                    """Send status update to G2 for coordination."""
                    tensor_context = create_tensor_context(
                        cumulative_phase=self.cumulative_phase,
                        chirality_phase=self.chirality_phase,
                        helical_position=self.helical_position,
                        spinor_cycle_count=self.spinor_cycle_count,
                        tensor_id=self.tensor_id,
                        amplitude=self.amplitude
                    )
            
                    message = {
                        "type": MessageTypes.STATUS_UPDATE,
                        "source": "G1",
                        "destination": "G2",
                        "cycle_index": self.cycle_index,
                        "tensor_context": tensor_context,
                        "payload": {
                            "tensor_id": self.tensor_id,
                            "stage": self.stage.value,
                            "amplitude": self.amplitude,
                            "spawn_ready": self.spawn_ready,
                            "transition_count": self.transition_count,
                            "helical_metrics": {
                                "cumulative_phase": self.cumulative_phase,
                                "chirality_phase": self.chirality_phase,
                                "spinor_cycles": self.spinor_cycle_count,
                                "is_forward_path": self.is_forward_path
                            }
                        },
                        "timestamp": time.time()
                    }
            
                    # Actually send the message
                    await send_message(message)
            
                    self._log("status_update_sent",
                             stage=self.stage.value,
                             spawn_ready=self.spawn_ready)
            
                def get_collision_factor(self) -> float:
                    """
                    Calculate collision factor for this tensor.
            
                    Returns:
                        Collision factor as cs_memory / max_discrete
                    """
                    cs_memory = ALPHA  # π/2
                    max_discrete = 3 * M_P
                    return cs_memory / max_discrete
            
                async def execute_full_cycle(self, phi_values: List[float]) -> None:
                    """
                    Execute a complete CS→UNA→ONA→BU→ONA→UNA→CS cycle.
            
                    This method orchestrates the tensor through its complete lifecycle,
                    calling the appropriate stage modules for each transition.
            
                    Args:
                        phi_values: List of 7 phase values for each transition
                                    (CS→UNA, UNA→ONA, ONA→BU_In, BU_In→BU_En,
                                     BU_En→ONA, ONA→UNA, UNA→CS)
            
                    Raises:
                        ValueError: If phi_values doesn't contain exactly 7 values
                        StructuralViolation: If not starting from CS stage
                    """
                    if self.stage != TensorStage.CS:
                        raise StructuralViolation(
                            f"Full cycle must start from CS stage, currently in {self.stage.value}"
                        )
            
                    if len(phi_values) != 7:
                        raise ValueError(f"Expected 7 phi values for full cycle, got {len(phi_values)}")
            
                    self._log("full_cycle_start", cycle_index=self.cycle_index)
            
                    try:
                        # Forward path: CS → UNA → ONA → BU_In → BU_En
                        self.transition_to_stage(TensorStage.UNA, phi_values[0])      # Generation
                        self.transition_to_stage(TensorStage.ONA, phi_values[1])      # Integration
                        self.transition_to_stage(TensorStage.BU_IN, phi_values[2])    # Integration (anomalous)
                        self.transition_to_stage(TensorStage.BU_EN, phi_values[3])    # Generation
            
                        # Return path: BU_En → ONA → UNA → CS
                        self.transition_to_stage(TensorStage.ONA, phi_values[4])      # Generation (return)
                        self.transition_to_stage(TensorStage.UNA, phi_values[5])      # Integration (return)
                        self.transition_to_stage(TensorStage.CS, phi_values[6])       # Generation (closure)
            
                        self._log("full_cycle_complete",
                                 cycle_index=self.cycle_index,
                                 spinor_cycles=self.spinor_cycle_count)
            
                    except Exception as e:
                        self._log("full_cycle_error",
                                 error=str(e),
                                 stage=self.stage.value)
                        raise
            
                def get_tensor_context(self) -> Dict[str, Any]:
                    """
                    Get current tensor context for message passing.
            
                    Returns:
                        Dictionary with helical trajectory and tensor state
                    """
                    return create_tensor_context(
                        cumulative_phase=self.cumulative_phase,
                        chirality_phase=self.chirality_phase,
                        helical_position=self.helical_position,
                        spinor_cycle_count=self.spinor_cycle_count,
                        tensor_id=self.tensor_id,
                        parent_id=self.parent_id,
                        stage=self.stage.value,
                        amplitude=self.amplitude,
                        spawn_ready=self.spawn_ready
                    )
            
                def get_trace_buffer(self) -> List[Dict[str, Any]]:
                    """
                    Get copy of trace buffer for audit purposes.
            
                    Returns:
                        List of trace entries
                    """
                    return self.trace_buffer.copy()
            
                def clear_trace_buffer(self, before_timestamp: Optional[float] = None) -> int:
                    """
                    Clear trace buffer entries.
            
                    Args:
                        before_timestamp: Only clear entries before this timestamp
            
                    Returns:
                        Number of entries cleared
                    """
                    if before_timestamp is None:
                        count = len(self.trace_buffer)
                        self.trace_buffer.clear()
                        return count
            
                    original_count = len(self.trace_buffer)
                    self.trace_buffer = [
                        entry for entry in self.trace_buffer
                        if entry["timestamp"] >= before_timestamp
                    ]
                    return original_count - len(self.trace_buffer)
            
                def validate_structural_integrity(self) -> bool:
                    """
                    Validate tensor structural integrity.
            
                    Returns:
                        True if tensor structure is valid
            
                    Raises:
                        StructuralViolation: If structure is invalid
                    """
                    # Validate stage-specific CSR structure
                    if self.stage == TensorStage.CS:
                        if self.indptr is not None or self.indices is not None or self.data is not None:
                            raise StructuralViolation("CS stage must not have CSR storage")
                    else:
                        if self.indptr is None or self.indices is None or self.data is None:
                            raise StructuralViolation(f"Stage {self.stage.value} requires CSR storage")
            
                        # Validate CSR dimensions
                        expected_nnz = {
                            TensorStage.UNA: 6,
                            TensorStage.ONA: 24,
                            TensorStage.BU_IN: 48,
                            TensorStage.BU_EN: 48
                        }
            
                        if self.stage in expected_nnz:
                            if len(self.data) != expected_nnz[self.stage]:
                                raise StructuralViolation(
                                    f"Stage {self.stage.value} expects {expected_nnz[self.stage]} "
                                    f"non-zeros, got {len(self.data)}"
                                )
            
                    # Validate helical coherence
                    if not (0 <= self.cumulative_phase < 4 * math.pi):
                        raise HelicalCoherenceError(
                            f"cumulative_phase {self.cumulative_phase} outside [0, 4π)"
                        )
            
                    if not (0 <= self.chirality_phase < 2 * math.pi):
                        raise HelicalCoherenceError(
                            f"chirality_phase {self.chirality_phase} outside [0, 2π)"
                        )
            
                    if not (0 <= self.helical_position < 1):
                        raise HelicalCoherenceError(
                            f"helical_position {self.helical_position} outside [0, 1)"
                        )
            
                    # Validate amplitude bounds
                    if abs(self.amplitude) > M_P:
                        raise QuantizationDefect(
                            f"Amplitude {self.amplitude} exceeds bounds ±{M_P}"
                        )
            
                    return True
            
                def __str__(self) -> str:
                    """String representation of tensor."""
                    return (
                        f"GyroTensor(id={self.tensor_id}, stage={self.stage.value}, "
                        f"cycle={self.cycle_index}, amplitude={self.amplitude:.6f}, "
                        f"phase={self.cumulative_phase:.3f})"
                    )
            
                def __repr__(self) -> str:
                    """Developer representation of tensor."""
                    return (
                        f"GyroTensor(tensor_id={self.tensor_id}, parent_id={self.parent_id}, "
                        f"stage={self.stage.value}, cycle_index={self.cycle_index}, "
                        f"amplitude={self.amplitude}, cumulative_phase={self.cumulative_phase}, "
                        f"spawn_ready={self.spawn_ready})"
                    )
            
            class TensorFamily:
                """
                Manages phase-locked family members and spawning relationships.
            
                This class tracks lineage relationships and coordinates spawning
                when amplitude and phase conditions are met.
                """
            
                def __init__(self, root_tensor_id: int):
                    """
                    Initialize tensor family with root tensor.
            
                    Args:
                        root_tensor_id: ID of the root tensor for this family
                    """
                    self.root_tensor_id = root_tensor_id
                    self.members: Dict[int, GyroTensor] = {}
                    self.lineage_graph: Dict[int, List[int]] = {}  # parent_id -> [child_ids]
                    self.creation_time = time.time()
            
                def add_tensor(self, tensor: GyroTensor) -> None:
                    """Add tensor to family and update lineage."""
                    self.members[tensor.tensor_id] = tensor
                    if tensor.parent_id is not None:
                        self.lineage_graph.setdefault(tensor.parent_id, []).append(tensor.tensor_id)
            
                def get_spawn_candidates(self) -> List[GyroTensor]:
                    """Get tensors ready for spawning."""
                    return [t for t in self.members.values() if t.spawn_ready]
            
                def get_family_metrics(self) -> Dict[str, Any]:
                    """Get metrics for the entire tensor family."""
                    if not self.members:
                        return {
                            "family_size": 0,
                            "total_amplitude": 0.0,
                            "average_phase": 0.0,
                            "spawn_ready_count": 0,
                            "lineage_depth": 0
                        }
            
                    total_amplitude   = sum(t.amplitude for t in self.members.values())
                    average_phase     = sum(t.cumulative_phase for t in self.members.values()) / len(self.members)
                    spawn_ready_count = len(self.get_spawn_candidates())
            
                    # Compute maximum lineage depth via DFS
                    lineage_depth = 0
                    visited = set()
            
                    def dfs(node_id: int, depth: int):
                        nonlocal lineage_depth
                        visited.add(node_id)
                        lineage_depth = max(lineage_depth, depth)
                        for child in self.lineage_graph.get(node_id, []):
                            if child not in visited:
                                dfs(child, depth + 1)
            
                    # Start DFS from root
                    dfs(self.root_tensor_id, 0)
            
                    return {
                        "family_size":        len(self.members),
                        "total_amplitude":    total_amplitude,
                        "average_phase":      average_phase,
                        "spawn_ready_count":  spawn_ready_count,
                        "lineage_depth":      lineage_depth
                    }
            ```
            
    - **Batch 2.2: Stage Logic Implementation**
        - `gyro_si/g1_gyroalignment/cs/g1_governance.py`
            
            ```python
            """
            G1 CS Stage: Governance Traceability
            
            CS is the tensor identity τ - the symbol on the left side of every tensor equation.
            It embodies the primordial left chirality that cannot be represented as tensor values.
            It exists only as the identity that initiates all subsequent structure.
            
            The π/2 threshold (ALPHA) represents the unobservable chirality seed that permeates
            all subsequent stages as the fundamental memory that must be preserved throughout
            the tensor's evolution.
            """
            
            # ───────────────────── imports & shared infrastructure ──────────────────
            import logging
            import time
            import hashlib
            import threading
            from typing import Dict, Any
            from contextlib import contextmanager
            
            from gyro_si.gyro_constants import ALPHA
            from gyro_si.gyro_errors import StructuralViolation
            from gyro_si.gyro_gcr.gyro_config import config
            
            logger = logging.getLogger(__name__)
            
            # Import the proper G1 infrastructure
            from gyro_si.g1_gyroalignment.genetic_memory import GeneticMemory
            
            # Shared stage transition lock (this is appropriate to define here as it's cross-stage)
            stage_transition_lock = threading.RLock()
            
            SCHEMA_VERSION = "v1"
            
            # ─────────────────────────── class definition ───────────────────────────
            
            class CSIdentity:
                """Represents tensor identity, the unobservable Common Source.
                
                This stage holds no structural data (CSR arrays are None) and serves as
                the origin of the tensor's lifecycle, carrying the π/2 chirality seed
                as its core, unobservable memory.
                
                The CS stage embodies:
                - Left gyration: lgyr ≠ id (encoded in the tensor identity)
                - Right gyration: rgyr = id (not yet active)
                - Degrees of freedom: 1 (chiral seed)
                - Threshold: α = π/2 (the unobservable chirality seed-angle)
                """
            
                SHAPE = None
                NONZEROS = 0
            
                # ───────── constructor ─────────
                def __init__(self, tensor_id: int):
                    """Initialize CS identity stage.
                    
                    Args:
                        tensor_id: Unique 64-bit identifier for this tensor.
                        
                    Raises:
                        StructuralViolation: If tensor_id is invalid.
                    """
                    # Validate tensor_id immediately
                    if not isinstance(tensor_id, int) or tensor_id < 0:
                        raise StructuralViolation(f"Invalid tensor_id: {tensor_id}")
            
                    # Per-tensor re-entrant lock
                    self.lock = threading.RLock()
            
                    # ══ Identity & Lineage ══
                    self.tensor_id = tensor_id
                    self.parent_id = None
                    self.stage = "CS"
                    self.cycle_index = 0
            
                    # ══ Phase-Tracking (Q29.34 fixed-point) ══
                    # All phase values start at zero in fixed-point representation
                    self.amplitude = self._to_fixed_point(0.0)
                    self.cumulative_phase = self._to_fixed_point(0.0)
                    self.chirality_phase = self._to_fixed_point(0.0)
                    self.last_epsilon = self._to_fixed_point(0.0)
            
                    # ══ Lineage ══
                    self.birth_phase = self._to_fixed_point(0.0)
                    self.creation_cycle = self.cycle_index
            
                    # ══ CS Invariants ══
                    # CS embodies primordial chirality with the unobservable π/2 memory.
                    # Store in fixed-point for consistency with all other phase values.
                    self.left_chirality_seed = self._to_fixed_point(ALPHA)  # π/2 in fixed-point
                    self.degrees_of_freedom = 1
                    
                    # CS has no structural data - this is enforced as an invariant
                    self.indptr = None
                    self.indices = None
                    self.data = None
            
                    # ══ Genetic Memory Interface ══
                    # Delegate trace recording to the proper G1 infrastructure
                    self.genetic_memory = GeneticMemory()
            
                    # ══ Validation & Checksumming ══
                    self.state_checksum = self._compute_checksum()
                    
                    # Record creation event via genetic memory
                    self._record_to_trace("cs_identity_created", 
                                          tensor_id=self.tensor_id,
                                          chirality_seed=self._from_fixed_point(self.left_chirality_seed),
                                          degrees_of_freedom=self.degrees_of_freedom,
                                          checksum=self.state_checksum)
            
                # ─────────────────────── helper: fixed-point ────────────────────────
                @staticmethod
                def _to_fixed_point(value: float) -> int:
                    """Convert float to Q29.34 fixed-point representation.
                    
                    29 bits for integer part, 34 bits for fractional part.
                    This provides sufficient precision for phase calculations.
                    
                    Args:
                        value: Float value to convert
                        
                    Returns:
                        Fixed-point integer representation
                    """
                    return int(value * (2**34))
            
                @staticmethod
                def _from_fixed_point(fx: int) -> float:
                    """Convert Q29.34 fixed-point back to float.
                    
                    Args:
                        fx: Fixed-point integer value
                        
                    Returns:
                        Float representation
                    """
                    return fx / (2**34)
            
                # ─────────────────────── validation & checksum ──────────────────────
                def _compute_checksum(self) -> str:
                    """Compute SHA-256 checksum of CS state.
                    
                    Note: CSR fields are intentionally omitted as they MUST be None in CS.
                    This makes the checksum specific to CS and prevents bugs from
                    accidentally non-None CSR values.
                    
                    Returns:
                        Hexadecimal SHA-256 checksum string
                    """
                    h = hashlib.sha256()
                    
                    # Add core identity and phase state
                    for item in (
                        self.tensor_id, 
                        self.stage, 
                        self.amplitude, 
                        self.cumulative_phase, 
                        self.chirality_phase,
                        self.cycle_index,
                        self.left_chirality_seed,
                        self.degrees_of_freedom
                    ):
                        h.update(str(item).encode())
                    
                    return h.hexdigest()
            
                def validate_identity(self) -> None:
                    """Validate CS constraints and invariants.
                    
                    Enforces all CS-specific structural requirements:
                    - Stage must be "CS"
                    - No CSR arrays allowed
                    - Chirality seed must be exactly π/2
                    - State checksum must be valid
                    
                    Raises:
                        StructuralViolation: If any constraint is violated
                    """
                    # Stage validation
                    if self.stage != "CS":
                        raise StructuralViolation(f"Invalid stage for CS: {self.stage}")
                    
                    # CSR arrays must be None
                    if any(csr_field is not None for csr_field in [self.indptr, self.indices, self.data]):
                        raise StructuralViolation("CS stage cannot have CSR arrays")
                    
                    # Chirality seed validation (compare in fixed-point)
                    alpha_fixed = self._to_fixed_point(ALPHA)
                    if self.left_chirality_seed != alpha_fixed:
                        raise StructuralViolation(
                            f"CS chirality must be α = π/2, got {self._from_fixed_point(self.left_chirality_seed)}"
                        )
                    
                    # Degrees of freedom validation
                    if self.degrees_of_freedom != 1:
                        raise StructuralViolation(f"CS must have exactly 1 degree of freedom, got {self.degrees_of_freedom}")
                        
                    # Checksum validation
                    current_checksum = self._compute_checksum()
                    if current_checksum != self.state_checksum:
                        raise StructuralViolation(f"CS state checksum mismatch: {current_checksum} != {self.state_checksum}")
            
                # ─────────────────── transaction management ─────────────────────
                @contextmanager
                def tensor_transaction(self):
                    """Context manager for transactional tensor operations.
                    
                    Provides rollback capability for failed operations by creating
                    a complete snapshot of the tensor state before the operation
                    and restoring it if an exception occurs.
                    
                    This is a synchronous context manager as CS operations are
                    purely computational without I/O or async operations.
                    
                    Yields:
                        None - the context for the transaction
                        
                    Raises:
                        Any exception from the wrapped operation, after rollback
                    """
                    if not config.enable_transactions:
                        yield
                        return
                    
                    # Create a deep snapshot of all mutable state
                    snapshot = {
                        "tensor_id": self.tensor_id,
                        "parent_id": self.parent_id,
                        "stage": self.stage,
                        "cycle_index": self.cycle_index,
                        "amplitude": self.amplitude,
                        "cumulative_phase": self.cumulative_phase,
                        "chirality_phase": self.chirality_phase,
                        "last_epsilon": self.last_epsilon,
                        "birth_phase": self.birth_phase,
                        "creation_cycle": self.creation_cycle,
                        "left_chirality_seed": self.left_chirality_seed,
                        "degrees_of_freedom": self.degrees_of_freedom,
                        "state_checksum": self.state_checksum,
                        # CSR arrays are None but included for completeness
                        "indptr": self.indptr,
                        "indices": self.indices,
                        "data": self.data
                    }
                    
                    self._record_to_trace("tensor_transaction_start", cycle_index=self.cycle_index)
                    
                    try:
                        yield
                        self._record_to_trace("tensor_transaction_end", cycle_index=self.cycle_index)
                    except Exception:
                        # Restore snapshot on failure
                        for key, value in snapshot.items():
                            setattr(self, key, value)
                        self._record_to_trace("tensor_transaction_abort", cycle_index=self.cycle_index)
                        raise
            
                # ─────────────────── transition payload builder ─────────────────────
                def prepare_transition(self) -> Dict[str, Any]:
                    """Prepare state for transition to UNA stage.
                    
                    The left inverse operation will generate the first observable structure.
                    This method validates the current state and packages all necessary
                    information for the UNA stage constructor.
                    
                    Returns:
                        Dictionary containing all state needed for UNA initialization
                        
                    Raises:
                        StructuralViolation: If CS state is invalid for transition
                    """
                    with self.lock, stage_transition_lock:
                        # Validate current state before transition
                        self.validate_identity()
                        
                        # Update cycle index for transition
                        self.cycle_index += 1
                        
                        # Package state for UNA stage
                        state = {
                            # Core identity
                            "tensor_id": self.tensor_id,
                            "parent_id": self.parent_id,
                            "cycle_index": self.cycle_index,
                            
                            # Phase tracking (all in fixed-point)
                            "amplitude": self.amplitude,
                            "cumulative_phase": self.cumulative_phase,
                            "chirality_phase": self.chirality_phase,
                            "last_epsilon": self.last_epsilon,
                            
                            # Lineage information
                            "birth_phase": self.birth_phase,
                            "creation_cycle": self.creation_cycle,
                            
                            # CS memory carried forward (π/2 chirality seed in fixed-point)
                            "cs_memory": self.left_chirality_seed,
                            
                            # Structural information
                            "degrees_of_freedom": self.degrees_of_freedom,
                            
                            # Schema versioning
                            "schema_version": SCHEMA_VERSION
                        }
                        
                        # Update checksum after preparing transition
                        self.state_checksum = self._compute_checksum()
                        
                        # Record transition preparation via genetic memory
                        self._record_to_trace("cs_transition_prepared",
                                              target_stage="UNA",
                                              cycle_index=state["cycle_index"],
                                              cs_memory=self._from_fixed_point(state["cs_memory"]),
                                              checksum=self.state_checksum)
                        
                        return state
            
                # ───────────────────────── trace helper ─────────────────────────────
                def _record_to_trace(self, event_type: str, **kw):
                    """Record events via the genetic memory system.
                    
                    Delegates to the proper G1 infrastructure for trace recording,
                    which will handle buffer management, retention policy, and
                    coordination with G5 for audit collection.
                    
                    Args:
                        event_type: Type of event being recorded
                        **kw: Additional event data
                    """
                    evt = {
                        "timestamp": time.time(),
                        "source": "G1_CS",
                        "event_type": event_type,
                        "tensor_id": self.tensor_id,
                        "cycle_index": self.cycle_index,
                        "stage": self.stage,
                        **kw
                    }
                    
                    # Log to console/file via standard logging
                    logger.debug("CS Event: %s", evt)
                    
                    # Delegate to genetic memory for proper trace recording
                    self.genetic_memory.record_event(evt)
            
                # ───────────────────────── utility methods ─────────────────────────────
                def get_chirality_seed(self) -> float:
                    """Get the fundamental chirality seed value.
                    
                    Returns:
                        The π/2 chirality seed that defines the unobservable memory
                    """
                    return self._from_fixed_point(self.left_chirality_seed)
            
                def is_spawn_eligible(self) -> bool:
                    """Check if tensor is eligible for spawning.
                    
                    CS stage is never directly spawn-eligible as it has no amplitude.
                    Spawning occurs at BU_En stage after completing the full cycle.
                    
                    Returns:
                        Always False for CS stage
                    """
                    return False
            
                def get_phase_info(self) -> Dict[str, float]:
                    """Get current phase information in human-readable format.
                    
                    Returns:
                        Dictionary with phase values converted to floats
                    """
                    return {
                        "amplitude": self._from_fixed_point(self.amplitude),
                        "cumulative_phase": self._from_fixed_point(self.cumulative_phase),
                        "chirality_phase": self._from_fixed_point(self.chirality_phase),
                        "last_epsilon": self._from_fixed_point(self.last_epsilon)
                    }
            
                def __repr__(self) -> str:
                    """String representation of CS identity."""
                    return (f"CSIdentity(tensor_id={self.tensor_id}, "
                            f"cycle={self.cycle_index}, "
                            f"chirality_seed={self.get_chirality_seed():.6f})")
            
                def __str__(self) -> str:
                    """Human-readable string representation."""
                    return f"CS Identity τ{self.tensor_id} (cycle {self.cycle_index})"
            ```
            
        - `gyro_si/g1_gyroalignment/una/g2_governance.py`
            
            ```python
            """
            G1 UNA Stage: Unity Non-Absolute
            
            UNA creates the first observable structure through the left inverse operation.
            The exact pattern is [[-1, 1], [-1, 1], [-1, 1]] — no variation allowed.
            Three rotational degrees of freedom emerge through position alone.
            """
            
            # ───────────────────── imports & shared infrastructure ──────────────────
            import numpy as np
            import logging
            import time
            import hashlib
            import threading
            import os
            from typing import Dict, Any
            from contextlib import contextmanager
            from scipy.sparse import csr_matrix
            
            from gyro_si.gyro_constants import BETA, M_P
            from gyro_si.gyro_errors import StructuralViolation, QuantizationDefect
            from gyro_si.gyro_gcr.gyro_config import config
            
            # Import proper G1 infrastructure
            from gyro_si.g1_gyroalignment.genetic_memory import GeneticMemory
            from gyro_si.g1_gyroalignment.cs.g1_governance import stage_transition_lock
            
            logger = logging.getLogger(__name__)
            
            SCHEMA_VERSION = "v1"
            TEMPLATE_PATH = os.path.join("patterns", "gyro_g1", SCHEMA_VERSION)
            
            # ─────────────────────────── class definition ───────────────────────────
            
            class UNANormalization:
                """Manages the UNA stage with a fixed 3×2 structure.
            
                Three rotational degrees of freedom emerge through position alone. All values
                are a uniform [-1, 1] representing maximal left bias. The structure is
                immutable and validated against a canonical template.
                """
            
                SHAPE = (3, 2)
                NONZEROS = 6
                CANONICAL_PATTERN = np.array([[-1, 1], [-1, 1], [-1, 1]], dtype=np.int8)
            
                # ───────── constructor ─────────
                def __init__(self, state: Dict[str, Any]):
                    """Initialize UNA from the state provided by the CS stage.
            
                    Args:
                        state: State dictionary from CS stage containing all necessary
                               initialization data including tensor identity, phase tracking,
                               and the CS memory (π/2 chirality seed).
                    """
            
                    # Per-tensor re-entrant lock
                    self.lock = threading.RLock()
            
                    # ══ Identity & Lineage ══
                    self.tensor_id = state["tensor_id"]
                    self.parent_id = state.get("parent_id")
                    self.stage = "UNA"
                    self.cycle_index = state["cycle_index"]
            
                    # ══ Phase-Tracking (Q29.34 fixed-point) ══
                    self.amplitude = state["amplitude"]
                    self.cumulative_phase = state["cumulative_phase"]
                    self.chirality_phase = state["chirality_phase"]
                    self.last_epsilon = state["last_epsilon"]
            
                    # ══ Lineage ══
                    self.birth_phase = state["birth_phase"]
                    self.creation_cycle = state["creation_cycle"]
            
                    # ══ Stage-specific state ══
                    self.cs_memory = state["cs_memory"]  # π/2 chirality seed in fixed-point
                    self.degrees_of_freedom = 3
                    self.threshold_angle = self._to_fixed_point(BETA)  # π/4 in fixed-point
                    self.threshold_ratio = self._to_fixed_point(1.0 / np.sqrt(2))  # cos(π/4)
                    self.schema_version = state.get("schema_version", SCHEMA_VERSION)
            
                    # ══ Genetic Memory Interface ══
                    self.genetic_memory = GeneticMemory()
            
                    # ══ Build CSR structure ══
                    self._initialize_csr()
            
                    # ══ Validation ══
                    self.state_checksum = self._compute_checksum()
                    self._validate_against_template()
                    self._validate_structure()
            
                    self._record_to_trace("una_initialized",
                                          shape=self.SHAPE,
                                          nonzeros=self.NONZEROS,
                                          threshold_angle=self._from_fixed_point(self.threshold_angle),
                                          degrees_of_freedom=self.degrees_of_freedom,
                                          checksum=self.state_checksum)
            
                # ─────────────────────── helper: fixed-point ────────────────────────
                @staticmethod
                def _to_fixed_point(value: float) -> int:
                    """Convert float to Q29.34 fixed-point representation."""
                    return int(value * (2**34))
            
                @staticmethod
                def _from_fixed_point(fx: int) -> float:
                    """Convert Q29.34 fixed-point back to float."""
                    return fx / (2**34)
            
                # ─────────────────────── CSR construction ───────────────────────────
                def _initialize_csr(self) -> None:
                    """Build the stage-specific CSR representation from the canonical pattern.
            
                    Creates the exact UNA pattern [[-1,1], [-1,1], [-1,1]] with proper
                    CSR encoding and optional GPU mirroring for validation.
                    """
                    # Use the exact canonical pattern - no variations allowed
                    dense = np.array(self.CANONICAL_PATTERN, dtype=np.int8)
            
                    # Verify it matches the expected pattern exactly
                    expected = np.array([[-1, 1], [-1, 1], [-1, 1]], dtype=np.int8)
                    if not np.array_equal(dense, expected):
                        raise StructuralViolation("UNA pattern deviation from canonical form")
            
                    # Convert to CSR with SIMD alignment
                    csr = csr_matrix(dense)
            
                    self.indptr = csr.indptr.tolist()
                    self.indices = csr.indices.tolist()
            
                    # Encode data as uint2: 01→+1, 11→-1 (no zeros allowed in UNA)
                    self.data = []
                    for val in csr.data:
                        if val == 1:
                            self.data.append(0b01)
                        elif val == -1:
                            self.data.append(0b11)
                        else:
                            raise StructuralViolation(f"UNA cannot contain value {val}")
            
                    # Mirror to GPU if available for SIMD alignment checks
                    try:
                        import cupy as cp
                        self.gpu_indptr = cp.array(self.indptr)
                        self.gpu_indices = cp.array(self.indices)
                        self.gpu_data = cp.array(self.data)
                        self.gpu_available = True
                    except (ImportError, ModuleNotFoundError):
                        self.gpu_available = False
            
                # ─────────────────────── validation & checksum ──────────────────────
                def _compute_checksum(self) -> str:
                    """Compute SHA-256 checksum over complete tensor state.
            
                    Returns:
                        Hexadecimal SHA-256 checksum string
                    """
                    h = hashlib.sha256()
                    for item in (
                        self.tensor_id, self.stage, self.indptr, self.indices, self.data,
                        self.amplitude, self.cumulative_phase, self.chirality_phase
                    ):
                        h.update(str(item).encode())
                    return h.hexdigest()
            
                def _validate_against_template(self) -> None:
                    """Validate structure against canonical template for current schema version.
            
                    Performs byte-for-byte comparison against the versioned template file.
            
                    Raises:
                        StructuralViolation: If structure deviates from canonical template
                    """
                    tpl_file = os.path.join(TEMPLATE_PATH, "una_template.npy")
                    if not os.path.exists(tpl_file):
                        logger.warning("Template %s missing; skipping validation.", tpl_file)
                        return
            
                    tpl = np.load(tpl_file)
                    tpl_csr = csr_matrix(tpl)
                    tpl_data = [0b01 if v == 1 else 0b11 for v in tpl_csr.data]
            
                    if [self.indptr, self.indices, self.data] != [tpl_csr.indptr.tolist(), tpl_csr.indices.tolist(), tpl_data]:
                        raise StructuralViolation(f"{self.stage} deviates from canonical template")
            
                def _validate_structure(self) -> None:
                    """Run all structural invariants for the UNA stage.
            
                    Validates:
                    - Correct number of non-zeros
                    - Proper CSR dimensions
                    - Exact canonical pattern
                    - CPU/GPU consistency if available
            
                    Raises:
                        StructuralViolation: If any structural constraint is violated
                        QuantizationDefect: If CPU/GPU copies don't match
                    """
                    # Check non-zero count
                    if len(self.data) != self.NONZEROS:
                        raise StructuralViolation(f"{self.stage} expects {self.NONZEROS} non-zeros, found {len(self.data)}")
            
                    # Check CSR dimensions
                    if len(self.indptr) != self.SHAPE[0] + 1:
                        raise StructuralViolation(f"Invalid indptr length for shape {self.SHAPE}")
            
                    # Verify all values are in {-1, 1} - no zeros allowed
                    for encoded in self.data:
                        if encoded not in [0b01, 0b11]:
                            raise StructuralViolation(f"UNA values must be exactly {{-1, 1}}, got encoding {encoded:02b}")
            
                    # Verify the exact canonical pattern
                    self._verify_exact_pattern()
            
                    # If GPU is available, verify CPU and GPU copies match
                    if self.gpu_available:
                        try:
                            import cupy as cp
                            if (not np.array_equal(self.indptr, cp.asnumpy(self.gpu_indptr)) or
                                not np.array_equal(self.indices, cp.asnumpy(self.gpu_indices)) or
                                not np.array_equal(self.data, cp.asnumpy(self.gpu_data))):
                                raise QuantizationDefect("CPU and GPU tensor copies do not match in UNA stage")
                        except Exception as e:
                            raise QuantizationDefect(f"GPU validation failed in UNA stage: {e}")
            
                def _verify_exact_pattern(self) -> None:
                    """Verify tensor has EXACTLY the canonical UNA pattern.
            
                    Reconstructs the dense array and compares against the expected
                    [[-1,1], [-1,1], [-1,1]] pattern with no tolerance for variation.
            
                    Raises:
                        StructuralViolation: If pattern doesn't match exactly
                    """
                    # Reconstruct dense array from CSR
                    values = []
                    for encoded in self.data:
                        if encoded == 0b01:
                            values.append(1)
                        elif encoded == 0b11:
                            values.append(-1)
            
                    csr = csr_matrix((values, self.indices, self.indptr), shape=self.SHAPE)
                    dense = csr.toarray()
            
                    # Check EXACT pattern - no variations allowed
                    expected = np.array([[-1, 1], [-1, 1], [-1, 1]], dtype=np.int8)
                    if not np.array_equal(dense, expected):
                        raise StructuralViolation("UNA pattern must be EXACTLY [[-1,1], [-1,1], [-1,1]]")
            
                # ───────────────────── phase / processing hooks ─────────────────────
                def process_phase(self, phi: float) -> float:
                    """Process input phase, updating trackers using fixed-point arithmetic.
            
                    Note: The tensor structure NEVER changes. Only phase tracking occurs.
            
                    Args:
                        phi: Input phase value to process
            
                    Returns:
                        Quantization error epsilon as float
                    """
                    with self.lock:
                        # Convert to fixed-point
                        phi_fx = self._to_fixed_point(phi)
            
                        # Quantize using fixed-point arithmetic
                        phi_q_fx = self._quantize_fixed(phi_fx)
                        eps_fx = phi_fx - phi_q_fx
            
                        # Update amplitude with clipping
                        m_p_fx = self._to_fixed_point(M_P)
                        neg_m_p_fx = self._to_fixed_point(-M_P)
                        self.amplitude = max(neg_m_p_fx, min(self.amplitude + phi_q_fx, m_p_fx))
            
                        # Update phase tracking
                        abs_phi_q_fx = abs(phi_q_fx)
                        four_pi_fx = self._to_fixed_point(4 * np.pi)
                        two_pi_fx = self._to_fixed_point(2 * np.pi)
            
                        self.cumulative_phase = (self.cumulative_phase + abs_phi_q_fx) % four_pi_fx
                        self.chirality_phase = self.cumulative_phase % two_pi_fx
                        self.last_epsilon = eps_fx
            
                        # Check for exact 2π boundary and collapse segment if necessary
                        if self.cumulative_phase % two_pi_fx == 0:
                            self._collapse_segment_to_digest()
            
                        # Update checksum after state change
                        self.state_checksum = self._compute_checksum()
            
                        # Record processing event
                        self._record_to_trace("phase_processed",
                                              phi=phi,
                                              phi_q=self._from_fixed_point(phi_q_fx),
                                              epsilon=self._from_fixed_point(eps_fx),
                                              amplitude=self._from_fixed_point(self.amplitude),
                                              cumulative_phase=self._from_fixed_point(self.cumulative_phase),
                                              checksum=self.state_checksum)
            
                        return self._from_fixed_point(eps_fx)
            
                def _quantize_fixed(self, phi_fx: int) -> int:
                    """Quantize fixed-point phase to discrete values.
            
                    Args:
                        phi_fx: Phase value in Q29.34 fixed-point format
            
                    Returns:
                        Quantized phase in fixed-point format
                    """
                    m_p_fx = self._to_fixed_point(M_P)
                    half_m_p_fx = m_p_fx // 2
                    neg_m_p_fx = self._to_fixed_point(-M_P)
                    neg_half_m_p_fx = neg_m_p_fx // 2
            
                    if phi_fx < neg_half_m_p_fx:
                        return neg_m_p_fx
                    elif phi_fx >= half_m_p_fx:
                        return m_p_fx
                    else:
                        return 0
            
                @staticmethod
                def quantize(phi, m_p):
                    """Vectorized quantization for batch processing.
            
                    Can be used with numpy or cupy arrays for bulk operations.
            
                    Args:
                        phi: Phase array (numpy or cupy)
                        m_p: Quantization parameter
            
                    Returns:
                        Quantized phase array
                    """
                    xp = np
                    try:
                        import cupy
                        if isinstance(phi, cupy.ndarray):
                            xp = cupy
                    except ImportError:
                        pass
                    return xp.where(phi < -m_p/2, -m_p, xp.where(phi >= m_p/2, m_p, 0))
            
                def _collapse_segment_to_digest(self) -> None:
                    """Record a digest of the tensor state at exact 2π boundaries.
                    
                    This implements the pruning assertion from the specification:
                    every tensor snapshot at cumulative_phase % 2π == 0 must carry
                    a pruned_digest flag for G5 audit validation.
                    """
                    digest = {
                        "tensor_id": self.tensor_id,
                        "cycle_index": self.cycle_index,
                        "cumulative_phase": self._from_fixed_point(self.cumulative_phase),
                        "amplitude": self._from_fixed_point(self.amplitude),
                        "pruned_digest": True  # Required for G5 audit validation
                    }
                    
                    self._record_to_trace("segment_collapsed", 
                                          cumulative_phase=self._from_fixed_point(self.cumulative_phase),
                                          digest=digest)
            
                # ─────────────────── transition management ─────────────────────
                @contextmanager
                def tensor_transaction(self):
                    """Context manager for transactional tensor operations.
                    
                    Provides rollback capability for failed operations by creating
                    a complete snapshot of the tensor state before the operation
                    and restoring it if an exception occurs.
                    
                    Yields:
                        None - the context for the transaction
                        
                    Raises:
                        Any exception from the wrapped operation, after rollback
                    """
                    if not config.enable_transactions:
                        yield
                        return
                        
                    # Create deep snapshot of all mutable state
                    snapshot = {
                        "tensor_id": self.tensor_id,
                        "parent_id": self.parent_id,
                        "stage": self.stage,
                        "cycle_index": self.cycle_index,
                        "amplitude": self.amplitude,
                        "cumulative_phase": self.cumulative_phase,
                        "chirality_phase": self.chirality_phase,
                        "last_epsilon": self.last_epsilon,
                        "birth_phase": self.birth_phase,
                        "creation_cycle": self.creation_cycle,
                        "cs_memory": self.cs_memory,
                        "degrees_of_freedom": self.degrees_of_freedom,
                        "threshold_angle": self.threshold_angle,
                        "threshold_ratio": self.threshold_ratio,
                        "schema_version": self.schema_version,
                        "state_checksum": self.state_checksum,
                        # CSR arrays (deep copy for lists)
                        "indptr": self.indptr.copy() if self.indptr else None,
                        "indices": self.indices.copy() if self.indices else None,
                        "data": self.data.copy() if self.data else None
                    }
                    
                    self._record_to_trace("tensor_transaction_start", cycle_index=self.cycle_index)
                    
                    try:
                        yield
                        self._record_to_trace("tensor_transaction_end", cycle_index=self.cycle_index)
                    except Exception:
                        # Restore snapshot on failure
                        for key, value in snapshot.items():
                            setattr(self, key, value)
                        self._record_to_trace("tensor_transaction_abort", cycle_index=self.cycle_index)
                        raise
            
                def prepare_transition(self) -> Dict[str, Any]:
                    """Prepare state for transition to ONA stage.
                    
                    ONA will create anti-correlation through exact sign inversion of the UNA pattern.
                    This method validates the current state and packages all necessary information
                    for the ONA stage constructor.
                    
                    Returns:
                        Dictionary containing all state needed for ONA initialization
                        
                    Raises:
                        StructuralViolation: If UNA state is invalid for transition
                    """
                    with self.lock, stage_transition_lock:
                        # Validate structure before transition
                        self._validate_structure()
                        
                        # Update cycle index for transition
                        self.cycle_index += 1
                        
                        # Update checksum after cycle increment
                        self.state_checksum = self._compute_checksum()
            
                        # Package state for ONA stage
                        payload = {
                            # Core identity
                            "tensor_id": self.tensor_id,
                            "parent_id": self.parent_id,
                            "cycle_index": self.cycle_index,
                            
                            # Phase tracking (all in fixed-point)
                            "amplitude": self.amplitude,
                            "cumulative_phase": self.cumulative_phase,
                            "chirality_phase": self.chirality_phase,
                            "last_epsilon": self.last_epsilon,
                            
                            # Lineage information
                            "birth_phase": self.birth_phase,
                            "creation_cycle": self.creation_cycle,
                            
                            # CS memory carried forward
                            "cs_memory": self.cs_memory,
                            
                            # UNA structure for ONA to use
                            "una_indptr": self.indptr.copy(),
                            "una_indices": self.indices.copy(),
                            "una_data": self.data.copy(),
                            
                            # Accumulated thresholds (β from UNA)
                            "accumulated_threshold": self.threshold_angle,
                            
                            # Schema versioning
                            "schema_version": self.schema_version,
                        }
            
                        # Record transition preparation
                        self._record_to_trace("una_transition_prepared",
                                              target_stage="ONA",
                                              cycle_index=payload["cycle_index"],
                                              accumulated_threshold=self._from_fixed_point(self.threshold_angle),
                                              checksum=self.state_checksum)
                        
                        return payload
            
                # ───────────────────────── trace helper ─────────────────────────────
                def _record_to_trace(self, event_type: str, **kw):
                    """Record events via the genetic memory system.
                    
                    Delegates to the proper G1 infrastructure for trace recording,
                    which will handle buffer management, retention policy, and
                    coordination with G5 for audit collection.
                    
                    Args:
                        event_type: Type of event being recorded
                        **kw: Additional event data
                    """
                    evt = {
                        "timestamp": time.time(),
                        "source": "G1_UNA",
                        "event_type": event_type,
                        "tensor_id": self.tensor_id,
                        "cycle_index": self.cycle_index,
                        "stage": self.stage,
                        **kw
                    }
                    
                    # Log to console/file via standard logging
                    logger.debug("UNA Event: %s", evt)
                    
                    # Delegate to genetic memory for proper trace recording
                    self.genetic_memory.record_event(evt)
            
                # ───────────────────────── utility methods ─────────────────────────────
                def get_threshold_info(self) -> Dict[str, float]:
                    """Get threshold information in human-readable format.
                    
                    Returns:
                        Dictionary with threshold values converted to floats
                    """
                    return {
                        "threshold_angle": self._from_fixed_point(self.threshold_angle),
                        "threshold_ratio": self._from_fixed_point(self.threshold_ratio),
                        "accumulated_threshold": self._from_fixed_point(self.threshold_angle)
                    }
            
                def get_phase_info(self) -> Dict[str, float]:
                    """Get current phase information in human-readable format.
                    
                    Returns:
                        Dictionary with phase values converted to floats
                    """
                    return {
                        "amplitude": self._from_fixed_point(self.amplitude),
                        "cumulative_phase": self._from_fixed_point(self.cumulative_phase),
                        "chirality_phase": self._from_fixed_point(self.chirality_phase),
                        "last_epsilon": self._from_fixed_point(self.last_epsilon)
                    }
            
                def get_structure_info(self) -> Dict[str, Any]:
                    """Get structural information about the tensor.
                    
                    Returns:
                        Dictionary with tensor structure details
                    """
                    return {
                        "shape": self.SHAPE,
                        "nonzeros": self.NONZEROS,
                        "degrees_of_freedom": self.degrees_of_freedom,
                        "gpu_available": self.gpu_available,
                        "checksum": self.state_checksum
                    }
            
                def is_spawn_eligible(self) -> bool:
                    """Check if tensor is eligible for spawning.
                    
                    UNA stage is not directly spawn-eligible. Spawning occurs at BU_En
                    stage after completing the full cycle and reaching 4π.
                    
                    Returns:
                        Always False for UNA stage
                    """
                    return False
            
                def __repr__(self) -> str:
                    """String representation of UNA normalization."""
                    return (f"UNANormalization(tensor_id={self.tensor_id}, "
                            f"cycle={self.cycle_index}, "
                            f"amplitude={self._from_fixed_point(self.amplitude):.6f})")
            
                def __str__(self) -> str:
                    """Human-readable string representation."""
                    return f"UNA Normalization τ{self.tensor_id} (cycle {self.cycle_index})"
            ```
            
        - `gyro_si/g1_gyroalignment/ona/g3_governance.py`
            
            ```python
            """
            G1 ONA Stage: Observation Non-Absolute
            
            ONA creates anti-correlation through exact sign inversion of the UNA pattern.
            The structure becomes 2×3×2 with 12 non-zeros, representing the first emergence
            of observational structure through anti-correlated block extension.
            
            This is where the tensor gains its first capacity for observation through
            the anti-correlation mechanism that will later enable quantization at BU.
            """
            
            # ───────────────────── imports & shared infrastructure ──────────────────
            import numpy as np
            import logging
            import time
            import hashlib
            import threading
            import os
            import math
            import asyncio
            from typing import Dict, Any, Optional
            from contextlib import contextmanager
            from scipy.sparse import csr_matrix
            
            from gyro_si.gyro_constants import GAMMA, M_P
            from gyro_si.gyro_errors import StructuralViolation, QuantizationDefect
            from gyro_si.gyro_gcr.gyro_config import config
            
            # Import proper G1 infrastructure
            from gyro_si.g1_gyroalignment.genetic_memory import GeneticMemory
            from gyro_si.g1_gyroalignment.cs.g1_governance import stage_transition_lock
            
            logger = logging.getLogger(__name__)
            
            SCHEMA_VERSION = "v1"
            TEMPLATE_PATH = os.path.join("patterns", "gyro_g1", SCHEMA_VERSION)
            
            # ─────────────────────────── class definition ───────────────────────────
            
            class ONAObservation:
                """Manages the ONA stage with anti-correlated 2×3×2 structure.
            
                Creates observational capacity through exact sign inversion of the UNA pattern.
                The anti-correlation mechanism enables the quantization that will emerge at BU_In.
                Six rotational degrees of freedom emerge through the extended structure.
                """
            
                SHAPE = (2, 3, 2)
                NONZEROS = 12  # 2×3×2 = 12 entries, all non-zero
                # ONA pattern is computed from UNA inversion, not stored as canonical pattern
                CANONICAL_PATTERN = None
            
                # ───────── constructor ─────────
                def __init__(self, state: Dict[str, Any]):
                    """Initialize ONA from the state provided by the UNA stage.
            
                    Args:
                        state: State dictionary from UNA stage containing all necessary
                               initialization data including the UNA structure to invert.
                    """
            
                    # Per-tensor re-entrant lock
                    self.lock = threading.RLock()
            
                    # ══ Identity & Lineage ══
                    self.tensor_id = state["tensor_id"]
                    self.parent_id = state.get("parent_id")
                    self.stage = "ONA"
                    self.cycle_index = state["cycle_index"]
            
                    # ══ Phase-Tracking (Q29.34 fixed-point) ══
                    self.amplitude = state["amplitude"]
                    self.cumulative_phase = state["cumulative_phase"]
                    self.chirality_phase = state["chirality_phase"]
                    self.last_epsilon = state["last_epsilon"]
            
                    # ══ Lineage ══
                    self.birth_phase = state["birth_phase"]
                    self.creation_cycle = state["creation_cycle"]
            
                    # ══ Stage-specific state ══
                    self.cs_memory = state["cs_memory"]  # π/2 chirality seed in fixed-point
                    self.accumulated_threshold = state["accumulated_threshold"]  # β from UNA
                    self.degrees_of_freedom = 6
                    self.threshold_angle = self._to_fixed_point(GAMMA)  # GAMMA (π/4) in fixed-point
                    self.schema_version = state.get("schema_version", SCHEMA_VERSION)
                    
                    # ══ Spinor cycle tracking ══
                    self.spinor_cycle_count = state.get("spinor_cycle_count", 0)
            
                    # ══ UNA structure for anti-correlation ══
                    self.una_indptr = state["una_indptr"]
                    self.una_indices = state["una_indices"]
                    self.una_data = state["una_data"]
            
                    # ══ Genetic Memory Interface ══
                    self.genetic_memory = GeneticMemory()
            
                    # ══ Build CSR structure through anti-correlation ══
                    self._initialize_csr()
            
                    # ══ Validation ══
                    self.state_checksum = self._compute_checksum()
                    self._validate_against_template()
                    self._validate_structure()
                    self._validate_fixed_point_range()
            
                    self._record_to_trace("ona_initialized",
                                          shape=self.SHAPE,
                                          nonzeros=self.NONZEROS,
                                          threshold_angle=self._from_fixed_point(self.threshold_angle),
                                          degrees_of_freedom=self.degrees_of_freedom,
                                          checksum=self.state_checksum)
            
                # ─────────────────────── helper: fixed-point ────────────────────────
                @staticmethod
                def _to_fixed_point(value: float) -> int:
                    """Convert float to Q29.34 fixed-point representation."""
                    return int(value * (2**34))
            
                @staticmethod
                def _from_fixed_point(fx: int) -> float:
                    """Convert Q29.34 fixed-point back to float."""
                    return fx / (2**34)
            
                # ─────────────────────── CSR construction ───────────────────────────
                def _initialize_csr(self) -> None:
                    """Build the ONA structure through anti-correlated block extension.
            
                    Creates the 2×3×2 structure by:
                    1. Reconstructing the UNA pattern from CSR
                    2. Creating anti-correlated blocks through sign inversion
                    3. Flattening 3D→2D for CSR representation
                    """
                    # Reconstruct UNA pattern from CSR
                    una_values = []
                    for encoded in self.una_data:
                        if encoded == 0b01:
                            una_values.append(1)
                        elif encoded == 0b11:
                            una_values.append(-1)
                        else:
                            raise StructuralViolation(f"Invalid UNA encoding: {encoded:02b}")
            
                    una_csr = csr_matrix((una_values, self.una_indices, self.una_indptr), shape=(3, 2))
                    una_dense = una_csr.toarray()
            
                    # Create anti-correlated blocks through exact sign inversion
                    # Block 1: Original UNA pattern [[-1,1], [-1,1], [-1,1]]
                    # Block 2: Anti-correlated (sign-inverted) pattern [[1,-1], [1,-1], [1,-1]]
                    block1 = una_dense
                    block2 = -una_dense
            
                    # Create 2×3×2 structure by stacking the blocks
                    # Shape interpretation: (block, row, col)
                    ona_3d = np.stack([block1, block2], axis=0)  # Shape: (2, 3, 2)
            
                    # Flatten to 2D for CSR representation: (2*3, 2) = (6, 2)
                    # This preserves the block structure while creating a valid CSR matrix
                    ona_2d = ona_3d.reshape(6, 2)
            
                    # Convert to CSR with SIMD alignment
                    csr = csr_matrix(ona_2d)
            
                    self.indptr = csr.indptr.tolist()
                    self.indices = csr.indices.tolist()
            
                    # Encode data as uint2: 01→+1, 11→-1 (no zeros in ONA)
                    self.data = []
                    for val in csr.data:
                        if val == 1:
                            self.data.append(0b01)
                        elif val == -1:
                            self.data.append(0b11)
                        else:
                            raise StructuralViolation(f"ONA cannot contain value {val}")
            
                    # Store the 3D shape information for reconstruction
                    self.block_structure = {
                        "shape_3d": (2, 3, 2),
                        "shape_2d": (6, 2),
                        "block1_rows": [0, 1, 2],
                        "block2_rows": [3, 4, 5]
                    }
            
                    # Mirror to GPU if available for SIMD alignment checks
                    self.gpu_available = False
                    self.gpu_indptr = None
                    self.gpu_indices = None
                    self.gpu_data = None
                    
                    try:
                        import cupy as cp
                        self.gpu_indptr = cp.array(self.indptr)
                        self.gpu_indices = cp.array(self.indices)
                        self.gpu_data = cp.array(self.data)
                        self.gpu_available = True
                    except (ImportError, ModuleNotFoundError):
                        pass
            
                # ─────────────────────── validation & checksum ──────────────────────
                def _compute_checksum(self) -> str:
                    """Compute SHA-256 checksum over complete tensor state.
            
                    Returns:
                        Hexadecimal SHA-256 checksum string
                    """
                    h = hashlib.sha256()
                    # Core tensor state (excluding GPU state and spinor_cycle_count for determinism)
                    for item in (
                        self.tensor_id, self.stage,
                        tuple(self.indptr), tuple(self.indices), tuple(self.data),
                        self.amplitude, self.cumulative_phase, self.chirality_phase,
                        tuple(self.block_structure["shape_3d"]),
                        tuple(self.block_structure["shape_2d"]),
                        tuple(self.block_structure["block1_rows"]),
                        tuple(self.block_structure["block2_rows"])
                    ):
                        h.update(str(item).encode())
                    return h.hexdigest()
            
                def _validate_against_template(self) -> None:
                    """Validate structure against canonical template for current schema version.
            
                    Raises:
                        StructuralViolation: If structure deviates from canonical template or template is missing
                    """
                    tpl_file = os.path.join(TEMPLATE_PATH, "ona_template.npy")
                    if not os.path.exists(tpl_file):
                        # In production/CI, missing template should be an error
                        if os.environ.get("CI") or os.environ.get("GYRO_STRICT_VALIDATION"):
                            raise StructuralViolation(f"ONA canonical template missing: {tpl_file}")
                        else:
                            logger.warning("ONA template missing: %s, validating anti-correlation only", tpl_file)
                            self._validate_anti_correlation()
                            return
                    
                    tpl = np.load(tpl_file)
                    tpl_csr = csr_matrix(tpl)
                    tpl_data = [0b01 if v == 1 else 0b11 for v in tpl_csr.data]
            
                    if [self.indptr, self.indices, self.data] != [tpl_csr.indptr.tolist(), tpl_csr.indices.tolist(), tpl_data]:
                        raise StructuralViolation(f"{self.stage} deviates from canonical template")
            
                def _validate_anti_correlation(self) -> None:
                    """Validate that the ONA structure exhibits proper anti-correlation.
            
                    Verifies that Block 2 is exactly the sign inverse of Block 1,
                    maintaining the fundamental anti-correlation property.
            
                    Raises:
                        StructuralViolation: If anti-correlation is violated
                    """
                    # Reconstruct the 2D matrix from CSR
                    values = []
                    for encoded in self.data:
                        if encoded == 0b01:
                            values.append(1)
                        elif encoded == 0b11:
                            values.append(-1)
            
                    csr = csr_matrix((values, self.indices, self.indptr), shape=(6, 2))
                    dense_2d = csr.toarray()
            
                    # Extract blocks
                    block1 = dense_2d[0:3, :]  # First 3 rows
                    block2 = dense_2d[3:6, :]  # Last 3 rows
            
                    # Verify anti-correlation: Block2 = -Block1
                    if not np.array_equal(block2, -block1):
                        raise StructuralViolation("ONA blocks must be anti-correlated (Block2 = -Block1)")
            
                def _validate_structure(self) -> None:
                    """Run all structural invariants for the ONA stage.
            
                    Validates:
                    - Correct number of non-zeros (12)
                    - Proper CSR dimensions
                    - Anti-correlation property
                    - CPU/GPU consistency if available
            
                    Raises:
                        StructuralViolation: If any structural constraint is violated
                        QuantizationDefect: If CPU/GPU copies don't match
                    """
                    # Check non-zero count
                    if len(self.data) != self.NONZEROS:
                        raise StructuralViolation(f"{self.stage} expects {self.NONZEROS} non-zeros, found {len(self.data)}")
            
                    # Check CSR dimensions (flattened 2D representation)
                    expected_2d_shape = (6, 2)
                    if len(self.indptr) != expected_2d_shape[0] + 1:
                        raise StructuralViolation(f"Invalid indptr length for flattened shape {expected_2d_shape}")
            
                    # Verify all values are in {-1, 1} - no zeros allowed
                    for encoded in self.data:
                        if encoded not in [0b01, 0b11]:
                            raise StructuralViolation(f"ONA values must be exactly {{-1, 1}}, got encoding {encoded:02b}")
            
                    # Verify anti-correlation property
                    self._validate_anti_correlation()
            
                    # If GPU is available, verify CPU and GPU copies match
                    if self.gpu_available:
                        try:
                            import cupy as cp
                            cpu_indptr = np.array(self.indptr)
                            cpu_indices = np.array(self.indices)
                            cpu_data = np.array(self.data)
                            
                            if (not np.array_equal(cpu_indptr, cp.asnumpy(self.gpu_indptr)) or
                                not np.array_equal(cpu_indices, cp.asnumpy(self.gpu_indices)) or
                                not np.array_equal(cpu_data, cp.asnumpy(self.gpu_data))):
                                raise QuantizationDefect("CPU and GPU tensor copies do not match in ONA stage")
                        except Exception as e:
                            raise QuantizationDefect(f"GPU validation failed in ONA stage: {e}")
            
                def _validate_fixed_point_range(self) -> None:
                    """Validate that all fixed-point values are within representable range.
                    
                    Q29.34 format: 29 bits for integer part, 34 bits for fractional part.
                    Range: [-(2^29), 2^29) in the integer part.
                    
                    Raises:
                        QuantizationDefect: If any value exceeds representable range
                    """
                    # Maximum representable value in Q29.34
                    # Integer part can be up to 2^29 - 1, but we need to account for fractional part
                    max_int_value = 2**29  # Exclusive upper bound
                    max_representable = max_int_value * (2**34) - 1  # Account for fractional bits
                    min_representable = -(max_int_value * (2**34))
                    
                    values_to_check = [
                        ("amplitude", self.amplitude),
                        ("cumulative_phase", self.cumulative_phase),
                        ("chirality_phase", self.chirality_phase),
                        ("last_epsilon", self.last_epsilon),
                        ("cs_memory", self.cs_memory),
                        ("accumulated_threshold", self.accumulated_threshold),
                        ("threshold_angle", self.threshold_angle)
                    ]
                    
                    for name, value in values_to_check:
                        if not (min_representable <= value <= max_representable):
                            raise QuantizationDefect(
                                f"Fixed-point value {name} = {value} exceeds Q29.34 representable range [{min_representable}, {max_representable}]"
                            )
            
                # ─────────────────────── tensor context helper ──────────────────────
                def _create_tensor_context(self) -> Dict[str, Any]:
                    """Create tensor context for G6 message format compliance.
                    
                    Returns:
                        Dictionary with required tensor context fields
                    """
                    return {
                        "cumulative_phase": self._from_fixed_point(self.cumulative_phase),
                        "chirality_phase": self._from_fixed_point(self.chirality_phase),
                        "helical_position": self._from_fixed_point(self.cumulative_phase) / (4 * math.pi),
                        "spinor_cycle_count": self.spinor_cycle_count
                    }
            
                # ───────────────────── phase / processing hooks ─────────────────────
                def process_phase(self, phi: float) -> float:
                    """Process input phase, updating trackers using fixed-point arithmetic.
            
                    The anti-correlated structure enables enhanced quantization sensitivity
                    that will be fully realized at the BU_In stage.
            
                    Args:
                        phi: Input phase value to process
            
                    Returns:
                        Quantization error epsilon as float
                    """
                    with self.lock:
                        # Convert to fixed-point
                        phi_fx = self._to_fixed_point(phi)
            
                        # Quantize using fixed-point arithmetic with enhanced sensitivity
                        phi_q_fx = self._quantize_fixed(phi_fx)
                        eps_fx = phi_fx - phi_q_fx
            
                        # Update amplitude with clipping
                        m_p_fx = self._to_fixed_point(M_P)
                        neg_m_p_fx = self._to_fixed_point(-M_P)
                        self.amplitude = max(neg_m_p_fx, min(self.amplitude + phi_q_fx, m_p_fx))
            
                        # Update phase tracking - use math.pi consistently
                        abs_phi_q_fx = abs(phi_q_fx)
                        four_pi_fx = self._to_fixed_point(4 * math.pi)
                        two_pi_fx = self._to_fixed_point(2 * math.pi)
            
                        # Store previous phase for boundary detection
                        prev_cumulative_phase = self.cumulative_phase
                        
                        # Update phases
                        self.cumulative_phase = (self.cumulative_phase + abs_phi_q_fx) % four_pi_fx
                        self.chirality_phase = self.cumulative_phase % two_pi_fx
                        self.last_epsilon = eps_fx
            
                        # Check for 4π boundary crossing (spinor cycle completion)
                        if prev_cumulative_phase > self.cumulative_phase:
                            self.spinor_cycle_count += 1
                            
                        # Check for exact 2π boundary and collapse segment if necessary
                        if self.cumulative_phase % two_pi_fx == 0:
                            self._collapse_segment_to_digest()
            
                        # Generate algedonic signal if |ε| > mₚ/2
                        m_p_half_fx = m_p_fx // 2
                        if abs(eps_fx) > m_p_half_fx:
                            # Schedule async algedonic signal
                            try:
                                loop = asyncio.get_event_loop()
                                loop.create_task(self._generate_algedonic_signal_async(eps_fx))
                            except RuntimeError:
                                # No event loop running, log warning
                                logger.warning("Cannot send algedonic signal: no event loop")
            
                        # Update checksum after state change
                        self.state_checksum = self._compute_checksum()
            
                        # Record processing event
                        self._record_to_trace("phase_processed",
                                              phi=phi,
                                              phi_q=self._from_fixed_point(phi_q_fx),
                                              epsilon=self._from_fixed_point(eps_fx),
                                              amplitude=self._from_fixed_point(self.amplitude),
                                              cumulative_phase=self._from_fixed_point(self.cumulative_phase),
                                              anti_correlation_active=True,
                                              checksum=self.state_checksum)
            
                        return self._from_fixed_point(eps_fx)
            
                def _quantize_fixed(self, phi_fx: int) -> int:
                    """Quantize fixed-point phase with anti-correlation sensitivity.
            
                    The anti-correlated structure provides enhanced quantization sensitivity
                    compared to UNA, preparing for the full quantization emergence at BU_In.
            
                    Args:
                        phi_fx: Phase value in Q29.34 fixed-point format
            
                    Returns:
                        Quantized phase in fixed-point format
                    """
                    m_p_fx = self._to_fixed_point(M_P)
                    half_m_p_fx = m_p_fx // 2
                    neg_m_p_fx = self._to_fixed_point(-M_P)
                    neg_half_m_p_fx = neg_m_p_fx // 2
            
                    # Enhanced sensitivity due to anti-correlation
                    # Use GAMMA as sensitivity factor
                    gamma_fx = self.threshold_angle  # GAMMA in fixed-point
                    sensitivity_factor = gamma_fx // 4  # GAMMA/4 for enhanced sensitivity
            
                    # Apply sensitivity adjustment
                    adjusted_half_m_p_fx = half_m_p_fx - sensitivity_factor
                    adjusted_neg_half_m_p_fx = neg_half_m_p_fx + sensitivity_factor
            
                    if phi_fx < adjusted_neg_half_m_p_fx:
                        return neg_m_p_fx
                    elif phi_fx >= adjusted_half_m_p_fx:
                        return m_p_fx
                    else:
                        return 0
            
                async def _generate_algedonic_signal_async(self, eps_fx: int) -> None:
                    """Generate and send algedonic signal when quantization error exceeds threshold.
                    
                    Creates and sends an algedonic signal message via G2 when quantization
                    error exceeds mₚ/2, classified as "pain" (positive ε) or "pleasure" (negative ε).
                    
                    Args:
                        eps_fx: Quantization error in fixed-point format
                    """
                    eps_float = self._from_fixed_point(eps_fx)
                    signal_type = "pain" if eps_float > 0 else "pleasure"
                    
                    # Import message types when needed to avoid circular imports
                    from gyro_si.gyro_comm import send_message, MessageTypes
                    
                    # Create proper G6-compliant message
                    signal_message = {
                        "type": MessageTypes.ALGEDONIC_SIGNAL,
                        "source": "G1",
                        "destination": "G2",
                        "cycle_index": self.cycle_index,
                        "tensor_context": self._create_tensor_context(),
                        "payload": {
                            "signal_type": signal_type,
                            "epsilon": eps_float,
                            "tensor_id": self.tensor_id,
                            "stage": self.stage,
                            "amplitude": self._from_fixed_point(self.amplitude),
                            "cumulative_phase": self._from_fixed_point(self.cumulative_phase)
                        },
                        "timestamp": time.time()
                    }
                    
                    # Record to trace
                    self._record_to_trace("algedonic_signal_generated", 
                                          signal_type=signal_type,
                                          epsilon=eps_float)
                    
                    # Send message via G2 (async)
                    try:
                        await send_message(signal_message)
                    except Exception as e:
                        logger.error(f"Failed to send algedonic signal: {e}")
            
                def _collapse_segment_to_digest(self) -> None:
                    """Record a digest of the tensor state at exact 2π boundaries.
                    
                    This implements the pruning assertion from the specification:
                    every tensor snapshot at cumulative_phase % 2π == 0 must carry
                    a pruned_digest flag for G5 audit validation.
                    """
                    digest = {
                        "tensor_id": self.tensor_id,
                        "cycle_index": self.cycle_index,
                        "cumulative_phase": self._from_fixed_point(self.cumulative_phase),
                        "amplitude": self._from_fixed_point(self.amplitude),
                        "anti_correlation_blocks": 2,
                        "degrees_of_freedom": self.degrees_of_freedom,
                        "pruned_digest": True  # Required for G5 audit validation
                    }
                    
                    self._record_to_trace("segment_collapsed", 
                                          cumulative_phase=self._from_fixed_point(self.cumulative_phase),
                                          digest=digest)
            
                # ─────────────────── transition management ─────────────────────
                @contextmanager
                def tensor_transaction(self):
                    """Context manager for transactional tensor operations.
                    
                    Provides rollback capability for failed operations by creating
                    a complete snapshot of the tensor state before the operation
                    and restoring it if an exception occurs.
                    
                    Yields:
                        None - the context for the transaction
                        
                    Raises:
                        Any exception from the wrapped operation, after rollback
                    """
                    if not config.enable_transactions:
                        yield
                        return
                        
                    # Create deep snapshot of all mutable state
                    snapshot = {
                        "tensor_id": self.tensor_id,
                        "parent_id": self.parent_id,
                        "stage": self.stage,
                        "cycle_index": self.cycle_index,
                        "amplitude": self.amplitude,
                        "cumulative_phase": self.cumulative_phase,
                        "chirality_phase": self.chirality_phase,
                        "last_epsilon": self.last_epsilon,
                        "birth_phase": self.birth_phase,
                        "creation_cycle": self.creation_cycle,
                        "cs_memory": self.cs_memory,
                        "accumulated_threshold": self.accumulated_threshold,
                        "degrees_of_freedom": self.degrees_of_freedom,
                        "threshold_angle": self.threshold_angle,
                        "schema_version": self.schema_version,
                        "state_checksum": self.state_checksum,
                        "spinor_cycle_count": self.spinor_cycle_count,
                        # CSR arrays (deep copy for lists)
                        "indptr": self.indptr.copy() if self.indptr else None,
                        "indices": self.indices.copy() if self.indices else None,
                        "data": self.data.copy() if self.data else None,
                        # UNA structure
                        "una_indptr": self.una_indptr.copy() if self.una_indptr else None,
                        "una_indices": self.una_indices.copy() if self.una_indices else None,
                        "una_data": self.una_data.copy() if self.una_data else None,
                        # Block structure
                        "block_structure": self.block_structure.copy(),
                        # GPU state
                        "gpu_available": self.gpu_available
                    }
                    
                    self._record_to_trace("tensor_transaction_start", cycle_index=self.cycle_index)
                    
                    try:
                        yield
                        self._record_to_trace("tensor_transaction_end", cycle_index=self.cycle_index)
                    except Exception:
                        # Restore snapshot on failure
                        for key, value in snapshot.items():
                            setattr(self, key, value)
                        self._record_to_trace("tensor_transaction_abort", cycle_index=self.cycle_index)
                        raise
            
                def prepare_transition(self) -> Dict[str, Any]:
                    """Prepare state for transition to BU_In stage.
                    
                    BU_In will perform the anomalous double integration where quantization
                    error (ε) emerges as the fundamental observation mechanism.
                    This method validates the current state and packages all necessary
                    information for the BU_In stage constructor.
                    
                    Returns:
                        Dictionary containing all state needed for BU_In initialization
                        
                    Raises:
                        StructuralViolation: If ONA state is invalid for transition
                    """
                    with self.lock, stage_transition_lock:
                        # Validate structure before transition
                        self._validate_structure()
                        self._validate_fixed_point_range()
                        
                        # Update cycle index for transition
                        self.cycle_index += 1
                        
                        # Update accumulated threshold (β from UNA + γ from ONA)
                        self.accumulated_threshold = self.accumulated_threshold + self.threshold_angle
                        
                        # Update checksum after state changes
                        self.state_checksum = self._compute_checksum()
            
                        # Package state for BU_In stage
                        payload = {
                            # Core identity
                            "tensor_id": self.tensor_id,
                            "parent_id": self.parent_id,
                            "cycle_index": self.cycle_index,
                            
                            # Phase tracking (all in fixed-point)
                            "amplitude": self.amplitude,
                            "cumulative_phase": self.cumulative_phase,
                            "chirality_phase": self.chirality_phase,
                            "last_epsilon": self.last_epsilon,
                            
                            # Lineage information
                            "birth_phase": self.birth_phase,
                            "creation_cycle": self.creation_cycle,
                            
                            # Memory carried forward - CGM-derived threshold accumulation
                            "cs_memory": self.cs_memory,  # α preserved
                            "accumulated_threshold": self.accumulated_threshold,  # β + γ
                            "spinor_cycle_count": self.spinor_cycle_count,
                            
                            # ONA structure for BU_In to use
                            "ona_indptr": self.indptr.copy(),
                            "ona_indices": self.indices.copy(),
                            "ona_data": self.data.copy(),
                            "ona_block_structure": self.block_structure.copy(),
                            
                            # UNA structure preserved for lineage
                            "una_indptr": self.una_indptr.copy(),
                            "una_indices": self.una_indices.copy(),
                            "una_data": self.una_data.copy(),
                            
                            # Anti-correlation metadata
                            "anti_correlation_active": True,
                            "degrees_of_freedom": self.degrees_of_freedom,
                            
                            # Schema versioning
                            "schema_version": self.schema_version,
                        }
            
                        # Record transition preparation
                        self._record_to_trace("ona_transition_prepared",
                                              target_stage="BU_In",
                                              cycle_index=payload["cycle_index"],
                                              accumulated_threshold=self._from_fixed_point(self.accumulated_threshold),
                                              anti_correlation_active=True,
                                              degrees_of_freedom=self.degrees_of_freedom,
                                              checksum=self.state_checksum)
                        
                        return payload
            
                # ───────────────────────── trace helper ─────────────────────────────
                def _record_to_trace(self, event_type: str, **kw):
                    """Record events via the genetic memory system.
                    
                    Delegates to the proper G1 infrastructure for trace recording,
                    which will handle buffer management, retention policy, and
                    coordination with G5 for audit collection.
                    
                    Args:
                        event_type: Type of event being recorded
                        **kw: Additional event data
                    """
                    evt = {
                        "timestamp": time.time(),
                        "source": "G1_ONA",
                        "event_type": event_type,
                        "tensor_id": self.tensor_id,
                        "cycle_index": self.cycle_index,
                        "stage": self.stage,
                        # G6 required helical context
                        "helical_position": self._from_fixed_point(self.cumulative_phase) / (4 * math.pi),
                        "spinor_cycle_count": self.spinor_cycle_count,
                        "chirality_phase": self._from_fixed_point(self.chirality_phase),
                        **kw
                    }
                    
                    # Log to console/file via standard logging
                    logger.debug("ONA Event: %s", evt)
                    
                    # Delegate to genetic memory for proper trace recording
                    self.genetic_memory.record_event(evt)
            
                # ───────────────────────── utility methods ─────────────────────────────
                def get_anti_correlation_info(self) -> Dict[str, Any]:
                    """Get anti-correlation structure information.
                    
                    Returns:
                        Dictionary with anti-correlation details
                    """
                    return {
                        "block_structure": self.block_structure,
                        "anti_correlation_active": True,
                        "block_count": 2,
                        "degrees_of_freedom": self.degrees_of_freedom
                    }
            
                def get_threshold_info(self) -> Dict[str, float]:
                    """Get threshold information in human-readable format.
                    
                    Returns:
                        Dictionary with threshold values converted to floats
                    """
                    return {
                        "threshold_angle": self._from_fixed_point(self.threshold_angle),
                        "accumulated_threshold": self._from_fixed_point(self.accumulated_threshold),
                        "sensitivity_factor": self._from_fixed_point(self.threshold_angle) / 4,
                        "cgm_gamma_value": self._from_fixed_point(self.threshold_angle)
                    }
            
                def get_phase_info(self) -> Dict[str, float]:
                    """Get current phase information in human-readable format.
                    
                    Returns:
                        Dictionary with phase values converted to floats
                    """
                    return {
                        "amplitude": self._from_fixed_point(self.amplitude),
                        "cumulative_phase": self._from_fixed_point(self.cumulative_phase),
                        "chirality_phase": self._from_fixed_point(self.chirality_phase),
                        "last_epsilon": self._from_fixed_point(self.last_epsilon),
                        "helical_position": self._from_fixed_point(self.cumulative_phase) / (4 * math.pi),
                        "spinor_cycle_count": self.spinor_cycle_count
                    }
            
                def get_structure_info(self) -> Dict[str, Any]:
                    """Get structural information about the tensor.
                    
                    Returns:
                        Dictionary with tensor structure details
                    """
                    return {
                        "shape": self.SHAPE,
                        "shape_2d": (6, 2),  # Flattened representation
                        "nonzeros": self.NONZEROS,
                        "degrees_of_freedom": self.degrees_of_freedom,
                        "gpu_available": self.gpu_available,
                        "anti_correlation_blocks": 2,
                        "checksum": self.state_checksum
                    }
            
                def is_spawn_eligible(self) -> bool:
                    """Check if tensor is eligible for spawning.
                    
                    ONA stage is not directly spawn-eligible. Spawning occurs at BU_En
                    stage after completing the full cycle and reaching 4π.
                    
                    Returns:
                        Always False for ONA stage
                    """
                    return False
            
                def reconstruct_3d_structure(self) -> np.ndarray:
                    """Reconstruct the full 3D anti-correlated structure.
                    
                    Returns:
                        3D numpy array with shape (2, 3, 2) showing the anti-correlated blocks
                    """
                    # Reconstruct 2D from CSR
                    values = []
                    for encoded in self.data:
                        if encoded == 0b01:
                            values.append(1)
                        elif encoded == 0b11:
                            values.append(-1)
            
                    csr = csr_matrix((values, self.indices, self.indptr), shape=(6, 2))
                    dense_2d = csr.toarray()
                    
                    # Reshape to 3D structure
                    return dense_2d.reshape(2, 3, 2)
            
                def get_cgm_compliance_info(self) -> Dict[str, Any]:
                    """Get CGM compliance and derivation information.
                    
                    Returns:
                        Dictionary with CGM-derived values and their sources
                    """
                    return {
                        "cs_memory_source": "ALPHA (π/2)",
                        "cs_memory_value": self._from_fixed_point(self.cs_memory),
                        "threshold_angle_source": "GAMMA (π/4)",
                        "threshold_angle_value": self._from_fixed_point(self.threshold_angle),
                        "accumulated_threshold_derivation": "β + γ (UNA + ONA)",
                        "accumulated_threshold_value": self._from_fixed_point(self.accumulated_threshold),
                        "quantization_parameter": M_P,
                        "sensitivity_derivation": "GAMMA/4",
                        "all_parameters_cgm_derived": True
                    }
            
                def __repr__(self) -> str:
                    """String representation of ONA observation."""
                    return (f"ONAObservation(tensor_id={self.tensor_id}, "
                            f"cycle={self.cycle_index}, "
                            f"amplitude={self._from_fixed_point(self.amplitude):.6f}, "
                            f"anti_corr=True, "
                            f"helical_pos={self._from_fixed_point(self.cumulative_phase)/(4*math.pi):.4f}, "
                            f"spinor_cycle={self.spinor_cycle_count})")
            
                def __str__(self) -> str:
                    """Human-readable string representation."""
                    helical_pos = self._from_fixed_point(self.cumulative_phase) / (4 * math.pi)
                    return (f"ONA Observation τ{self.tensor_id} "
                            f"(cycle {self.cycle_index}, anti-correlated, "
                            f"helical {helical_pos:.4f}, spinor {self.spinor_cycle_count})")
            ```
            
        - `gyro_si/g1_gyroalignment/bu_in/g4_governance.py`
        - `gyro_si/g1_gyroalignment/bu_en/g5_governance.py`
    - **Batch 2.3: Genetic Memory & The Runner**
        - `gyro_si/g1_gyroalignment/genetic_memory.py`
        - `gyro_si/g1_gyroalignment/runner.py`
    
    ---
    
    ### **Phase 3: The Information Coordinator (G2 GyroInformation)**
    
    - **Batch 3.1: Lexicon & Memory**
        - `gyro_si/g2_gyroinformation/epigenetic_memory.py`
        - `gyro_si/g2_gyroinformation/cs/g1_governance.py`
        - `gyro_si/g2_gyroinformation/una/g2_governance.py`
        - `gyro_si/g2_gyroinformation/ona/g3_governance.py`
        - `gyro_si/g2_gyroinformation/bu_in/g4_governance.py`
        - `gyro_si/g2_gyroinformation/bu_en/synthesis.py`
    - **Batch 3.2: Runner**
        - `gyro_si/g2_gyroinformation/runner.py`
    
    ---
    
    ### **Phase 4: The Interactive Interface (G3 GyroInference)**
    
    - **Batch 4.1: Stage Modules**
        - `gyro_si/g3_gyroinference/cs/g1_governance.py`
        - `gyro_si/g3_gyroinference/una/g2_governance.py`
        - `gyro_si/g3_gyroinference/ona/g3_governance.py`
        - `gyro_si/g3_gyroinference/bu_in/g4_governance.py`
        - `gyro_si/g3_gyroinference/bu_en/synthesis.py`
        - `gyro_si/g3_gyroinference/structural_memory.py`
        - *(If a UI is present, its path and assets directory should be specified separately, e.g., `gyro_si/g3_gyroinference/ona/interface/` and `assets/`, if those exist)*
    - **Batch 4.2: Runner**
        - `gyro_si/g3_gyroinference/runner.py`
    
    ---
    
    ### **Phase 5: The Strategic Observer (G4 GyroIntelligence Ingress)**
    
    - **Batch 5.1: Analytics & Observation**
        - `gyro_si/g4_gyrointelligence_in/cs/g1_governance.py`
        - `gyro_si/g4_gyrointelligence_in/una/g2_governance.py`
        - `gyro_si/g4_gyrointelligence_in/ona/g3_governance.py`
        - `gyro_si/g4_gyrointelligence_in/bu_in/g4_governance.py`
        - `gyro_si/g4_gyrointelligence_in/bu_en/synthesis.py`
        - `gyro_si/g4_gyrointelligence_in/somatic_memory.py`
    - **Batch 5.2: Runner**
        - `gyro_si/g4_gyrointelligence_in/runner.py`
    
    ---
    
    ### **Phase 6: The Executive Governor (G5 GyroIntelligence Egress)**
    
    - **Batch 6.1: Governance, Policy & Memory**
        - `gyro_si/g5_gyrointelligence_en/cs/g1_governance.py`
        - `gyro_si/g5_gyrointelligence_en/una/g2_governance.py`
        - `gyro_si/g5_gyrointelligence_en/ona/g3_governance.py`
        - `gyro_si/g5_gyrointelligence_en/bu_in/g4_governance.py`
        - `gyro_si/g5_gyrointelligence_en/bu_en/synthesis.py`
        - `gyro_si/g5_gyrointelligence_en/immunity_memory.py`
    - **Batch 6.2: Runner**
        - `gyro_si/g5_gyrointelligence_en/runner.py`
    
    ---